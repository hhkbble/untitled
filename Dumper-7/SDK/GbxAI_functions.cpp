#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxAI

#include "Basic.hpp"

#include "GbxAI_classes.hpp"
#include "GbxAI_parameters.hpp"


namespace SDK
{

// Function GbxAI.Cover.SetCoverEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACover::SetCoverEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Cover", "SetCoverEnabled");

	Params::Cover_SetCoverEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.CoverSlotComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverSlotComponent::SetEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSlotComponent", "SetEnabled");

	Params::CoverSlotComponent_SetEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.CoverSlotComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoverSlotComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSlotComponent", "IsEnabled");

	Params::CoverSlotComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.CoverStatics.AIScriptedCover
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Cover                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxBrainExec*                          Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCoverStatics::AIScriptedCover(class AActor* AIActor, class AActor* Cover, EGbxBrainExec* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoverStatics", "AIScriptedCover");

	Params::CoverStatics_AIScriptedCover Parms{};

	Parms.AIActor = AIActor;
	Parms.Cover = Cover;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GbxChildActorComponent.GetOrWaitForChildActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGbxChildActorComponent*          Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor**                          Child                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxChildActorComponent::GetOrWaitForChildActor(class UGbxChildActorComponent* Component, class AActor** Child, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxChildActorComponent", "GetOrWaitForChildActor");

	Params::GbxChildActorComponent_GetOrWaitForChildActor Parms{};

	Parms.Component = Component;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Child != nullptr)
		*Child = Parms.Child;
}


// Function GbxAI.GbxChildActorComponent.DespawnChildActor
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UGbxChildActorComponent::DespawnChildActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponent", "DespawnChildActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponent.OnRep_ChildActorDefName
// (Final, Native, Protected)

void UGbxChildActorComponent::OnRep_ChildActorDefName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponent", "OnRep_ChildActorDefName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponent.OnRep_ChildActorState
// (Final, Native, Protected)

void UGbxChildActorComponent::OnRep_ChildActorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponent", "OnRep_ChildActorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponent.OnRep_ReplicatedChildActor
// (Final, Native, Protected)

void UGbxChildActorComponent::OnRep_ReplicatedChildActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponent", "OnRep_ReplicatedChildActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponent.SpawnChildActor
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UGbxChildActorComponent::SpawnChildActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponent", "SpawnChildActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponent.GetChildActor
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxChildActorComponent::GetChildActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponent", "GetChildActor");

	Params::GbxChildActorComponent_GetChildActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxAIHeldActorComponent.OnHeldActorSpawned
// (Native, Public)
// Parameters:
// class AActor*                           NewHeldActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorComponent::OnHeldActorSpawned(class AActor* NewHeldActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAIHeldActorComponent", "OnHeldActorSpawned");

	Params::GbxAIHeldActorComponent_OnHeldActorSpawned Parms{};

	Parms.NewHeldActor = NewHeldActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIDebugDataReplicator.OnRep_AIPerfStats
// (Final, Native, Public)

void AGbxAIDebugDataReplicator::OnRep_AIPerfStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAIDebugDataReplicator", "OnRep_AIPerfStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIDebugDataReplicator.ServerSetClientListening
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class APlayerController*          ClientPC                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bListening                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxAIDebugDataReplicator::ServerSetClientListening(const class APlayerController* ClientPC, const bool bListening)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAIDebugDataReplicator", "ServerSetClientListening");

	Params::GbxAIDebugDataReplicator_ServerSetClientListening Parms{};

	Parms.ClientPC = ClientPC;
	Parms.bListening = bListening;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_Destroy
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_Destroy(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_Destroy");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_Destroy Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatorOverride                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_Drop(class AActor* AIActor, bool bRequestNewHeldActor, class FName ID, EGbxAIHeldFilterType FilterType, class AActor* InstigatorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_Drop");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_Drop Parms{};

	Parms.AIActor = AIActor;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.InstigatorOverride = InstigatorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_GetActors
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UGbxAIHeldActorFunctionLibrary::AIHeldActor_GetActors(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_GetActors");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_GetActors Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_Hide
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_Hide(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_Hide");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_Hide Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_SetChildActorDef
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                NewActorDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_SetChildActorDef(class AActor* AIActor, FGameDataHandleProperty_ NewActorDef, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_SetChildActorDef");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_SetChildActorDef Parms{};

	Parms.AIActor = AIActor;
	Parms.NewActorDef = NewActorDef;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_Show
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_Show(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_Show");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_Show Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_Spawn
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_Spawn(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_Spawn");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_Spawn Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_ThrowAtActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_ThrowAtActor(class AActor* AIActor, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_ThrowAtActor");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_ThrowAtActor Parms{};

	Parms.AIActor = AIActor;
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_ThrowAtTarget
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_ThrowAtTarget(class AActor* AIActor, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_ThrowAtTarget");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_ThrowAtTarget Parms{};

	Parms.AIActor = AIActor;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAIHeldActorFunctionLibrary.AIHeldActor_ThrowHeldActorAtLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ThrowAtLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAIHeldActorFunctionLibrary::AIHeldActor_ThrowHeldActorAtLocation(class AActor* AIActor, const struct FVector& ThrowAtLocation, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAIHeldActorFunctionLibrary", "AIHeldActor_ThrowHeldActorAtLocation");

	Params::GbxAIHeldActorFunctionLibrary_AIHeldActor_ThrowHeldActorAtLocation Parms{};

	Parms.AIActor = AIActor;
	Parms.ThrowAtLocation = std::move(ThrowAtLocation);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAttachableActorLibrary.AttachActorToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ChildActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ParentActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAttachableActorLibrary::AttachActorToActor(class AActor* ChildActor, class AActor* ParentActor, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAttachableActorLibrary", "AttachActorToActor");

	Params::GbxAttachableActorLibrary_AttachActorToActor Parms{};

	Parms.ChildActor = ChildActor;
	Parms.ParentActor = ParentActor;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAttachableActorLibrary.AttachActorToComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ChildActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAttachableActorLibrary::AttachActorToComponent(class AActor* ChildActor, class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAttachableActorLibrary", "AttachActorToComponent");

	Params::GbxAttachableActorLibrary_AttachActorToComponent Parms{};

	Parms.ChildActor = ChildActor;
	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxAttachableActorLibrary.DetachActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ChildActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAttachableActorLibrary::DetachActor(class AActor* ChildActor, EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAttachableActorLibrary", "DetachActor");

	Params::GbxAttachableActorLibrary_DetachActor Parms{};

	Parms.ChildActor = ChildActor;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxBrainFunctionLibrary.AbortScriptedBrainTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopImmediately                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AbortScriptedBrainTask(class AActor* AIActor, bool bStopImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AbortScriptedBrainTask");

	Params::GbxBrainFunctionLibrary_AbortScriptedBrainTask Parms{};

	Parms.AIActor = AIActor;
	Parms.bStopImmediately = bStopImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxBrainFunctionLibrary.AIReplaceDefaultTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxBrainTaskData*                Task                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AIReplaceDefaultTask(class AActor* AIActor, class UGbxBrainTaskData* Task)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AIReplaceDefaultTask");

	Params::GbxBrainFunctionLibrary_AIReplaceDefaultTask Parms{};

	Parms.AIActor = AIActor;
	Parms.Task = Task;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxBrainFunctionLibrary.AIResetDefaultTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AIResetDefaultTask(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AIResetDefaultTask");

	Params::GbxBrainFunctionLibrary_AIResetDefaultTask Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxBrainFunctionLibrary.AIScriptedLook
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxBrainExec*                          Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AIScriptedLook(class AActor* AIActor, class AActor* TargetActor, EGbxBrainExec* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AIScriptedLook");

	Params::GbxBrainFunctionLibrary_AIScriptedLook Parms{};

	Parms.AIActor = AIActor;
	Parms.TargetActor = TargetActor;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GbxBrainFunctionLibrary.AIScriptedMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GoalActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxBrainExec*                          Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AIScriptedMove(class AActor* AIActor, class AActor* GoalActor, EGbxBrainExec* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AIScriptedMove");

	Params::GbxBrainFunctionLibrary_AIScriptedMove Parms{};

	Parms.AIActor = AIActor;
	Parms.GoalActor = GoalActor;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GbxBrainFunctionLibrary.AIScriptedTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxBrainTaskData*                Task                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AIScriptedTask(class AActor* AIActor, class UGbxBrainTaskData* Task)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AIScriptedTask");

	Params::GbxBrainFunctionLibrary_AIScriptedTask Parms{};

	Parms.AIActor = AIActor;
	Parms.Task = Task;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxBrainFunctionLibrary.AIScriptedTeleport
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GoalLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxBrainExec*                          Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AIScriptedTeleport(class AActor* AIActor, const struct FVector& GoalLocation, EGbxBrainExec* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AIScriptedTeleport");

	Params::GbxBrainFunctionLibrary_AIScriptedTeleport Parms{};

	Parms.AIActor = AIActor;
	Parms.GoalLocation = std::move(GoalLocation);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GbxBrainFunctionLibrary.AIScriptedWait
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::AIScriptedWait(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "AIScriptedWait");

	Params::GbxBrainFunctionLibrary_AIScriptedWait Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxBrainFunctionLibrary.LockThinking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbort                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::LockThinking(class AActor* AIActor, class FName reason, bool Block, bool bAbort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "LockThinking");

	Params::GbxBrainFunctionLibrary_LockThinking Parms{};

	Parms.AIActor = AIActor;
	Parms.reason = reason;
	Parms.Block = Block;
	Parms.bAbort = bAbort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxBrainFunctionLibrary.UnlockThinking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBrainFunctionLibrary::UnlockThinking(class AActor* AIActor, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBrainFunctionLibrary", "UnlockThinking");

	Params::GbxBrainFunctionLibrary_UnlockThinking Parms{};

	Parms.AIActor = AIActor;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponentReplicator.OnRep_ChildActorDefName
// (Final, Native, Private)

void UGbxChildActorComponentReplicator::OnRep_ChildActorDefName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponentReplicator", "OnRep_ChildActorDefName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponentReplicator.OnRep_ChildActorState
// (Final, Native, Private)

void UGbxChildActorComponentReplicator::OnRep_ChildActorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponentReplicator", "OnRep_ChildActorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponentReplicator.OnRep_ReplicatedChildActor
// (Final, Native, Private)

void UGbxChildActorComponentReplicator::OnRep_ReplicatedChildActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponentReplicator", "OnRep_ReplicatedChildActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxChildActorComponentReplicator.OnRep_TargetName
// (Final, Native, Private)

void UGbxChildActorComponentReplicator::OnRep_TargetName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxChildActorComponentReplicator", "OnRep_TargetName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxNavTest_Targeting.StoreLastKnownLocation
// (Final, Native, Public, BlueprintCallable)

void AGbxNavTest_Targeting::StoreLastKnownLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxNavTest_Targeting", "StoreLastKnownLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.AIClearScriptedTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::AIClearScriptedTarget(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "AIClearScriptedTarget");

	Params::GbxTargetingFunctionLibrary_AIClearScriptedTarget Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.AIGetScriptedTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxTargetingFunctionLibrary::AIGetScriptedTarget(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "AIGetScriptedTarget");

	Params::GbxTargetingFunctionLibrary_AIGetScriptedTarget Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.AIScriptedScoringBoost
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxTargetScoringBoost                  ScoringBoost                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::AIScriptedScoringBoost(class AActor* AIActor, EGbxTargetScoringBoost ScoringBoost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "AIScriptedScoringBoost");

	Params::GbxTargetingFunctionLibrary_AIScriptedScoringBoost Parms{};

	Parms.AIActor = AIActor;
	Parms.ScoringBoost = ScoringBoost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.AISetScriptedTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyRestrictions                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::AISetScriptedTarget(class AActor* AIActor, class AActor* TargetActor, bool bApplyRestrictions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "AISetScriptedTarget");

	Params::GbxTargetingFunctionLibrary_AISetScriptedTarget Parms{};

	Parms.AIActor = AIActor;
	Parms.TargetActor = TargetActor;
	Parms.bApplyRestrictions = bApplyRestrictions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.EveryoneForget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::EveryoneForget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "EveryoneForget");

	Params::GbxTargetingFunctionLibrary_EveryoneForget Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.ForgetTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::ForgetTarget(class AActor* Actor, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "ForgetTarget");

	Params::GbxTargetingFunctionLibrary_ForgetTarget Parms{};

	Parms.Actor = Actor;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.GetAIScriptedScoringBoost
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxTargetScoringBoost                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGbxTargetScoringBoost UGbxTargetingFunctionLibrary::GetAIScriptedScoringBoost(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "GetAIScriptedScoringBoost");

	Params::GbxTargetingFunctionLibrary_GetAIScriptedScoringBoost Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.GetBestTargetableSocket
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Targeter                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseViewRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            SocketName                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         SocketLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent**                 Component                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTargetingFunctionLibrary::GetBestTargetableSocket(class AActor* target, class AActor* Targeter, bool bUseViewRotation, class FName* SocketName, struct FVector* SocketLocation, class USceneComponent** Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "GetBestTargetableSocket");

	Params::GbxTargetingFunctionLibrary_GetBestTargetableSocket Parms{};

	Parms.target = target;
	Parms.Targeter = Targeter;
	Parms.bUseViewRotation = bUseViewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SocketName != nullptr)
		*SocketName = Parms.SocketName;

	if (SocketLocation != nullptr)
		*SocketLocation = std::move(Parms.SocketLocation);

	if (Component != nullptr)
		*Component = Parms.Component;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.GetPrimaryTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxTargetingFunctionLibrary::GetPrimaryTarget(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "GetPrimaryTarget");

	Params::GbxTargetingFunctionLibrary_GetPrimaryTarget Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.GetPrimaryTargetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTargetingFunctionLibrary::GetPrimaryTargetLocation(class AActor* AIActor, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "GetPrimaryTargetLocation");

	Params::GbxTargetingFunctionLibrary_GetPrimaryTargetLocation Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.GetTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor**                          PrimaryTarget                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  TargetList                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::GetTarget(class AActor* AIActor, class AActor** PrimaryTarget, TArray<class AActor*>* TargetList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "GetTarget");

	Params::GbxTargetingFunctionLibrary_GetTarget Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PrimaryTarget != nullptr)
		*PrimaryTarget = Parms.PrimaryTarget;

	if (TargetList != nullptr)
		*TargetList = std::move(Parms.TargetList);
}


// Function GbxAI.GbxTargetingFunctionLibrary.GetTargetList
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UGbxTargetingFunctionLibrary::GetTargetList(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "GetTargetList");

	Params::GbxTargetingFunctionLibrary_GetTargetList Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.GetTargetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Targeter                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTargetingFunctionLibrary::GetTargetLocation(class AActor* Targeter, class AActor* target, struct FVector* OutLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "GetTargetLocation");

	Params::GbxTargetingFunctionLibrary_GetTargetLocation Parms{};

	Parms.Targeter = Targeter;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.LockPerceivability
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::LockPerceivability(class AActor* Actor, class FName reason, bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "LockPerceivability");

	Params::GbxTargetingFunctionLibrary_LockPerceivability Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.LockTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTargetingFunctionLibrary::LockTarget(class AActor* Actor, class FName reason, bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "LockTarget");

	Params::GbxTargetingFunctionLibrary_LockTarget Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTargetingFunctionLibrary.LockTargetability
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::LockTargetability(class AActor* Actor, class FName reason, bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "LockTargetability");

	Params::GbxTargetingFunctionLibrary_LockTargetability Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.LockTargetableByAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEveryoneForget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::LockTargetableByAI(class AActor* Actor, class FName reason, bool Block, bool bEveryoneForget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "LockTargetableByAI");

	Params::GbxTargetingFunctionLibrary_LockTargetableByAI Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;
	Parms.bEveryoneForget = bEveryoneForget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.LockTargeting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForget                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::LockTargeting(class AActor* Actor, class FName reason, bool Block, bool bForget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "LockTargeting");

	Params::GbxTargetingFunctionLibrary_LockTargeting Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;
	Parms.bForget = bForget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.RejoinAIGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::RejoinAIGroup(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "RejoinAIGroup");

	Params::GbxTargetingFunctionLibrary_RejoinAIGroup Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTargetingFunctionLibrary.SetInvisibleToAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTargetingFunctionLibrary::SetInvisibleToAI(class AActor* Actor, class FName reason, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTargetingFunctionLibrary", "SetInvisibleToAI");

	Params::GbxTargetingFunctionLibrary_SetInvisibleToAI Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTeamFunctionLibrary.GetAttitudeTowards
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Perceiver                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UGbxTeamFunctionLibrary::GetAttitudeTowards(class AActor* Perceiver, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "GetAttitudeTowards");

	Params::GbxTeamFunctionLibrary_GetAttitudeTowards Parms{};

	Parms.Perceiver = Perceiver;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTeamFunctionLibrary.GetDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxTeamIdHandle&          Team                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGbxTeamFunctionLibrary::GetDisplayName(const struct FGbxTeamIdHandle& Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "GetDisplayName");

	Params::GbxTeamFunctionLibrary_GetDisplayName Parms{};

	Parms.Team = std::move(Team);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTeamFunctionLibrary.GetTeam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ UGbxTeamFunctionLibrary::GetTeam(class AActor* AIActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "GetTeam");

	Params::GbxTeamFunctionLibrary_GetTeam Parms{};

	Parms.AIActor = AIActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTeamFunctionLibrary.GetTeamFromActorDef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                GbxActorDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ UGbxTeamFunctionLibrary::GetTeamFromActorDef(FGameDataHandleProperty_ GbxActorDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "GetTeamFromActorDef");

	Params::GbxTeamFunctionLibrary_GetTeamFromActorDef Parms{};

	Parms.GbxActorDef = GbxActorDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTeamFunctionLibrary.GetTeamID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxTeamIdHandle                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGbxTeamIdHandle UGbxTeamFunctionLibrary::GetTeamID(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "GetTeamID");

	Params::GbxTeamFunctionLibrary_GetTeamID Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTeamFunctionLibrary.IsOnTeam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Team                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTeamFunctionLibrary::IsOnTeam(class AActor* AIActor, FGameDataHandleProperty_ Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "IsOnTeam");

	Params::GbxTeamFunctionLibrary_IsOnTeam Parms{};

	Parms.AIActor = AIActor;
	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTeamFunctionLibrary.IsSameTeamId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxTeamIdHandle&          Team                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxTeamIdHandle&          OtherTeam                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTeamFunctionLibrary::IsSameTeamId(const struct FGbxTeamIdHandle& Team, const struct FGbxTeamIdHandle& OtherTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "IsSameTeamId");

	Params::GbxTeamFunctionLibrary_IsSameTeamId Parms{};

	Parms.Team = std::move(Team);
	Parms.OtherTeam = std::move(OtherTeam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GbxTeamFunctionLibrary.SetTeam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Team                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTeamFunctionLibrary::SetTeam(class AActor* AIActor, FGameDataHandleProperty_ Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "SetTeam");

	Params::GbxTeamFunctionLibrary_SetTeam Parms{};

	Parms.AIActor = AIActor;
	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTeamFunctionLibrary.SetTeamCollisionChannelFrom
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TeamActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTeamFunctionLibrary::SetTeamCollisionChannelFrom(class AActor* Actor, class AActor* TeamActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "SetTeamCollisionChannelFrom");

	Params::GbxTeamFunctionLibrary_SetTeamCollisionChannelFrom Parms{};

	Parms.Actor = Actor;
	Parms.TeamActor = TeamActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTeamFunctionLibrary.SetTeamID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxTeamIdHandle&          Team                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxTeamFunctionLibrary::SetTeamID(class AActor* Actor, const struct FGbxTeamIdHandle& Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTeamFunctionLibrary", "SetTeamID");

	Params::GbxTeamFunctionLibrary_SetTeamID Parms{};

	Parms.Actor = Actor;
	Parms.Team = std::move(Team);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxTerritory.GetTerritory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGbxTerritoryComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxTerritoryComponent* AGbxTerritory::GetTerritory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTerritory", "GetTerritory");

	Params::GbxTerritory_GetTerritory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GpsBlueprintLibrary.MakeGpsQueryRunData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGpsQueryAsset*                   Query                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGpsQueryRunData UGpsBlueprintLibrary::MakeGpsQueryRunData(class UGpsQueryAsset* Query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "MakeGpsQueryRunData");

	Params::GpsBlueprintLibrary_MakeGpsQueryRunData Parms{};

	Parms.Query = Query;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxAI.GpsBlueprintLibrary.RunGpsQueryActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor**                          Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGpsExec*                               Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::RunGpsQueryActor(class UObject* WorldContextObject, class AActor* owner, const struct FGpsQueryRunData& QueryData, class AActor** Result, EGpsExec* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "RunGpsQueryActor");

	Params::GpsBlueprintLibrary_RunGpsQueryActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GpsBlueprintLibrary.RunGpsQueryActorList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EGpsExec*                               Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   NumResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::RunGpsQueryActorList(class UObject* WorldContextObject, class AActor* owner, const struct FGpsQueryRunData& QueryData, TArray<class AActor*>* Result, EGpsExec* Exec, const struct FLatentActionInfo& LatentInfo, int32 NumResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "RunGpsQueryActorList");

	Params::GpsBlueprintLibrary_RunGpsQueryActorList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.NumResults = NumResults;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GpsBlueprintLibrary.RunGpsQueryVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector*                         Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGpsExec*                               Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::RunGpsQueryVector(class UObject* WorldContextObject, class AActor* owner, const struct FGpsQueryRunData& QueryData, struct FVector* Result, EGpsExec* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "RunGpsQueryVector");

	Params::GpsBlueprintLibrary_RunGpsQueryVector Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GpsBlueprintLibrary.RunGpsQueryVectorList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EGpsExec*                               Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   NumResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::RunGpsQueryVectorList(class UObject* WorldContextObject, class AActor* owner, const struct FGpsQueryRunData& QueryData, TArray<struct FVector>* Result, EGpsExec* Exec, const struct FLatentActionInfo& LatentInfo, int32 NumResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "RunGpsQueryVectorList");

	Params::GpsBlueprintLibrary_RunGpsQueryVectorList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.NumResults = NumResults;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxAI.GpsBlueprintLibrary.SetGpsName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGpsQueryRunData&          InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData*                OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             QueryName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::SetGpsName(const struct FGpsQueryRunData& InData, struct FGpsQueryRunData* OutData, class FName QueryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "SetGpsName");

	Params::GpsBlueprintLibrary_SetGpsName Parms{};

	Parms.InData = std::move(InData);
	Parms.QueryName = QueryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function GbxAI.GpsBlueprintLibrary.SetGpsParam_Actor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGpsQueryRunData&          InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData*                OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::SetGpsParam_Actor(const struct FGpsQueryRunData& InData, struct FGpsQueryRunData* OutData, class FName ParamName, class AActor* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "SetGpsParam_Actor");

	Params::GpsBlueprintLibrary_SetGpsParam_Actor Parms{};

	Parms.InData = std::move(InData);
	Parms.ParamName = ParamName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function GbxAI.GpsBlueprintLibrary.SetGpsParam_Float
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGpsQueryRunData&          InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData*                OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::SetGpsParam_Float(const struct FGpsQueryRunData& InData, struct FGpsQueryRunData* OutData, class FName ParamName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "SetGpsParam_Float");

	Params::GpsBlueprintLibrary_SetGpsParam_Float Parms{};

	Parms.InData = std::move(InData);
	Parms.ParamName = ParamName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function GbxAI.GpsBlueprintLibrary.SetGpsParam_Int
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGpsQueryRunData&          InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData*                OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::SetGpsParam_Int(const struct FGpsQueryRunData& InData, struct FGpsQueryRunData* OutData, class FName ParamName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "SetGpsParam_Int");

	Params::GpsBlueprintLibrary_SetGpsParam_Int Parms{};

	Parms.InData = std::move(InData);
	Parms.ParamName = ParamName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function GbxAI.GpsBlueprintLibrary.SetGpsParam_NumericRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGpsQueryRunData&          InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData*                OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNumericRange&             Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::SetGpsParam_NumericRange(const struct FGpsQueryRunData& InData, struct FGpsQueryRunData* OutData, class FName ParamName, const struct FNumericRange& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "SetGpsParam_NumericRange");

	Params::GpsBlueprintLibrary_SetGpsParam_NumericRange Parms{};

	Parms.InData = std::move(InData);
	Parms.ParamName = ParamName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function GbxAI.GpsBlueprintLibrary.SetGpsParam_Rotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGpsQueryRunData&          InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData*                OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::SetGpsParam_Rotator(const struct FGpsQueryRunData& InData, struct FGpsQueryRunData* OutData, class FName ParamName, const struct FRotator& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "SetGpsParam_Rotator");

	Params::GpsBlueprintLibrary_SetGpsParam_Rotator Parms{};

	Parms.InData = std::move(InData);
	Parms.ParamName = ParamName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function GbxAI.GpsBlueprintLibrary.SetGpsParam_Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGpsQueryRunData&          InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGpsQueryRunData*                OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGpsBlueprintLibrary::SetGpsParam_Vector(const struct FGpsQueryRunData& InData, struct FGpsQueryRunData* OutData, class FName ParamName, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GpsBlueprintLibrary", "SetGpsParam_Vector");

	Params::GpsBlueprintLibrary_SetGpsParam_Vector Parms{};

	Parms.InData = std::move(InData);
	Parms.ParamName = ParamName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function GbxAI.GpsTestComponent.RefreshContexts
// (Final, Native, Private)

void UGpsTestComponent::RefreshContexts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GpsTestComponent", "RefreshContexts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxEffectAreaFunctionLibrary.CreateEffectArea
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFollowOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxEffectAreaAffectType                type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxEffectAreaFunctionLibrary::CreateEffectArea(class AActor* owner, bool bFollowOwner, const struct FVector& Center, float Radius, float HalfHeight, EGbxEffectAreaAffectType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectAreaFunctionLibrary", "CreateEffectArea");

	Params::GbxEffectAreaFunctionLibrary_CreateEffectArea Parms{};

	Parms.owner = owner;
	Parms.bFollowOwner = bFollowOwner;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxAI.GbxEffectAreaFunctionLibrary.RemoveAllEffectAreas
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxEffectAreaFunctionLibrary::RemoveAllEffectAreas(class AActor* owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectAreaFunctionLibrary", "RemoveAllEffectAreas");

	Params::GbxEffectAreaFunctionLibrary_RemoveAllEffectAreas Parms{};

	Parms.owner = owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

