#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxGame

#include "Basic.hpp"

#include "GbxGame_classes.hpp"
#include "GbxGame_parameters.hpp"


namespace SDK
{

// Function GbxGame.GbxShapeComponent.SetBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InBoxExtent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "SetBoxExtent");

	Params::GbxShapeComponent_SetBoxExtent Parms{};

	Parms.InBoxExtent = std::move(InBoxExtent);
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxShapeComponent.SetCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "SetCapsuleHalfHeight");

	Params::GbxShapeComponent_SetCapsuleHalfHeight Parms{};

	Parms.HalfHeight = HalfHeight;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxShapeComponent.SetCapsuleRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "SetCapsuleRadius");

	Params::GbxShapeComponent_SetCapsuleRadius Parms{};

	Parms.Radius = Radius;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxShapeComponent.SetCapsuleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "SetCapsuleSize");

	Params::GbxShapeComponent_SetCapsuleSize Parms{};

	Parms.InRadius = InRadius;
	Parms.InHalfHeight = InHalfHeight;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxShapeComponent.SetShapeConfig
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxShapeConfig&           NewShapeConfig                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::SetShapeConfig(const struct FGbxShapeConfig& NewShapeConfig, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "SetShapeConfig");

	Params::GbxShapeComponent_SetShapeConfig Parms{};

	Parms.NewShapeConfig = std::move(NewShapeConfig);
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxShapeComponent.SetSphereRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSphereRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "SetSphereRadius");

	Params::GbxShapeComponent_SetSphereRadius Parms{};

	Parms.InSphereRadius = InSphereRadius;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxShapeComponent.GetScaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxShapeComponent::GetScaledBoxExtent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetScaledBoxExtent");

	Params::GbxShapeComponent_GetScaledBoxExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetScaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetScaledCapsuleHalfHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetScaledCapsuleHalfHeight");

	Params::GbxShapeComponent_GetScaledCapsuleHalfHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetScaledCapsuleHalfHeight_WithoutHemisphere() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetScaledCapsuleHalfHeight_WithoutHemisphere");

	Params::GbxShapeComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetScaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetScaledCapsuleRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetScaledCapsuleRadius");

	Params::GbxShapeComponent_GetScaledCapsuleRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetScaledCapsuleSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float*                                  OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutHalfHeight                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::GetScaledCapsuleSize(float* OutRadius, float* OutHalfHeight) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetScaledCapsuleSize");

	Params::GbxShapeComponent_GetScaledCapsuleSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeight != nullptr)
		*OutHalfHeight = Parms.OutHalfHeight;
}


// Function GbxGame.GbxShapeComponent.GetScaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float*                                  OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutHalfHeightWithoutHemisphere                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::GetScaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetScaledCapsuleSize_WithoutHemisphere");

	Params::GbxShapeComponent_GetScaledCapsuleSize_WithoutHemisphere Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = Parms.OutHalfHeightWithoutHemisphere;
}


// Function GbxGame.GbxShapeComponent.GetScaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetScaledSphereRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetScaledSphereRadius");

	Params::GbxShapeComponent_GetScaledSphereRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetShapeScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetShapeScale");

	Params::GbxShapeComponent_GetShapeScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetShapeType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGGbxShapeComponentType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGGbxShapeComponentType UGbxShapeComponent::GetShapeType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetShapeType");

	Params::GbxShapeComponent_GetShapeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetUnscaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxShapeComponent::GetUnscaledBoxExtent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetUnscaledBoxExtent");

	Params::GbxShapeComponent_GetUnscaledBoxExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetUnscaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetUnscaledCapsuleHalfHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetUnscaledCapsuleHalfHeight");

	Params::GbxShapeComponent_GetUnscaledCapsuleHalfHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetUnscaledCapsuleHalfHeight_WithoutHemisphere() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetUnscaledCapsuleHalfHeight_WithoutHemisphere");

	Params::GbxShapeComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetUnscaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetUnscaledCapsuleRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetUnscaledCapsuleRadius");

	Params::GbxShapeComponent_GetUnscaledCapsuleRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxShapeComponent.GetUnscaledCapsuleSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float*                                  OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutHalfHeight                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::GetUnscaledCapsuleSize(float* OutRadius, float* OutHalfHeight) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetUnscaledCapsuleSize");

	Params::GbxShapeComponent_GetUnscaledCapsuleSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeight != nullptr)
		*OutHalfHeight = Parms.OutHalfHeight;
}


// Function GbxGame.GbxShapeComponent.GetUnscaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float*                                  OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutHalfHeightWithoutHemisphere                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxShapeComponent::GetUnscaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetUnscaledCapsuleSize_WithoutHemisphere");

	Params::GbxShapeComponent_GetUnscaledCapsuleSize_WithoutHemisphere Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = Parms.OutHalfHeightWithoutHemisphere;
}


// Function GbxGame.GbxShapeComponent.GetUnscaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxShapeComponent::GetUnscaledSphereRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxShapeComponent", "GetUnscaledSphereRadius");

	Params::GbxShapeComponent_GetUnscaledSphereRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.AttachToTarget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                target                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bSnapToTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProjectileDetachAction                 DetachedAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool Aprojectile::AttachToTarget(const struct FHitResult& target, bool bSnapToTarget, EProjectileDetachAction DetachedAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "AttachToTarget");

	Params::projectile_AttachToTarget Parms{};

	Parms.target = std::move(target);
	Parms.bSnapToTarget = bSnapToTarget;
	Parms.DetachedAction = DetachedAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.CauseDamage
// (Native, Protected, BlueprintCallable)

void Aprojectile::CauseDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "CauseDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.DetachFromTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EProjectileDetachAction                 DetachAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::DetachFromTarget(EProjectileDetachAction DetachAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "DetachFromTarget");

	Params::projectile_DetachFromTarget Parms{};

	Parms.DetachAction = DetachAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.Explode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::Explode(uint8 Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "Explode");

	Params::projectile_Explode Parms{};

	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnAttachedActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::OnAttachedActorDestroyed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnAttachedActorDestroyed");

	Params::projectile_OnAttachedActorDestroyed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnAttachedDestructibleFractured
// (Final, Native, Private)
// Parameters:
// bool                                    bMeshSwap                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::OnAttachedDestructibleFractured(bool bMeshSwap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnAttachedDestructibleFractured");

	Params::projectile_OnAttachedDestructibleFractured Parms{};

	Parms.bMeshSwap = bMeshSwap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnHomingTargetDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::OnHomingTargetDestroyed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnHomingTargetDestroyed");

	Params::projectile_OnHomingTargetDestroyed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_AttachedState
// (Final, Native, Protected)

void Aprojectile::OnRep_AttachedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_AttachedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_CustomGravityScale
// (Final, Native, Private)

void Aprojectile::OnRep_CustomGravityScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_CustomGravityScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_DamageModifierFlags
// (Final, Native, Private)

void Aprojectile::OnRep_DamageModifierFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_DamageModifierFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_Dropped
// (Final, Native, Private)

void Aprojectile::OnRep_Dropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_Dropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_DrunkenMovementSeed
// (Final, Native, Private)

void Aprojectile::OnRep_DrunkenMovementSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_DrunkenMovementSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_Exploded
// (Final, Native, Private)

void Aprojectile::OnRep_Exploded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_Exploded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_FactsConduit
// (Final, Native, Protected)

void Aprojectile::OnRep_FactsConduit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_FactsConduit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_GestaltMeshParts
// (Final, Native, Public)

void Aprojectile::OnRep_GestaltMeshParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_GestaltMeshParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_HealthState
// (Final, Native, Protected)

void Aprojectile::OnRep_HealthState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_HealthState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_HomingTarget
// (Final, Native, Private)

void Aprojectile::OnRep_HomingTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_HomingTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_InFlight
// (Final, Native, Private)

void Aprojectile::OnRep_InFlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_InFlight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_IsHoming
// (Final, Native, Private)

void Aprojectile::OnRep_IsHoming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_IsHoming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_StartFuse
// (Final, Native, Private)

void Aprojectile::OnRep_StartFuse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_StartFuse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_Thrown
// (Final, Native, Private)

void Aprojectile::OnRep_Thrown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_Thrown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.OnRep_Velocity
// (Final, Native, Private)

void Aprojectile::OnRep_Velocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "OnRep_Velocity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetCustomGravityScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   GravityScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetCustomGravityScale(float GravityScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetCustomGravityScale");

	Params::projectile_SetCustomGravityScale Parms{};

	Parms.GravityScale = GravityScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetDrunkenMovementState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetDrunkenMovementState(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetDrunkenMovementState");

	Params::projectile_SetDrunkenMovementState Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetHoming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHoming                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetHoming(bool bHoming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetHoming");

	Params::projectile_SetHoming Parms{};

	Parms.bHoming = bHoming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetHomingTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetHomingTarget(class AActor* Actor, class USceneComponent* Component, class FName socket, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetHomingTarget");

	Params::projectile_SetHomingTarget Parms{};

	Parms.Actor = Actor;
	Parms.Component = Component;
	Parms.socket = socket;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetHomingTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetHomingTargetLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetHomingTargetLocation");

	Params::projectile_SetHomingTargetLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetSpawnSpeedScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SpeedScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetSpawnSpeedScale(float SpeedScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetSpawnSpeedScale");

	Params::projectile_SetSpawnSpeedScale Parms{};

	Parms.SpeedScale = SpeedScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetSpawnVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InSpawnVelocity                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetSpawnVelocity(const struct FVector& InSpawnVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetSpawnVelocity");

	Params::projectile_SetSpawnVelocity Parms{};

	Parms.InSpawnVelocity = std::move(InSpawnVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetupProximityTrigger
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void Aprojectile::SetupProximityTrigger(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetupProximityTrigger");

	Params::projectile_SetupProximityTrigger Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SetVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SetVelocity(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SetVelocity");

	Params::projectile_SetVelocity Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.SimulatePhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSimulate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::SimulatePhysics(bool bSimulate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "SimulatePhysics");

	Params::projectile_SimulatePhysics Parms{};

	Parms.bSimulate = bSimulate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.StartFuse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FuseTime_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::StartFuse(float FuseTime_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "StartFuse");

	Params::projectile_StartFuse Parms{};

	Parms.FuseTime_0 = FuseTime_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.StartSimAudio
// (Native, Protected, BlueprintCallable)

void Aprojectile::StartSimAudio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "StartSimAudio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.StopBlockingPawns
// (Final, Native, Public, BlueprintCallable)

void Aprojectile::StopBlockingPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "StopBlockingPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.StopSimAudio
// (Final, Native, Protected, BlueprintCallable)

void Aprojectile::StopSimAudio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "StopSimAudio");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.ToggleProximityTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bTrigger                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Aprojectile::ToggleProximityTrigger(const bool bTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "ToggleProximityTrigger");

	Params::projectile_ToggleProximityTrigger Parms{};

	Parms.bTrigger = bTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.projectile.GetExplosionFlags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 Aprojectile::GetExplosionFlags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "GetExplosionFlags");

	Params::projectile_GetExplosionFlags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.GetGpsQueryName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName Aprojectile::GetGpsQueryName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "GetGpsQueryName");

	Params::projectile_GetGpsQueryName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.GetHeldImpactEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FImpactEffectSelection           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FImpactEffectSelection Aprojectile::GetHeldImpactEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "GetHeldImpactEffect");

	Params::projectile_GetHeldImpactEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.GetImpactedActorHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult*                      OutResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool Aprojectile::GetImpactedActorHitResult(struct FHitResult* OutResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "GetImpactedActorHitResult");

	Params::projectile_GetImpactedActorHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.HasDamageModifierFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDamageModifierFlag                     Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool Aprojectile::HasDamageModifierFlag(EDamageModifierFlag Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "HasDamageModifierFlag");

	Params::projectile_HasDamageModifierFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.HasExploded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool Aprojectile::HasExploded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "HasExploded");

	Params::projectile_HasExploded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.IsHeld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool Aprojectile::IsHeld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "IsHeld");

	Params::projectile_IsHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.IsInFlight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool Aprojectile::IsInFlight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "IsInFlight");

	Params::projectile_IsInFlight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.projectile.ShouldAttachToTarget
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileAttachFilterData&AttachTo                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool Aprojectile::ShouldAttachToTarget(class AActor* TargetActor, const struct FProjectileAttachFilterData& AttachTo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("projectile", "ShouldAttachToTarget");

	Params::projectile_ShouldAttachToTarget Parms{};

	Parms.TargetActor = TargetActor;
	Parms.AttachTo = std::move(AttachTo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillManagedResourceType_Actor.Destroy
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillManagedResourceType_Actor::Destroy(class UGbxSkillScript* Context, class AActor* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillManagedResourceType_Actor", "Destroy");

	Params::GbxSkillManagedResourceType_Actor_Destroy Parms{};

	Parms.Context = Context;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillManagedResourceType_Actor.Register
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Handler                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Group                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillManagedResourceType_Actor::Register(class UGbxSkillScript* Context, class AActor* Value, class FName Handler, FGbxDefPtrProperty_ Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillManagedResourceType_Actor", "Register");

	Params::GbxSkillManagedResourceType_Actor_Register Parms{};

	Parms.Context = Context;
	Parms.Value = Value;
	Parms.Handler = Handler;
	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillManagedResourceType_Actor.Unregister
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Group                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillManagedResourceType_Actor::Unregister(class UGbxSkillScript* Context, class AActor* Value, FGbxDefPtrProperty_ Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillManagedResourceType_Actor", "Unregister");

	Params::GbxSkillManagedResourceType_Actor_Unregister Parms{};

	Parms.Context = Context;
	Parms.Value = Value;
	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformComponent.OnBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxMovingPlatformComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformComponent", "OnBeginOverlap");

	Params::GbxMovingPlatformComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformComponent.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMovingPlatformComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformComponent", "OnEndOverlap");

	Params::GbxMovingPlatformComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformComponent.OnRep_MovingPlatformController
// (Final, Native, Protected)

void UGbxMovingPlatformComponent::OnRep_MovingPlatformController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformComponent", "OnRep_MovingPlatformController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformComponent.OnRep_SplineTrackActor
// (Final, Native, Protected)

void UGbxMovingPlatformComponent::OnRep_SplineTrackActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformComponent", "OnRep_SplineTrackActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAIHeldProjectileComponent.GetHeldProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class Aprojectile*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class Aprojectile* UGbxAIHeldProjectileComponent::GetHeldProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAIHeldProjectileComponent", "GetHeldProjectile");

	Params::GbxAIHeldProjectileComponent_GetHeldProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillManagedResourceType_ActorComponent.Destroy
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  Value                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillManagedResourceType_ActorComponent::Destroy(class UGbxSkillScript* Context, class UActorComponent* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillManagedResourceType_ActorComponent", "Destroy");

	Params::GbxSkillManagedResourceType_ActorComponent_Destroy Parms{};

	Parms.Context = Context;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillManagedResourceType_ActorComponent.Register
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  Value                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Handler                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Group                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillManagedResourceType_ActorComponent::Register(class UGbxSkillScript* Context, class UActorComponent* Value, class FName Handler, FGbxDefPtrProperty_ Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillManagedResourceType_ActorComponent", "Register");

	Params::GbxSkillManagedResourceType_ActorComponent_Register Parms{};

	Parms.Context = Context;
	Parms.Value = Value;
	Parms.Handler = Handler;
	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillManagedResourceType_ActorComponent.Unregister
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  Value                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Group                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillManagedResourceType_ActorComponent::Unregister(class UGbxSkillScript* Context, class UActorComponent* Value, FGbxDefPtrProperty_ Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillManagedResourceType_ActorComponent", "Unregister");

	Params::GbxSkillManagedResourceType_ActorComponent_Unregister Parms{};

	Parms.Context = Context;
	Parms.Value = Value;
	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorScript.StaticGetInterfaceScripts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          ContextSource                                          (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           InterfaceClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGbxActorScript*>*         Scripts                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxActorScript::StaticGetInterfaceScripts(class UObject* ContextSource, TSubclassOf<class IInterface> InterfaceClass, TArray<class UGbxActorScript*>* Scripts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorScript", "StaticGetInterfaceScripts");

	Params::GbxActorScript_StaticGetInterfaceScripts Parms{};

	Parms.ContextSource = ContextSource;
	Parms.InterfaceClass = InterfaceClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Scripts != nullptr)
		*Scripts = std::move(Parms.Scripts);
}


// Function GbxGame.GbxActorScript.StaticIsScriptStateEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             GraphName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ContextSource                                          (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxActorScript::StaticIsScriptStateEnabled(class FName GraphName, class UObject* ContextSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorScript", "StaticIsScriptStateEnabled");

	Params::GbxActorScript_StaticIsScriptStateEnabled Parms{};

	Parms.GraphName = GraphName;
	Parms.ContextSource = ContextSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorScript.StaticSetScriptStateEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             GraphName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ContextSource                                          (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActorScript::StaticSetScriptStateEnabled(class FName GraphName, bool bEnabled, class UObject* ContextSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorScript", "StaticSetScriptStateEnabled");

	Params::GbxActorScript_StaticSetScriptStateEnabled Parms{};

	Parms.GraphName = GraphName;
	Parms.bEnabled = bEnabled;
	Parms.ContextSource = ContextSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorScript.OnBeginPlay
// (Event, Public, BlueprintEvent)

void UGbxActorScript::OnBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "OnBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxActorScript.OnEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActorScript::OnEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "OnEndPlay");

	Params::GbxActorScript_OnEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxActorScript.OnInit
// (Event, Public, BlueprintEvent)

void UGbxActorScript::OnInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "OnInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxActorScript.OnStateDisabled
// (Event, Public, BlueprintEvent)

void UGbxActorScript::OnStateDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "OnStateDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxActorScript.OnStateEnabled
// (Event, Public, BlueprintEvent)

void UGbxActorScript::OnStateEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "OnStateEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxActorScript.SetScriptStateEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GraphName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActorScript::SetScriptStateEnabled(class FName GraphName, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "SetScriptStateEnabled");

	Params::GbxActorScript_SetScriptStateEnabled Parms{};

	Parms.GraphName = GraphName;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorScript.GetAssociatedActor
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxActorScript::GetAssociatedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "GetAssociatedActor");

	Params::GbxActorScript_GetAssociatedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorScript.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class IGbxActorScriptInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IGbxActorScriptInterface> UGbxActorScript::GetOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "GetOwner");

	Params::GbxActorScript_GetOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorScript.GetStableRandomStream
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SeedOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRandomStream UGbxActorScript::GetStableRandomStream(int32 SeedOffset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "GetStableRandomStream");

	Params::GbxActorScript_GetStableRandomStream Parms{};

	Parms.SeedOffset = SeedOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorScript.HasAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxActorScript::HasAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "HasAuthority");

	Params::GbxActorScript_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorScript.IsScriptStateEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GraphName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxActorScript::IsScriptStateEnabled(class FName GraphName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "IsScriptStateEnabled");

	Params::GbxActorScript_IsScriptStateEnabled Parms{};

	Parms.GraphName = GraphName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorScript.UserConstructionScript
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActorScript::UserConstructionScript(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript", "UserConstructionScript");

	Params::GbxActorScript_UserConstructionScript Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.GetTrickValueActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxTrickScript::GetTrickValueActor(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueActor");

	Params::GbxTrickScript_GetTrickValueActor Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueBool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTrickScript::GetTrickValueBool(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueBool");

	Params::GbxTrickScript_GetTrickValueBool Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxTrickScript::GetTrickValueFloat(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueFloat");

	Params::GbxTrickScript_GetTrickValueFloat Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxTrickScript::GetTrickValueInt(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueInt");

	Params::GbxTrickScript_GetTrickValueInt Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxTrickScript::GetTrickValueName(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueName");

	Params::GbxTrickScript_GetTrickValueName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueNumericRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNumericRange                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FNumericRange UGbxTrickScript::GetTrickValueNumericRange(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueNumericRange");

	Params::GbxTrickScript_GetTrickValueNumericRange Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UGbxTrickScript::GetTrickValueObject(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueObject");

	Params::GbxTrickScript_GetTrickValueObject Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UGbxTrickScript::GetTrickValueRotator(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueRotator");

	Params::GbxTrickScript_GetTrickValueRotator Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueString
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGbxTrickScript::GetTrickValueString(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueString");

	Params::GbxTrickScript_GetTrickValueString Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueTrajectoryOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectoryOptions               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTrajectoryOptions UGbxTrickScript::GetTrickValueTrajectoryOptions(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueTrajectoryOptions");

	Params::GbxTrickScript_GetTrickValueTrajectoryOptions Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.GetTrickValueVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxTrickScript::GetTrickValueVector(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetTrickValueVector");

	Params::GbxTrickScript_GetTrickValueVector Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.OnBegin_Mut
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnBegin_Mut(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnBegin_Mut");

	Params::GbxTrickScript_OnBegin_Mut Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.OnEnd_Mut
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxTrickEnd                            EndType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnEnd_Mut(class AActor* Actor, EGbxTrickEnd EndType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnEnd_Mut");

	Params::GbxTrickScript_OnEnd_Mut Parms{};

	Parms.Actor = Actor;
	Parms.EndType = EndType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.OnIrrelevant_Mut
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnIrrelevant_Mut(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnIrrelevant_Mut");

	Params::GbxTrickScript_OnIrrelevant_Mut Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.SetTrickValueActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueActor(class FName Name_0, class AActor* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueActor");

	Params::GbxTrickScript_SetTrickValueActor Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueBool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueBool(class FName Name_0, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueBool");

	Params::GbxTrickScript_SetTrickValueBool Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueFloat(class FName Name_0, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueFloat");

	Params::GbxTrickScript_SetTrickValueFloat Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueInt(class FName Name_0, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueInt");

	Params::GbxTrickScript_SetTrickValueInt Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueName(class FName Name_0, class FName Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueName");

	Params::GbxTrickScript_SetTrickValueName Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueNumericRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNumericRange&             Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueNumericRange(class FName Name_0, const struct FNumericRange& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueNumericRange");

	Params::GbxTrickScript_SetTrickValueNumericRange Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueObject(class FName Name_0, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueObject");

	Params::GbxTrickScript_SetTrickValueObject Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueRotator(class FName Name_0, const struct FRotator& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueRotator");

	Params::GbxTrickScript_SetTrickValueRotator Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueString
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueString(class FName Name_0, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueString");

	Params::GbxTrickScript_SetTrickValueString Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueTrajectoryOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueTrajectoryOptions(class FName Name_0, const struct FTrajectoryOptions& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueTrajectoryOptions");

	Params::GbxTrickScript_SetTrickValueTrajectoryOptions Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.SetTrickValueVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::SetTrickValueVector(class FName Name_0, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "SetTrickValueVector");

	Params::GbxTrickScript_SetTrickValueVector Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickScript.GetAssociatedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxTrickScript::GetAssociatedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "GetAssociatedActor");

	Params::GbxTrickScript_GetAssociatedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript.OnAnimNotify
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTrickHasEnded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnAnimNotify(class AActor* Actor, const struct FGameplayTag& Tag, bool bTrickHasEnded) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnAnimNotify");

	Params::GbxTrickScript_OnAnimNotify Parms{};

	Parms.Actor = Actor;
	Parms.Tag = std::move(Tag);
	Parms.bTrickHasEnded = bTrickHasEnded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.OnAnimNotifyState
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxTrickAnimNotifyState                type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTrickHasEnded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnAnimNotifyState(class AActor* Actor, const struct FGameplayTag& Tag, EGbxTrickAnimNotifyState type, bool bTrickHasEnded) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnAnimNotifyState");

	Params::GbxTrickScript_OnAnimNotifyState Parms{};

	Parms.Actor = Actor;
	Parms.Tag = std::move(Tag);
	Parms.type = type;
	Parms.bTrickHasEnded = bTrickHasEnded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.OnBegin_Const
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnBegin_Const(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnBegin_Const");

	Params::GbxTrickScript_OnBegin_Const Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.OnEnd_Const
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxTrickEnd                            EndType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnEnd_Const(class AActor* Actor, EGbxTrickEnd EndType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnEnd_Const");

	Params::GbxTrickScript_OnEnd_Const Parms{};

	Parms.Actor = Actor;
	Parms.EndType = EndType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript.OnIrrelevant_Const
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript::OnIrrelevant_Const(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript", "OnIrrelevant_Const");

	Params::GbxTrickScript_OnIrrelevant_Const Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameModeModule.OnInitBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModule::OnInitBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModule", "OnInitBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModule.GetModuleName
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGbxGameModeModule::GetModuleName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModule", "GetModuleName");

	Params::GbxGameModeModule_GetModuleName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeModule.GetTags
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGbxGameModeModuleTags     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGbxGameModeModuleTags UGbxGameModeModule::GetTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModule", "GetTags");

	Params::GbxGameModeModule_GetTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerController.Client_ConsumePremiumCurrency
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FSToken&                   type                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::Client_ConsumePremiumCurrency(const struct FSToken& type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "Client_ConsumePremiumCurrency");

	Params::GbxPlayerController_Client_ConsumePremiumCurrency Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.Client_PlayGbxFeedback
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const FGameDataHandleProperty_&         data                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIs3D                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceContext                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SourceLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EffectFalloffMinDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EffectFalloffMaxDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::Client_PlayGbxFeedback(const FGameDataHandleProperty_& data, int32 PlayFlags, bool bIs3D, bool bLoop, float scale, class UObject* SourceContext, const struct FVector& SourceLocation, float EffectFalloffMinDistance, float EffectFalloffMaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "Client_PlayGbxFeedback");

	Params::GbxPlayerController_Client_PlayGbxFeedback Parms{};

	Parms.data = data;
	Parms.PlayFlags = PlayFlags;
	Parms.bIs3D = bIs3D;
	Parms.bLoop = bLoop;
	Parms.scale = scale;
	Parms.SourceContext = SourceContext;
	Parms.SourceLocation = std::move(SourceLocation);
	Parms.EffectFalloffMinDistance = EffectFalloffMinDistance;
	Parms.EffectFalloffMaxDistance = EffectFalloffMaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.Client_ResetGbxFeedbackPlayTime
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const FGameDataHandleProperty_&         data                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::Client_ResetGbxFeedbackPlayTime(const FGameDataHandleProperty_& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "Client_ResetGbxFeedbackPlayTime");

	Params::GbxPlayerController_Client_ResetGbxFeedbackPlayTime Parms{};

	Parms.data = data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.Client_StopAllGbxFeedback
// (Net, NetReliable, Native, Event, Public, NetClient)

void AGbxPlayerController::Client_StopAllGbxFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "Client_StopAllGbxFeedback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.Client_StopGbxFeedback
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const FGameDataHandleProperty_&         data                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::Client_StopGbxFeedback(const FGameDataHandleProperty_& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "Client_StopGbxFeedback");

	Params::GbxPlayerController_Client_StopGbxFeedback Parms{};

	Parms.data = data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ClientPartyKick
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class FString&                    KickReason                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::ClientPartyKick(const class FString& KickReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ClientPartyKick");

	Params::GbxPlayerController_ClientPartyKick Parms{};

	Parms.KickReason = std::move(KickReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ClientPlayRadialBlur
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         Blur                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideCenter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceCenter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::ClientPlayRadialBlur(const FGameDataHandleProperty_& Blur, bool bOverrideCenter, const struct FVector& WorldSpaceCenter, float MaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ClientPlayRadialBlur");

	Params::GbxPlayerController_ClientPlayRadialBlur Parms{};

	Parms.Blur = Blur;
	Parms.bOverrideCenter = bOverrideCenter;
	Parms.WorldSpaceCenter = std::move(WorldSpaceCenter);
	Parms.MaxDistance = MaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ClientReceiveTextChat
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class APlayerState*                     Sender                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::ClientReceiveTextChat(class APlayerState* Sender, const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ClientReceiveTextChat");

	Params::GbxPlayerController_ClientReceiveTextChat Parms{};

	Parms.Sender = Sender;
	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ClientStopRadialBlur
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         Blur                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::ClientStopRadialBlur(const FGameDataHandleProperty_& Blur)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ClientStopRadialBlur");

	Params::GbxPlayerController_ClientStopRadialBlur Parms{};

	Parms.Blur = Blur;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ExecuteInventoryTransactionOnClient
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FGbxInventoryTransaction&  Transaction                                            (Parm, NativeAccessSpecifierPublic)

void AGbxPlayerController::ExecuteInventoryTransactionOnClient(const struct FGbxInventoryTransaction& Transaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ExecuteInventoryTransactionOnClient");

	Params::GbxPlayerController_ExecuteInventoryTransactionOnClient Parms{};

	Parms.Transaction = std::move(Transaction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ExecuteInventoryTransactionOnServer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FGbxInventoryTransaction&  Transaction                                            (Parm, NativeAccessSpecifierPublic)

void AGbxPlayerController::ExecuteInventoryTransactionOnServer(const struct FGbxInventoryTransaction& Transaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ExecuteInventoryTransactionOnServer");

	Params::GbxPlayerController_ExecuteInventoryTransactionOnServer Parms{};

	Parms.Transaction = std::move(Transaction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.OnRep_ActiveCinematicModeIdent
// (Final, Native, Private)

void AGbxPlayerController::OnRep_ActiveCinematicModeIdent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "OnRep_ActiveCinematicModeIdent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.PopCameraFade
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class FName&                      reason                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::PopCameraFade(const class FName& reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "PopCameraFade");

	Params::GbxPlayerController_PopCameraFade Parms{};

	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.PushCameraFadeFromColor
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const class FName&                      reason                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHoldWhenFinished                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::PushCameraFadeFromColor(const class FName& reason, float Duration, uint8 priority, const struct FColor& Color, bool bHoldWhenFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "PushCameraFadeFromColor");

	Params::GbxPlayerController_PushCameraFadeFromColor Parms{};

	Parms.reason = reason;
	Parms.Duration = Duration;
	Parms.priority = priority;
	Parms.Color = std::move(Color);
	Parms.bHoldWhenFinished = bHoldWhenFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.PushCameraFadeToColor
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const class FName&                      reason                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    Color                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::PushCameraFadeToColor(const class FName& reason, float Duration, uint8 priority, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "PushCameraFadeToColor");

	Params::GbxPlayerController_PushCameraFadeToColor Parms{};

	Parms.reason = reason;
	Parms.Duration = Duration;
	Parms.priority = priority;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.Server_NotifyReadyToPlayLevelSequence
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGbxLevelSequencePlaybackRequestID&PlaybackRequestId                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::Server_NotifyReadyToPlayLevelSequence(const struct FGbxLevelSequencePlaybackRequestID& PlaybackRequestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "Server_NotifyReadyToPlayLevelSequence");

	Params::GbxPlayerController_Server_NotifyReadyToPlayLevelSequence Parms{};

	Parms.PlaybackRequestId = std::move(PlaybackRequestId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.Server_UpdatePremiumCurrency
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FSToken&                   type                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromEntitlementRefresh                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::Server_UpdatePremiumCurrency(const struct FSToken& type, uint32 Amount, bool bFromEntitlementRefresh, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "Server_UpdatePremiumCurrency");

	Params::GbxPlayerController_Server_UpdatePremiumCurrency Parms{};

	Parms.type = std::move(type);
	Parms.Amount = Amount;
	Parms.bFromEntitlementRefresh = bFromEntitlementRefresh;
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ServerGiveEntitlementReward
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// FGbxDefPtrProperty_                     RewardDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::ServerGiveEntitlementReward(FGbxDefPtrProperty_ RewardDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ServerGiveEntitlementReward");

	Params::GbxPlayerController_ServerGiveEntitlementReward Parms{};

	Parms.RewardDef = RewardDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ServerRefreshPlayerEntitlementFacts
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const class FString&                    EncodedSnapshot                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::ServerRefreshPlayerEntitlementFacts(const class FString& EncodedSnapshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ServerRefreshPlayerEntitlementFacts");

	Params::GbxPlayerController_ServerRefreshPlayerEntitlementFacts Parms{};

	Parms.EncodedSnapshot = std::move(EncodedSnapshot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.ServerSendTextChat
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const class FString&                    Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerController::ServerSendTextChat(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "ServerSendTextChat");

	Params::GbxPlayerController_ServerSendTextChat Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerController.GetPlayerGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGbxPlayerGroup*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGbxPlayerGroup* AGbxPlayerController::GetPlayerGroup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "GetPlayerGroup");

	Params::GbxPlayerController_GetPlayerGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerController.GetPlayerGroupState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGbxPlayerGroupState*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGbxPlayerGroupState* AGbxPlayerController::GetPlayerGroupState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerController", "GetPlayerGroupState");

	Params::GbxPlayerController_GetPlayerGroupState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityLandscapeBlueprintBrushBase.OverrideHeightmapMaterialParamValues
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UMaterialInstanceDynamic*         InDMI                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxActivityLandscapeBlueprintBrushBase::OverrideHeightmapMaterialParamValues(class UMaterialInstanceDynamic* InDMI) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActivityLandscapeBlueprintBrushBase", "OverrideHeightmapMaterialParamValues");

	Params::GbxActivityLandscapeBlueprintBrushBase_OverrideHeightmapMaterialParamValues Parms{};

	Parms.InDMI = InDMI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProximityProcessingActor.OnEnteringProximityZone
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AGbxProximityProcessingActor::OnEnteringProximityZone(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProximityProcessingActor", "OnEnteringProximityZone");

	Params::GbxProximityProcessingActor_OnEnteringProximityZone Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProximityProcessingActor.OnExitingProximityZone
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxProximityProcessingActor::OnExitingProximityZone(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProximityProcessingActor", "OnExitingProximityZone");

	Params::GbxProximityProcessingActor_OnExitingProximityZone Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DialogFunctionImplementation.PerformTest
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FDialogContext&            Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EDialogDecisionTestResult*              Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogFunctionImplementation::PerformTest(const struct FDialogContext& Context, EDialogDecisionTestResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogFunctionImplementation", "PerformTest");

	Params::DialogFunctionImplementation_PerformTest Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.AvatarDummy.RemoveDummy
// (Final, Native, Public, BlueprintCallable)

void AAvatarDummy::RemoveDummy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AvatarDummy", "RemoveDummy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.AvatarDummy.SetSerialNumberForChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ForChannel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    UseSerial                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAvatarDummy::SetSerialNumberForChannel(class FName ForChannel, const class FString& UseSerial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AvatarDummy", "SetSerialNumberForChannel");

	Params::AvatarDummy_SetSerialNumberForChannel Parms{};

	Parms.ForChannel = ForChannel;
	Parms.UseSerial = std::move(UseSerial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.AvatarDummy.SpawnDummy
// (Final, Native, Public, BlueprintCallable)

void AAvatarDummy::SpawnDummy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AvatarDummy", "SpawnDummy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.AvatarDummy.GetDummy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AAvatarDummy::GetDummy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AvatarDummy", "GetDummy");

	Params::AvatarDummy_GetDummy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorScriptInterface.SetScriptStateEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GraphName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGbxActorScriptInterface::SetScriptStateEnabled(class FName GraphName, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxActorScriptInterface", "SetScriptStateEnabled");

	Params::GbxActorScriptInterface_SetScriptStateEnabled Parms{};

	Parms.GraphName = GraphName;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorScriptInterface.IsScriptStateEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GraphName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IGbxActorScriptInterface::IsScriptStateEnabled(class FName GraphName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxActorScriptInterface", "IsScriptStateEnabled");

	Params::GbxActorScriptInterface_IsScriptStateEnabled Parms{};

	Parms.GraphName = GraphName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.AvatarStatics.AddOption
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    SerialNumber                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                WithDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Prefix                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAvatarStatics::AddOption(const class FString& SerialNumber, FGameDataHandleProperty_ WithDef, bool Prefix, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AvatarStatics", "AddOption");

	Params::AvatarStatics_AddOption Parms{};

	Parms.SerialNumber = std::move(SerialNumber);
	Parms.WithDef = WithDef;
	Parms.Prefix = Prefix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	return Parms.ReturnValue;
}


// Function GbxGame.AvatarStatics.AssignAvatarSerialNumber
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetAppearance                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ForChannel                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    WithSerial                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AtPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAvatarStatics::AssignAvatarSerialNumber(class AActor* TargetAppearance, const class FName& ForChannel, const class FString& WithSerial, int32 AtPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AvatarStatics", "AssignAvatarSerialNumber");

	Params::AvatarStatics_AssignAvatarSerialNumber Parms{};

	Parms.TargetAppearance = TargetAppearance;
	Parms.ForChannel = ForChannel;
	Parms.WithSerial = std::move(WithSerial);
	Parms.AtPriority = AtPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.AvatarStatics.GenerateFromArchtypeDef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                WithDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAvatarStatics::GenerateFromArchtypeDef(FGameDataHandleProperty_ WithDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AvatarStatics", "GenerateFromArchtypeDef");

	Params::AvatarStatics_GenerateFromArchtypeDef Parms{};

	Parms.WithDef = WithDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.AvatarStatics.GenerateFromTaggedArchtype
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              FilterTags                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAvatarStatics::GenerateFromTaggedArchtype(const TArray<class FName>& FilterTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AvatarStatics", "GenerateFromTaggedArchtype");

	Params::AvatarStatics_GenerateFromTaggedArchtype Parms{};

	Parms.FilterTags = std::move(FilterTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.AvatarStatics.QueryAvatarSerialNumber
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetAppearance                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      FromChannel                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutSerial                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAvatarStatics::QueryAvatarSerialNumber(class AActor* TargetAppearance, const class FName& FromChannel, class FString* OutSerial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AvatarStatics", "QueryAvatarSerialNumber");

	Params::AvatarStatics_QueryAvatarSerialNumber Parms{};

	Parms.TargetAppearance = TargetAppearance;
	Parms.FromChannel = FromChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSerial != nullptr)
		*OutSerial = std::move(Parms.OutSerial);

	return Parms.ReturnValue;
}


// Function GbxGame.AvatarStatics.RemoveOption
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    SerialNumber                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                WithDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAvatarStatics::RemoveOption(const class FString& SerialNumber, FGameDataHandleProperty_ WithDef, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AvatarStatics", "RemoveOption");

	Params::AvatarStatics_RemoveOption Parms{};

	Parms.SerialNumber = std::move(SerialNumber);
	Parms.WithDef = WithDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (success != nullptr)
		*success = Parms.success;

	return Parms.ReturnValue;
}


// Function GbxGame.BalanceBlueprintLibrary.GetBalancedActorLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  ExperienceLevel                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  gamestage                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBalanceBlueprintLibrary::GetBalancedActorLevel(class UObject* OwnerContext, int32* ExperienceLevel, int32* gamestage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BalanceBlueprintLibrary", "GetBalancedActorLevel");

	Params::BalanceBlueprintLibrary_GetBalancedActorLevel Parms{};

	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ExperienceLevel != nullptr)
		*ExperienceLevel = Parms.ExperienceLevel;

	if (gamestage != nullptr)
		*gamestage = Parms.gamestage;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxLegIKBlueprintLibrary.SetLegIKEnabled
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    reason                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLegIKBlueprintLibrary::SetLegIKEnabled(class AActor* Actor, bool bNewEnabled, const class FString& reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxLegIKBlueprintLibrary", "SetLegIKEnabled");

	Params::GbxLegIKBlueprintLibrary_SetLegIKEnabled Parms{};

	Parms.Actor = Actor;
	Parms.bNewEnabled = bNewEnabled;
	Parms.reason = std::move(reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileManager.OnParticleSystemFinished
// (Final, Native, Private)
// Parameters:
// class UFXSystemComponent*               FinishedComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightProjectileManager::OnParticleSystemFinished(class UFXSystemComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileManager", "OnParticleSystemFinished");

	Params::LightProjectileManager_OnParticleSystemFinished Parms{};

	Parms.FinishedComponent = FinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileManager.ServerSendDebugProjectileImpact
// (Net, NetReliable, Native, Event, NetMulticast, Protected, NetClient)
// Parameters:
// int32                                   ProjSyncID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  ProjFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightProjectileManager::ServerSendDebugProjectileImpact(int32 ProjSyncID, class AActor* HitActor, class FName BoneName, uint16 ProjFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileManager", "ServerSendDebugProjectileImpact");

	Params::LightProjectileManager_ServerSendDebugProjectileImpact Parms{};

	Parms.ProjSyncID = ProjSyncID;
	Parms.HitActor = HitActor;
	Parms.BoneName = BoneName;
	Parms.ProjFlags = ProjFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileManager.ServerSendDebugProjectilePath
// (Net, NetReliable, Native, Event, NetMulticast, Protected, NetClient)
// Parameters:
// int32                                   ProjSyncID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector_NetQuantize&       Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightProjectileManager::ServerSendDebugProjectilePath(int32 ProjSyncID, const struct FVector_NetQuantize& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileManager", "ServerSendDebugProjectilePath");

	Params::LightProjectileManager_ServerSendDebugProjectilePath Parms{};

	Parms.ProjSyncID = ProjSyncID;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DeliverySpawnPointComponent.GetLoopTrick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGbxTrick_Loop*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxTrick_Loop* UDeliverySpawnPointComponent::GetLoopTrick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeliverySpawnPointComponent", "GetLoopTrick");

	Params::DeliverySpawnPointComponent_GetLoopTrick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.BodyActionAnimOwner.PlayBodyActionTrick
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckForRelevancy                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 IBodyActionAnimOwner::PlayBodyActionTrick(class FName Action, class FName Tag, class UObject* Context, bool bCheckForRelevancy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BodyActionAnimOwner", "PlayBodyActionTrick");

	Params::BodyActionAnimOwner_PlayBodyActionTrick Parms{};

	Parms.Action = Action;
	Parms.Tag = Tag;
	Parms.Context = Context;
	Parms.bCheckForRelevancy = bCheckForRelevancy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.BodyActionAnimOwner.StopBodyActionTrick
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// uint8                                   TrickId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBodyActionAnimOwner::StopBodyActionTrick(uint8 TrickId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BodyActionAnimOwner", "StopBodyActionTrick");

	Params::BodyActionAnimOwner_StopBodyActionTrick Parms{};

	Parms.TrickId = TrickId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorStateSequencePlayer.OnTransitionFinished
// (Final, Native, Public)

void UGbxActorStateSequencePlayer::OnTransitionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorStateSequencePlayer", "OnTransitionFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameCover.OnRep_FactsConduit
// (Final, Native, Protected)

void AGbxGameCover::OnRep_FactsConduit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameCover", "OnRep_FactsConduit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.BreadcrumbFactVolumeActivator.OnRep_FactsConduit
// (Final, Native, Protected)

void ABreadcrumbFactVolumeActivator::OnRep_FactsConduit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreadcrumbFactVolumeActivator", "OnRep_FactsConduit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorPartStatics.GetGbxActorPartParam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     ParamDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxParam                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxParam UGbxActorPartStatics::GetGbxActorPartParam(class UObject* Context, FGbxDefPtrProperty_ ParamDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorPartStatics", "GetGbxActorPartParam");

	Params::GbxActorPartStatics_GetGbxActorPartParam Parms{};

	Parms.Context = Context;
	Parms.ParamDef = ParamDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorPartStatics.GetGbxActorPartShowTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UGbxActorPartStatics::GetGbxActorPartShowTags(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorPartStatics", "GetGbxActorPartShowTags");

	Params::GbxActorPartStatics_GetGbxActorPartShowTags Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.BlueprintableCameraModeBehavior.End
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCameraModeState*                 State                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintableCameraModeBehavior::End(class UCameraModeState* State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlueprintableCameraModeBehavior", "End");

	Params::BlueprintableCameraModeBehavior_End Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.BlueprintableCameraModeBehavior.Start
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCameraModeState*                 State                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintableCameraModeBehavior::Start(class UCameraModeState* State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlueprintableCameraModeBehavior", "Start");

	Params::BlueprintableCameraModeBehavior_Start Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.BlueprintableCameraModeBehavior.Update
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraModeState*                 State                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintableCameraModeBehavior::Update(float DeltaTime, class UCameraModeState* State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlueprintableCameraModeBehavior", "Update");

	Params::BlueprintableCameraModeBehavior_Update Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.CameraModeState.AddPostProcessBlend
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      UniqueID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPostProcessSettings&      settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   BlendWeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModeState::AddPostProcessBlend(const class FName& UniqueID, const struct FPostProcessSettings& settings, float BlendWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "AddPostProcessBlend");

	Params::CameraModeState_AddPostProcessBlend Parms{};

	Parms.UniqueID = UniqueID;
	Parms.settings = std::move(settings);
	Parms.BlendWeight = BlendWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.CameraModeState.CameraTrace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   IgnoreMask                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraModeState::CameraTrace(const struct FVector& Start, const struct FVector& End, float Radius, ECollisionChannel TraceChannel, uint8 IgnoreMask, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "CameraTrace");

	Params::CameraModeState_CameraTrace Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.TraceChannel = TraceChannel;
	Parms.IgnoreMask = IgnoreMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function GbxGame.CameraModeState.SetBaseFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewFOV                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModeState::SetBaseFOV(float NewFOV, bool bDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "SetBaseFOV");

	Params::CameraModeState_SetBaseFOV Parms{};

	Parms.NewFOV = NewFOV;
	Parms.bDefault = bDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.CameraModeState.SetBaseLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModeState::SetBaseLocation(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "SetBaseLocation");

	Params::CameraModeState_SetBaseLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.CameraModeState.SetBaseRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCameraModeState::SetBaseRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "SetBaseRotation");

	Params::CameraModeState_SetBaseRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.CameraModeState.SetViewModelFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewFOV                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModeState::SetViewModelFOV(float NewFOV, bool bDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "SetViewModelFOV");

	Params::CameraModeState_SetViewModelFOV Parms{};

	Parms.NewFOV = NewFOV;
	Parms.bDefault = bDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.CameraModeState.GetBaseFOV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCameraModeState::GetBaseFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "GetBaseFOV");

	Params::CameraModeState_GetBaseFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.CameraModeState.GetBaseLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UCameraModeState::GetBaseLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "GetBaseLocation");

	Params::CameraModeState_GetBaseLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.CameraModeState.GetBaseRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRotator                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FRotator UCameraModeState::GetBaseRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraModeState", "GetBaseRotation");

	Params::CameraModeState_GetBaseRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript_Loop.OnLoop_Mut
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_Loop::OnLoop_Mut(class AActor* Actor, int32 LoopCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_Loop", "OnLoop_Mut");

	Params::GbxTrickScript_Loop_OnLoop_Mut Parms{};

	Parms.Actor = Actor;
	Parms.LoopCount = LoopCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_Loop.OnLoopEnd_Mut
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_Loop::OnLoopEnd_Mut(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_Loop", "OnLoopEnd_Mut");

	Params::GbxTrickScript_Loop_OnLoopEnd_Mut Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxAINodeComponent.GetOrWaitForSpawnedActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGbxAINodeComponent*              AINode                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor**                          OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAINodeComponent::GetOrWaitForSpawnedActor(class UGbxAINodeComponent* AINode, const struct FLatentActionInfo& LatentInfo, class AActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAINodeComponent", "GetOrWaitForSpawnedActor");

	Params::GbxAINodeComponent_GetOrWaitForSpawnedActor Parms{};

	Parms.AINode = AINode;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;
}


// Function GbxGame.GbxAINodeComponent.AttachActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxAINodeComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxAINodeComponent* UGbxAINodeComponent::AttachActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "AttachActor");

	Params::GbxAINodeComponent_AttachActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxAINodeComponent.ResetNodeSpawn
// (Final, Native, Public, BlueprintCallable)

void UGbxAINodeComponent::ResetNodeSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "ResetNodeSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINodeComponent.SetGbxActorDef
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         NewGbxActorDef                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAINodeComponent::SetGbxActorDef(const FGameDataHandleProperty_& NewGbxActorDef, bool bResetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "SetGbxActorDef");

	Params::GbxAINodeComponent_SetGbxActorDef Parms{};

	Parms.NewGbxActorDef = NewGbxActorDef;
	Parms.bResetActor = bResetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINodeComponent.SetNodeEnabled
// (Final, Native, Public, BlueprintCallable)

void UGbxAINodeComponent::SetNodeEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "SetNodeEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINodeComponent.GetAggroSpeeds
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// TArray<EGbxAINodeStanceSpeed>*          OutSpeeds                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxAINodeComponent::GetAggroSpeeds(TArray<EGbxAINodeStanceSpeed>* OutSpeeds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "GetAggroSpeeds");

	Params::GbxAINodeComponent_GetAggroSpeeds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpeeds != nullptr)
		*OutSpeeds = std::move(Parms.OutSpeeds);
}


// Function GbxGame.GbxAINodeComponent.GetAggroStyles
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// TArray<EGbxAINodeStanceStyle>*          OutStyles                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxAINodeComponent::GetAggroStyles(TArray<EGbxAINodeStanceStyle>* OutStyles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "GetAggroStyles");

	Params::GbxAINodeComponent_GetAggroStyles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStyles != nullptr)
		*OutStyles = std::move(Parms.OutStyles);
}


// Function GbxGame.GbxAINodeComponent.GetSpawnedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxAINodeComponent::GetSpawnedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "GetSpawnedActor");

	Params::GbxAINodeComponent_GetSpawnedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxAINodeComponent.GetStaySequenceBindingOptions
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxAINodeComponent::GetStaySequenceBindingOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "GetStaySequenceBindingOptions");

	Params::GbxAINodeComponent_GetStaySequenceBindingOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxAINodeComponent.IsNodeEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxAINodeComponent::IsNodeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINodeComponent", "IsNodeEnabled");

	Params::GbxAINodeComponent_IsNodeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.InteractiveObject.OnRep_FactsConduit
// (Final, Native, Protected)

void AInteractiveObject::OnRep_FactsConduit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveObject", "OnRep_FactsConduit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InteractiveObject.OnRep_GbxActorPartOwnerState
// (Final, Native, Public)

void AInteractiveObject::OnRep_GbxActorPartOwnerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveObject", "OnRep_GbxActorPartOwnerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InteractiveObject.OnRep_RotationState
// (Final, Native, Public)

void AInteractiveObject::OnRep_RotationState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveObject", "OnRep_RotationState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InteractiveObject.OnRep_UsableActorState
// (Final, Native, Protected)

void AInteractiveObject::OnRep_UsableActorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveObject", "OnRep_UsableActorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InteractiveObject.SetRecipeCost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                RecipeDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUsabilityType                          UseType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveObject::SetRecipeCost(FGameDataHandleProperty_ RecipeDef, EUsabilityType UseType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveObject", "SetRecipeCost");

	Params::InteractiveObject_SetRecipeCost Parms{};

	Parms.RecipeDef = RecipeDef;
	Parms.UseType = UseType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgressGraphUser.GbxGetUnlockableGroupNames
// (RequiredAPI, Native, Public, HasOutParams, Const)
// Parameters:
// FGbxDefPtrProperty_                     InGraph                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void IGbxProgressGraphUser::GbxGetUnlockableGroupNames(FGbxDefPtrProperty_ InGraph, TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxProgressGraphUser", "GbxGetUnlockableGroupNames");

	Params::GbxProgressGraphUser_GbxGetUnlockableGroupNames Parms{};

	Parms.InGraph = InGraph;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.GbxProgressGraphUser.GbxGetUnlockableNodeNames
// (RequiredAPI, Native, Public, HasOutParams, Const)
// Parameters:
// FGbxDefPtrProperty_                     InGraph                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void IGbxProgressGraphUser::GbxGetUnlockableNodeNames(FGbxDefPtrProperty_ InGraph, TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxProgressGraphUser", "GbxGetUnlockableNodeNames");

	Params::GbxProgressGraphUser_GbxGetUnlockableNodeNames Parms{};

	Parms.InGraph = InGraph;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.GbxBodyData.GetBodySwitchState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Switch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxBodyData::GetBodySwitchState(class FName Switch, class UObject* OwnerContext, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyData", "GetBodySwitchState");

	Params::GbxBodyData_GetBodySwitchState Parms{};

	Parms.Switch = Switch;
	Parms.OwnerContext = OwnerContext;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxBodyData.GetBodySwitchStateAsBool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Switch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxBodyData::GetBodySwitchStateAsBool(class FName Switch, class UObject* OwnerContext, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyData", "GetBodySwitchStateAsBool");

	Params::GbxBodyData_GetBodySwitchStateAsBool Parms{};

	Parms.Switch = Switch;
	Parms.OwnerContext = OwnerContext;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxBodyData.SetBodySwitchState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Switch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBodyData::SetBodySwitchState(class FName Switch, class FName State, class UObject* OwnerContext, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyData", "SetBodySwitchState");

	Params::GbxBodyData_SetBodySwitchState Parms{};

	Parms.Switch = Switch;
	Parms.State = State;
	Parms.OwnerContext = OwnerContext;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxNavTest_NavMeshPath.SetGbxActorDef
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         NewGbxActorDef                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxNavTest_NavMeshPath::SetGbxActorDef(const FGameDataHandleProperty_& NewGbxActorDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxNavTest_NavMeshPath", "SetGbxActorDef");

	Params::GbxNavTest_NavMeshPath_SetGbxActorDef Parms{};

	Parms.NewGbxActorDef = NewGbxActorDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxNavTest_NavMeshPath.SetStance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         NewStance                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxNavTest_NavMeshPath::SetStance(const FGameDataHandleProperty_& NewStance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxNavTest_NavMeshPath", "SetStance");

	Params::GbxNavTest_NavMeshPath_SetStance Parms{};

	Parms.NewStance = NewStance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameStateBase.OnGroupAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroup                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameStateBase::OnGroupAdded(class AGbxPlayerGroupState* PlayerGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameStateBase", "OnGroupAdded");

	Params::GbxGameStateBase_OnGroupAdded Parms{};

	Parms.PlayerGroup = PlayerGroup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameStateBase.OnGroupRemoved
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroup                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameStateBase::OnGroupRemoved(class AGbxPlayerGroupState* PlayerGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameStateBase", "OnGroupRemoved");

	Params::GbxGameStateBase_OnGroupRemoved Parms{};

	Parms.PlayerGroup = PlayerGroup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameStateBase.OnPlayerAddedToGroup
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroupState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameStateBase::OnPlayerAddedToGroup(class AGbxPlayerGroupState* PlayerGroupState, class AGbxPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameStateBase", "OnPlayerAddedToGroup");

	Params::GbxGameStateBase_OnPlayerAddedToGroup Parms{};

	Parms.PlayerGroupState = PlayerGroupState;
	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameStateBase.OnPlayerRemovedFromGroup
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroupState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameStateBase::OnPlayerRemovedFromGroup(class AGbxPlayerGroupState* PlayerGroupState, class AGbxPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameStateBase", "OnPlayerRemovedFromGroup");

	Params::GbxGameStateBase_OnPlayerRemovedFromGroup Parms{};

	Parms.PlayerGroupState = PlayerGroupState;
	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameStateBase.OnRep_ServerIdentity
// (Final, Native, Public)

void AGbxGameStateBase::OnRep_ServerIdentity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameStateBase", "OnRep_ServerIdentity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameStateBase.OnRep_ServerModeDef
// (RequiredAPI, Native, Public)

void AGbxGameStateBase::OnRep_ServerModeDef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameStateBase", "OnRep_ServerModeDef");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.OnRep_bPlayersOnly
// (Final, Native, Public)

void AGbxGameState::OnRep_bPlayersOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "OnRep_bPlayersOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.OnRep_HostPlayerState
// (RequiredAPI, Native, Public)

void AGbxGameState::OnRep_HostPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "OnRep_HostPlayerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.OnRep_ModuleConduits
// (Final, Native, Private)

void AGbxGameState::OnRep_ModuleConduits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "OnRep_ModuleConduits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.OnRep_PlatformGameplaySessions
// (Final, Native, Public)

void AGbxGameState::OnRep_PlatformGameplaySessions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "OnRep_PlatformGameplaySessions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.PlayMusicEvent
// (RequiredAPI, Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FGameplayTag&              MusicEvent                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameState::PlayMusicEvent(const struct FGameplayTag& MusicEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "PlayMusicEvent");

	Params::GbxGameState_PlayMusicEvent Parms{};

	Parms.MusicEvent = std::move(MusicEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.PlaySoundInWorldMulticast
// (RequiredAPI, Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           ActorInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxAudioEmitterSource&    EmitterSource                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxAudioEvent&            Event                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FWwiseSwitchDef&           OptionalSwitch                                         (ConstParm, Parm, NativeAccessSpecifierPublic)

void AGbxGameState::PlaySoundInWorldMulticast(class AActor* ActorInstigator, const struct FGbxAudioEmitterSource& EmitterSource, const struct FGbxAudioEvent& Event, const struct FWwiseSwitchDef& OptionalSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "PlaySoundInWorldMulticast");

	Params::GbxGameState_PlaySoundInWorldMulticast Parms{};

	Parms.ActorInstigator = ActorInstigator;
	Parms.EmitterSource = std::move(EmitterSource);
	Parms.Event = std::move(Event);
	Parms.OptionalSwitch = std::move(OptionalSwitch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.PlaySoundOnActorMulticast
// (RequiredAPI, Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           ActorInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxAudioEvent&            Event                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FName                       EmitterTag                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWwiseSwitchDef&           OptionalSwitch                                         (ConstParm, Parm, NativeAccessSpecifierPublic)

void AGbxGameState::PlaySoundOnActorMulticast(class AActor* ActorInstigator, const struct FGbxAudioEvent& Event, const class FName EmitterTag, const struct FWwiseSwitchDef& OptionalSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "PlaySoundOnActorMulticast");

	Params::GbxGameState_PlaySoundOnActorMulticast Parms{};

	Parms.ActorInstigator = ActorInstigator;
	Parms.Event = std::move(Event);
	Parms.EmitterTag = EmitterTag;
	Parms.OptionalSwitch = std::move(OptionalSwitch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameState.PlaySoundOnActorSocketMulticast
// (RequiredAPI, Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           ActorInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxAudioEvent&            Event                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FName&                      SocketName                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameState::PlaySoundOnActorSocketMulticast(class AActor* ActorInstigator, const struct FGbxAudioEvent& Event, const class FName& SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameState", "PlaySoundOnActorSocketMulticast");

	Params::GbxGameState_PlaySoundOnActorSocketMulticast Parms{};

	Parms.ActorInstigator = ActorInstigator;
	Parms.Event = std::move(Event);
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ClimbableVolume.SetIsClimbable
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsClimbable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AClimbableVolume::SetIsClimbable(bool bInIsClimbable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClimbableVolume", "SetIsClimbable");

	Params::ClimbableVolume_SetIsClimbable Parms{};

	Parms.bInIsClimbable = bInIsClimbable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ClimbableVolume.IsClimbable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AClimbableVolume::IsClimbable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClimbableVolume", "IsClimbable");

	Params::ClimbableVolume_IsClimbable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ClimbableInteractiveObject.SetIsClimbable
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsClimbable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AClimbableInteractiveObject::SetIsClimbable(bool bInIsClimbable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClimbableInteractiveObject", "SetIsClimbable");

	Params::ClimbableInteractiveObject_SetIsClimbable Parms{};

	Parms.bInIsClimbable = bInIsClimbable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ClimbableInteractiveObject.IsClimbable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AClimbableInteractiveObject::IsClimbable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClimbableInteractiveObject", "IsClimbable");

	Params::ClimbableInteractiveObject_IsClimbable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ClimbableInterface.SetIsClimbable
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsClimbable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IClimbableInterface::SetIsClimbable(bool bInIsClimbable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClimbableInterface", "SetIsClimbable");

	Params::ClimbableInterface_SetIsClimbable Parms{};

	Parms.bInIsClimbable = bInIsClimbable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ClimbableInterface.IsClimbable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IClimbableInterface::IsClimbable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ClimbableInterface", "IsClimbable");

	Params::ClimbableInterface_IsClimbable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnHitTargetable_Mut
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnHitTargetable_Mut(class AActor* OwnerActor, class AActor* HitActor, const struct FVector& HitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnHitTargetable_Mut");

	Params::GbxTrickScript_ControlledMove_OnHitTargetable_Mut Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.HitActor = HitActor;
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnHitWorld_Mut
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnHitWorld_Mut(class AActor* Actor, const struct FVector& HitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnHitWorld_Mut");

	Params::GbxTrickScript_ControlledMove_OnHitWorld_Mut Parms{};

	Parms.Actor = Actor;
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnServerStart_Mut
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   MoveDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnServerStart_Mut(float MoveDuration, class AActor* TargetActor, class AActor* instigator, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnServerStart_Mut");

	Params::GbxTrickScript_ControlledMove_OnServerStart_Mut Parms{};

	Parms.MoveDuration = MoveDuration;
	Parms.TargetActor = TargetActor;
	Parms.instigator = instigator;
	Parms.TargetLocation = std::move(TargetLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnServerStop_Mut
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnServerStop_Mut(bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnServerStop_Mut");

	Params::GbxTrickScript_ControlledMove_OnServerStop_Mut Parms{};

	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnStart_Mut
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   MoveDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnStart_Mut(float MoveDuration, class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnStart_Mut");

	Params::GbxTrickScript_ControlledMove_OnStart_Mut Parms{};

	Parms.MoveDuration = MoveDuration;
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnStop_Mut
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnStop_Mut(bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnStop_Mut");

	Params::GbxTrickScript_ControlledMove_OnStop_Mut Parms{};

	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnTargetLocationChanged_Mut
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   NewTargetLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnTargetLocationChanged_Mut(const struct FVector& NewTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnTargetLocationChanged_Mut");

	Params::GbxTrickScript_ControlledMove_OnTargetLocationChanged_Mut Parms{};

	Parms.NewTargetLocation = std::move(NewTargetLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnTeleported_Mut
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   MoveDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PreTeleportLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnTeleported_Mut(float MoveDuration, const struct FVector& PreTeleportLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnTeleported_Mut");

	Params::GbxTrickScript_ControlledMove_OnTeleported_Mut Parms{};

	Parms.MoveDuration = MoveDuration;
	Parms.PreTeleportLocation = std::move(PreTeleportLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnHitTargetable_Const
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnHitTargetable_Const(class AActor* OwnerActor, class AActor* HitActor, const struct FVector& HitNormal) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnHitTargetable_Const");

	Params::GbxTrickScript_ControlledMove_OnHitTargetable_Const Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.HitActor = HitActor;
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnHitWorld_Const
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnHitWorld_Const(class AActor* Actor, const struct FVector& HitNormal) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnHitWorld_Const");

	Params::GbxTrickScript_ControlledMove_OnHitWorld_Const Parms{};

	Parms.Actor = Actor;
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnServerStart_Const
// (Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// float                                   MoveDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnServerStart_Const(float MoveDuration, class AActor* TargetActor, class AActor* instigator, const struct FVector& TargetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnServerStart_Const");

	Params::GbxTrickScript_ControlledMove_OnServerStart_Const Parms{};

	Parms.MoveDuration = MoveDuration;
	Parms.TargetActor = TargetActor;
	Parms.instigator = instigator;
	Parms.TargetLocation = std::move(TargetLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnServerStop_Const
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnServerStop_Const(bool bInterrupted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnServerStop_Const");

	Params::GbxTrickScript_ControlledMove_OnServerStop_Const Parms{};

	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnStart_Const
// (Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// float                                   MoveDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnStart_Const(float MoveDuration, class AActor* TargetActor, const struct FVector& TargetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnStart_Const");

	Params::GbxTrickScript_ControlledMove_OnStart_Const Parms{};

	Parms.MoveDuration = MoveDuration;
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnStop_Const
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnStop_Const(bool bInterrupted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnStop_Const");

	Params::GbxTrickScript_ControlledMove_OnStop_Const Parms{};

	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnTargetLocationChanged_Const
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// const struct FVector&                   NewTargetLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnTargetLocationChanged_Const(const struct FVector& NewTargetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnTargetLocationChanged_Const");

	Params::GbxTrickScript_ControlledMove_OnTargetLocationChanged_Const Parms{};

	Parms.NewTargetLocation = std::move(NewTargetLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxTrickScript_ControlledMove.OnTeleported_Const
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// float                                   MoveDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PreTeleportLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickScript_ControlledMove::OnTeleported_Const(float MoveDuration, const struct FVector& PreTeleportLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrickScript_ControlledMove", "OnTeleported_Const");

	Params::GbxTrickScript_ControlledMove_OnTeleported_Const Parms{};

	Parms.MoveDuration = MoveDuration;
	Parms.PreTeleportLocation = std::move(PreTeleportLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxOpportunisticAmbientAudioComponent.GetAudioOpportunisticShowFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxOpportunisticAmbientAudioComponent::GetAudioOpportunisticShowFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxOpportunisticAmbientAudioComponent", "GetAudioOpportunisticShowFlag");

	Params::GbxOpportunisticAmbientAudioComponent_GetAudioOpportunisticShowFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxOpportunisticAmbientAudioComponent.SetAudioOpportunisticShowFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxOpportunisticAmbientAudioComponent::SetAudioOpportunisticShowFlag(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxOpportunisticAmbientAudioComponent", "SetAudioOpportunisticShowFlag");

	Params::GbxOpportunisticAmbientAudioComponent_SetAudioOpportunisticShowFlag Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameSpawner.ResetTerritoryToDefault
// (Final, Native, Public, BlueprintCallable)

void AGbxGameSpawner::ResetTerritoryToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameSpawner", "ResetTerritoryToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameSpawner.SetTerritory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGbxTerritoryProvider>TerritoryProvider                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameSpawner::SetTerritory(TScriptInterface<class IGbxTerritoryProvider> TerritoryProvider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameSpawner", "SetTerritory");

	Params::GbxGameSpawner_SetTerritory Parms{};

	Parms.TerritoryProvider = TerritoryProvider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameSpawner.GetTerritory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGbxTerritoryComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxTerritoryComponent* AGbxGameSpawner::GetTerritory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameSpawner", "GetTerritory");

	Params::GbxGameSpawner_GetTerritory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ControlledMoveFunctionLibrary.IsPerformingControlledMove
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UControlledMoveFunctionLibrary::IsPerformingControlledMove(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ControlledMoveFunctionLibrary", "IsPerformingControlledMove");

	Params::ControlledMoveFunctionLibrary_IsPerformingControlledMove Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ControlledMoveFunctionLibrary.IsPerformingSpecificControlledMove
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UControlledMove*            ControlledMove                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UControlledMoveFunctionLibrary::IsPerformingSpecificControlledMove(class AActor* Actor, const class UControlledMove* ControlledMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ControlledMoveFunctionLibrary", "IsPerformingSpecificControlledMove");

	Params::ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove Parms{};

	Parms.Actor = Actor;
	Parms.ControlledMove = ControlledMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ControlledMoveFunctionLibrary.StartControlledMove
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UControlledMove*            ControlledMove                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchAngleOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UControlledMoveFunctionLibrary::StartControlledMove(class AActor* Actor, const class UControlledMove* ControlledMove, class AActor* instigator, float SpeedOverride, float DurationOverride, float LaunchAngleOverride, class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ControlledMoveFunctionLibrary", "StartControlledMove");

	Params::ControlledMoveFunctionLibrary_StartControlledMove Parms{};

	Parms.Actor = Actor;
	Parms.ControlledMove = ControlledMove;
	Parms.instigator = instigator;
	Parms.SpeedOverride = SpeedOverride;
	Parms.DurationOverride = DurationOverride;
	Parms.LaunchAngleOverride = LaunchAngleOverride;
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ControlledMoveFunctionLibrary.StopControlledMove
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UControlledMove*            ControlledMove                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StopMoveFlags                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UControlledMoveFunctionLibrary::StopControlledMove(class AActor* Actor, const class UControlledMove* ControlledMove, int32 StopMoveFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ControlledMoveFunctionLibrary", "StopControlledMove");

	Params::ControlledMoveFunctionLibrary_StopControlledMove Parms{};

	Parms.Actor = Actor;
	Parms.ControlledMove = ControlledMove;
	Parms.StopMoveFlags = StopMoveFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost.EnableBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost::EnableBP(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "EnableBP");

	Params::GbxGameModeModuleHost_EnableBP Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost.GetModuleConduit
// (Final, RequiredAPI, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGbxGameModeModuleConduit>ConduitType                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxGameModeModuleHostConduitExecs*     Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxGameModeModuleConduit*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxGameModeModuleConduit* UGbxGameModeModuleHost::GetModuleConduit(TSubclassOf<class UGbxGameModeModuleConduit> ConduitType, EGbxGameModeModuleHostConduitExecs* Exec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "GetModuleConduit");

	Params::GbxGameModeModuleHost_GetModuleConduit Parms{};

	Parms.ConduitType = ConduitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeModuleHost.OnDisabledBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost::OnDisabledBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnDisabledBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost.OnEnabledBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost::OnEnabledBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnEnabledBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost.OnGameModePhaseChangedBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// FGbxDefPtrProperty_                     PhaseDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost::OnGameModePhaseChangedBP(FGbxDefPtrProperty_ PhaseDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnGameModePhaseChangedBP");

	Params::GbxGameModeModuleHost_OnGameModePhaseChangedBP Parms{};

	Parms.PhaseDef = PhaseDef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameModeModuleHost.OnLogoutBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AController*                      ExitingController                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost::OnLogoutBP(class AController* ExitingController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnLogoutBP");

	Params::GbxGameModeModuleHost_OnLogoutBP Parms{};

	Parms.ExitingController = ExitingController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameModeModuleHost.OnMatchAbortedBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost::OnMatchAbortedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnMatchAbortedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost.OnMatchEndedBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost::OnMatchEndedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnMatchEndedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost.OnMatchStartedBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost::OnMatchStartedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnMatchStartedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost.OnPostLoginBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost::OnPostLoginBP(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnPostLoginBP");

	Params::GbxGameModeModuleHost_OnPostLoginBP Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameModeModuleHost.OnPostMatchBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost::OnPostMatchBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnPostMatchBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost.OnPreMatchBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost::OnPreMatchBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "OnPreMatchBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost.UnwatchAllEvents
// (Final, Native, Public, BlueprintCallable)

void UGbxGameModeModuleHost::UnwatchAllEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "UnwatchAllEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost.UnwatchEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost::UnwatchEvent(FGbxDefPtrProperty_ EventDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "UnwatchEvent");

	Params::GbxGameModeModuleHost_UnwatchEvent Parms{};

	Parms.EventDef = EventDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost.WatchEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FGbxGameModeModuleEventParams& params)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost::WatchEvent(FGbxDefPtrProperty_ EventDef, TDelegate<void(const struct FGbxGameModeModuleEventParams& params)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "WatchEvent");

	Params::GbxGameModeModuleHost_WatchEvent Parms{};

	Parms.EventDef = EventDef;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost.GetGameMode
// (Final, RequiredAPI, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGbxGameMode*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGbxGameMode* UGbxGameModeModuleHost::GetGameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "GetGameMode");

	Params::GbxGameModeModuleHost_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeModuleHost.GetModuleParameter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxParam                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxParam UGbxGameModeModuleHost::GetModuleParameter(class FName ParamName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "GetModuleParameter");

	Params::GbxGameModeModuleHost_GetModuleParameter Parms{};

	Parms.ParamName = ParamName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeModuleHost.IsEnabled
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameModeModuleHost::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "IsEnabled");

	Params::GbxGameModeModuleHost_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeModuleHost.SetModuleParameter
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxParam&                 Value                                                  (Parm, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost::SetModuleParameter(class FName ParamName, const struct FGbxParam& Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost", "SetModuleParameter");

	Params::GbxGameModeModuleHost_SetModuleParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.CorpseFunctionLibrary.EnableCorpseCleanup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCorpseFunctionLibrary::EnableCorpseCleanup(class AActor* Context, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CorpseFunctionLibrary", "EnableCorpseCleanup");

	Params::CorpseFunctionLibrary_EnableCorpseCleanup Parms{};

	Parms.Context = Context;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageAreaInterface.GetEffectLocationInfo
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult*                      Result                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FRotator*                        Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageAreaInterface::GetEffectLocationInfo(struct FHitResult* Result, struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DamageAreaInterface", "GetEffectLocationInfo");

	Params::DamageAreaInterface_GetEffectLocationInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);

	return Parms.ReturnValue;
}


// Function GbxGame.DamageScript.OnDamage
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Causer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageEventDetails&       Details                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDamageScript::OnDamage(class AActor* instigator, class AActor* Causer, class AActor* target, const struct FDamageEventDetails& Details) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageScript", "OnDamage");

	Params::DamageScript_OnDamage Parms{};

	Parms.instigator = instigator;
	Parms.Causer = Causer;
	Parms.target = target;
	Parms.Details = std::move(Details);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.DamageScript.OnDamageEnemy
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Causer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageEventDetails&       Details                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDamageScript::OnDamageEnemy(class AActor* instigator, class AActor* Causer, class AActor* target, const struct FDamageEventDetails& Details) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageScript", "OnDamageEnemy");

	Params::DamageScript_OnDamageEnemy Parms{};

	Parms.instigator = instigator;
	Parms.Causer = Causer;
	Parms.target = target;
	Parms.Details = std::move(Details);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.DamageScript.OnDamageFriendly
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Causer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageEventDetails&       Details                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDamageScript::OnDamageFriendly(class AActor* instigator, class AActor* Causer, class AActor* target, const struct FDamageEventDetails& Details) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageScript", "OnDamageFriendly");

	Params::DamageScript_OnDamageFriendly Parms{};

	Parms.instigator = instigator;
	Parms.Causer = Causer;
	Parms.target = target;
	Parms.Details = std::move(Details);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.DamageScript.OnEffectTick
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class AActor*                           EffectContext                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageScript::OnEffectTick(class AActor* EffectContext, float ElapsedTime, float MaxDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageScript", "OnEffectTick");

	Params::DamageScript_OnEffectTick Parms{};

	Parms.EffectContext = EffectContext;
	Parms.ElapsedTime = ElapsedTime;
	Parms.MaxDuration = MaxDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.DamageScript.OnKillEnemy
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Causer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageEventDetails&       Details                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDamageScript::OnKillEnemy(class AActor* instigator, class AActor* Causer, class AActor* target, const struct FDamageEventDetails& Details) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageScript", "OnKillEnemy");

	Params::DamageScript_OnKillEnemy Parms{};

	Parms.instigator = instigator;
	Parms.Causer = Causer;
	Parms.target = target;
	Parms.Details = std::move(Details);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameMode.NotifyModeConfigured
// (RequiredAPI, Native, Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    ConfigIdent                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameMode::NotifyModeConfigured(const class FString& ConfigIdent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameMode", "NotifyModeConfigured");

	Params::GbxGameMode_NotifyModeConfigured Parms{};

	Parms.ConfigIdent = std::move(ConfigIdent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameMode.GetConfigDataForBP
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FNexusConfigDataBP               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNexusConfigDataBP AGbxGameMode::GetConfigDataForBP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameMode", "GetConfigDataForBP");

	Params::GbxGameMode_GetConfigDataForBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.Add_DamageSourceContainers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    A                                                      (Parm, NativeAccessSpecifierPublic)
// const struct FDamageSourceContainer&    B                                                      (Parm, NativeAccessSpecifierPublic)
// struct FDamageSourceContainer           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDamageSourceContainer UDamageStatics::Add_DamageSourceContainers(const struct FDamageSourceContainer& A, const struct FDamageSourceContainer& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "Add_DamageSourceContainers");

	Params::DamageStatics_Add_DamageSourceContainers Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.AddHealthPool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                HealthType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxAttributeInit>& Segments                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bChoosePoolAutomatically                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Pool                                                   (Parm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRefillAllHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RefillPercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDamageStatics::AddHealthPool(class AActor* Context, FGameDataHandleProperty_ HealthType, const TArray<struct FGbxAttributeInit>& Segments, bool bChoosePoolAutomatically, FGameDataHandleProperty_ Pool, bool bRefillAllHealth, float RefillPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "AddHealthPool");

	Params::DamageStatics_AddHealthPool Parms{};

	Parms.Context = Context;
	Parms.HealthType = HealthType;
	Parms.Segments = std::move(Segments);
	Parms.bChoosePoolAutomatically = bChoosePoolAutomatically;
	Parms.Pool = Pool;
	Parms.bRefillAllHealth = bRefillAllHealth;
	Parms.RefillPercent = RefillPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.BindHealthPoolSegmentStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolSegmentState           State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 Segment)>          Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::BindHealthPoolSegmentStateEvent(class AActor* Context, int32 layer, EGameResourcePoolSegmentState State, TDelegate<void(int32 Segment)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "BindHealthPoolSegmentStateEvent");

	Params::DamageStatics_BindHealthPoolSegmentStateEvent Parms{};

	Parms.Context = Context;
	Parms.layer = layer;
	Parms.State = State;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.BindHealthPoolStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolState                  State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::BindHealthPoolStateEvent(class AActor* Context, int32 layer, EGameResourcePoolState State, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "BindHealthPoolStateEvent");

	Params::DamageStatics_BindHealthPoolStateEvent Parms{};

	Parms.Context = Context;
	Parms.layer = layer;
	Parms.State = State;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.CauseDamage
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            DamageInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageData                                             (Parm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageTarget                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                TargetedHitInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageTypeOverride                                     (Parm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageSourceContainer&    DamageSourceOverride                                   (Parm, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bAppendDamageSource                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SourceActorOverride                                    (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SourceLocationOverride                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  SourceRotationOverride                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// class FName                             SourceSocketOverride                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRadiusOverride                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DamageExtentOverride                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FForceSelection&           ImpactForceOverride                                    (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const struct FImpactEffectSelection&    SourceEffectOverride                                   (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const struct FImpactEffectSelection&    ImpactEffectOverride                                   (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   DurationOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageTags&               DamageTags                                             (ConstParm, Parm, OutParm, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bInheritTimeDilation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthorityOverride                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::CauseDamage(class AActor* DamageCauser, class APawn* DamageInstigator, FGameDataHandleProperty_ DamageData, class AActor* DamageTarget, float DamageOverride, const struct FHitResult& TargetedHitInfo, FGameDataHandleProperty_ DamageTypeOverride, const struct FDamageSourceContainer& DamageSourceOverride, bool bAppendDamageSource, class AActor* SourceActorOverride, const struct FVector& SourceLocationOverride, const struct FRotator& SourceRotationOverride, class FName SourceSocketOverride, float DamageRadiusOverride, const struct FVector& DamageExtentOverride, const struct FForceSelection& ImpactForceOverride, const struct FImpactEffectSelection& SourceEffectOverride, const struct FImpactEffectSelection& ImpactEffectOverride, float DurationOverride, const struct FDamageTags& DamageTags, bool bInheritTimeDilation, bool bServerAuthorityOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "CauseDamage");

	Params::DamageStatics_CauseDamage Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.DamageInstigator = DamageInstigator;
	Parms.DamageData = DamageData;
	Parms.DamageTarget = DamageTarget;
	Parms.DamageOverride = DamageOverride;
	Parms.TargetedHitInfo = std::move(TargetedHitInfo);
	Parms.DamageTypeOverride = DamageTypeOverride;
	Parms.DamageSourceOverride = std::move(DamageSourceOverride);
	Parms.bAppendDamageSource = bAppendDamageSource;
	Parms.SourceActorOverride = SourceActorOverride;
	Parms.SourceLocationOverride = std::move(SourceLocationOverride);
	Parms.SourceRotationOverride = std::move(SourceRotationOverride);
	Parms.SourceSocketOverride = SourceSocketOverride;
	Parms.DamageRadiusOverride = DamageRadiusOverride;
	Parms.DamageExtentOverride = std::move(DamageExtentOverride);
	Parms.ImpactForceOverride = std::move(ImpactForceOverride);
	Parms.SourceEffectOverride = std::move(SourceEffectOverride);
	Parms.ImpactEffectOverride = std::move(ImpactEffectOverride);
	Parms.DurationOverride = DurationOverride;
	Parms.DamageTags = std::move(DamageTags);
	Parms.bInheritTimeDilation = bInheritTimeDilation;
	Parms.bServerAuthorityOverride = bServerAuthorityOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.Conv_DamageSource_DamageSourceContainer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const FGameDataHandleProperty_&         DamageSource                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageSourceContainer           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDamageSourceContainer UDamageStatics::Conv_DamageSource_DamageSourceContainer(const FGameDataHandleProperty_& DamageSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "Conv_DamageSource_DamageSourceContainer");

	Params::DamageStatics_Conv_DamageSource_DamageSourceContainer Parms{};

	Parms.DamageSource = DamageSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.Conv_DamageSourceContainer_DamageSource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ UDamageStatics::Conv_DamageSourceContainer_DamageSource(const struct FDamageSourceContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "Conv_DamageSourceContainer_DamageSource");

	Params::DamageStatics_Conv_DamageSourceContainer_DamageSource Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.Conv_DamageSourceContainer_GameDataHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ UDamageStatics::Conv_DamageSourceContainer_GameDataHandle(const struct FDamageSourceContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "Conv_DamageSourceContainer_GameDataHandle");

	Params::DamageStatics_Conv_DamageSourceContainer_GameDataHandle Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.Conv_DamageSourceContainer_String
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDamageStatics::Conv_DamageSourceContainer_String(const struct FDamageSourceContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "Conv_DamageSourceContainer_String");

	Params::DamageStatics_Conv_DamageSourceContainer_String Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.Conv_FloatToForceSelection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ForceSelection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FForceSelection                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FForceSelection UDamageStatics::Conv_FloatToForceSelection(float ForceSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "Conv_FloatToForceSelection");

	Params::DamageStatics_Conv_FloatToForceSelection Parms{};

	Parms.ForceSelection = ForceSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.Conv_ForceSelectionToFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FForceSelection&           ForceSelection                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDamageStatics::Conv_ForceSelectionToFloat(const struct FForceSelection& ForceSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "Conv_ForceSelectionToFloat");

	Params::DamageStatics_Conv_ForceSelectionToFloat Parms{};

	Parms.ForceSelection = std::move(ForceSelection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.EqualEqual_DamageSourceContainer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDamageSourceContainer&    B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::EqualEqual_DamageSourceContainer(const struct FDamageSourceContainer& A, const struct FDamageSourceContainer& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "EqualEqual_DamageSourceContainer");

	Params::DamageStatics_EqualEqual_DamageSourceContainer Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.EqualEqual_DamageSourceContainerDamageSource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const FGameDataHandleProperty_&         B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::EqualEqual_DamageSourceContainerDamageSource(const struct FDamageSourceContainer& A, const FGameDataHandleProperty_& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "EqualEqual_DamageSourceContainerDamageSource");

	Params::DamageStatics_EqualEqual_DamageSourceContainerDamageSource Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetCustomDamageNumberEvents
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDamageStatics::GetCustomDamageNumberEvents(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetCustomDamageNumberEvents");

	Params::DamageStatics_GetCustomDamageNumberEvents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.DamageStatics.GetDamageSourceContainerTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDamageSourceContainer&    Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDamageStatics::GetDamageSourceContainerTags(const struct FDamageSourceContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetDamageSourceContainerTags");

	Params::DamageStatics_GetDamageSourceContainerTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetDamageSourceTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         DamageSource                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UDamageStatics::GetDamageSourceTags(const FGameDataHandleProperty_& DamageSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetDamageSourceTags");

	Params::DamageStatics_GetDamageSourceTags Parms{};

	Parms.DamageSource = DamageSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetDeathDetails
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    OwnerContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FReceivedDamageDetails*          Details                                                (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::GetDeathDetails(const class UObject* OwnerContext, struct FReceivedDamageDetails* Details)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetDeathDetails");

	Params::DamageStatics_GetDeathDetails Parms{};

	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Details != nullptr)
		*Details = std::move(Parms.Details);

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetHealthPoolLayerOfType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                HealthType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTopDown                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDamageStatics::GetHealthPoolLayerOfType(class AActor* Context, FGameDataHandleProperty_ HealthType, bool bTopDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetHealthPoolLayerOfType");

	Params::DamageStatics_GetHealthPoolLayerOfType Parms{};

	Parms.Context = Context;
	Parms.HealthType = HealthType;
	Parms.bTopDown = bTopDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetHealthPoolPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDamageStatics::GetHealthPoolPercent(class AActor* Context, int32 layer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetHealthPoolPercent");

	Params::DamageStatics_GetHealthPoolPercent Parms{};

	Parms.Context = Context;
	Parms.layer = layer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetHitRegionHealthPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                def                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDamageStatics::GetHitRegionHealthPercent(class AActor* Context, class FName Name_0, FGameDataHandleProperty_ def)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetHitRegionHealthPercent");

	Params::DamageStatics_GetHitRegionHealthPercent Parms{};

	Parms.Context = Context;
	Parms.Name_0 = Name_0;
	Parms.def = def;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetNumHealthSlots
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNonDepleted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDamageStatics::GetNumHealthSlots(class AActor* Context, bool bNonDepleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetNumHealthSlots");

	Params::DamageStatics_GetNumHealthSlots Parms{};

	Parms.Context = Context;
	Parms.bNonDepleted = bNonDepleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.GetSummary_ForceSelection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FForceSelection&           ForceSelection                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDamageStatics::GetSummary_ForceSelection(const struct FForceSelection& ForceSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "GetSummary_ForceSelection");

	Params::DamageStatics_GetSummary_ForceSelection Parms{};

	Parms.ForceSelection = std::move(ForceSelection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.HasDamageSource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageSource                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExactMatch                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::HasDamageSource(const struct FDamageSourceContainer& Container, FGameDataHandleProperty_ DamageSource, bool bExactMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "HasDamageSource");

	Params::DamageStatics_HasDamageSource Parms{};

	Parms.Container = std::move(Container);
	Parms.DamageSource = DamageSource;
	Parms.bExactMatch = bExactMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.IsInGodMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::IsInGodMode(class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "IsInGodMode");

	Params::DamageStatics_IsInGodMode Parms{};

	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.IsInGodOrDemigodMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    OwnerContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::IsInGodOrDemigodMode(const class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "IsInGodOrDemigodMode");

	Params::DamageStatics_IsInGodOrDemigodMode Parms{};

	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.LockDemigod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::LockDemigod(class AActor* Actor, class FName reason, bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "LockDemigod");

	Params::DamageStatics_LockDemigod Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.LockGod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::LockGod(class AActor* Actor, class FName reason, bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "LockGod");

	Params::DamageStatics_LockGod Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.MakeDamageTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageTags&               tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDamageTags                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDamageTags UDamageStatics::MakeDamageTags(const struct FDamageTags& tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "MakeDamageTags");

	Params::DamageStatics_MakeDamageTags Parms{};

	Parms.tags = std::move(tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.MakeDamageTagsFromTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SingleTag                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageTags                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDamageTags UDamageStatics::MakeDamageTagsFromTag(class FName SingleTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "MakeDamageTagsFromTag");

	Params::DamageStatics_MakeDamageTagsFromTag Parms{};

	Parms.SingleTag = SingleTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.MakePipelineDamageInput
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageReceiver                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageSourceContainer&    DamageSource                                           (Parm, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitForceDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FForceSelection&           HitForceMagnitude                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FDamageTags&               DamageTags                                             (Parm, NativeAccessSpecifierPublic)
// struct FPipelineDamageInput             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPipelineDamageInput UDamageStatics::MakePipelineDamageInput(class AActor* DamageCauser, class AActor* DamageReceiver, FGameDataHandleProperty_ DamageType, const struct FDamageSourceContainer& DamageSource, const struct FHitResult& HitInfo, const struct FVector& HitLocation, const struct FVector& HitDirection, const struct FVector& HitForceDirection, const struct FForceSelection& HitForceMagnitude, const struct FDamageTags& DamageTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "MakePipelineDamageInput");

	Params::DamageStatics_MakePipelineDamageInput Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.DamageReceiver = DamageReceiver;
	Parms.DamageType = DamageType;
	Parms.DamageSource = std::move(DamageSource);
	Parms.HitInfo = std::move(HitInfo);
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitDirection = std::move(HitDirection);
	Parms.HitForceDirection = std::move(HitForceDirection);
	Parms.HitForceMagnitude = std::move(HitForceMagnitude);
	Parms.DamageTags = std::move(DamageTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.NotEqual_DamageSourceContainer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDamageSourceContainer&    B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::NotEqual_DamageSourceContainer(const struct FDamageSourceContainer& A, const struct FDamageSourceContainer& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "NotEqual_DamageSourceContainer");

	Params::DamageStatics_NotEqual_DamageSourceContainer Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.NotEqual_DamageSourceContainerDamageSource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDamageSourceContainer&    A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const FGameDataHandleProperty_&         B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::NotEqual_DamageSourceContainerDamageSource(const struct FDamageSourceContainer& A, const FGameDataHandleProperty_& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "NotEqual_DamageSourceContainerDamageSource");

	Params::DamageStatics_NotEqual_DamageSourceContainerDamageSource Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.RefillHealthPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                HealthType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::RefillHealthPercent(class AActor* Context, FGameDataHandleProperty_ HealthType, float Percent, float MaxPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "RefillHealthPercent");

	Params::DamageStatics_RefillHealthPercent Parms{};

	Parms.Context = Context;
	Parms.HealthType = HealthType;
	Parms.Percent = Percent;
	Parms.MaxPercent = MaxPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.RefillHitRegionHealth
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                def                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::RefillHitRegionHealth(class AActor* Context, class FName Name_0, FGameDataHandleProperty_ def, float Percent, float MaxPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "RefillHitRegionHealth");

	Params::DamageStatics_RefillHitRegionHealth Parms{};

	Parms.Context = Context;
	Parms.Name_0 = Name_0;
	Parms.def = def;
	Parms.Percent = Percent;
	Parms.MaxPercent = MaxPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.RegisterDamageableModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Damageable                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Modifier                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ContextOverride                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::RegisterDamageableModifier(class AActor* Damageable, FGameDataHandleProperty_ Modifier, class UObject* owner, class UObject* ContextOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "RegisterDamageableModifier");

	Params::DamageStatics_RegisterDamageableModifier Parms{};

	Parms.Damageable = Damageable;
	Parms.Modifier = Modifier;
	Parms.owner = owner;
	Parms.ContextOverride = ContextOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.RegisterDamageCauserModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Modifier                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ContextOverride                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::RegisterDamageCauserModifier(class AActor* DamageCauser, FGameDataHandleProperty_ Modifier, class UObject* owner, class UObject* ContextOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "RegisterDamageCauserModifier");

	Params::DamageStatics_RegisterDamageCauserModifier Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.Modifier = Modifier;
	Parms.owner = owner;
	Parms.ContextOverride = ContextOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.RemoveHealthPool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                HealthType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Pool                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::RemoveHealthPool(class AActor* Context, FGameDataHandleProperty_ HealthType, FGameDataHandleProperty_ Pool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "RemoveHealthPool");

	Params::DamageStatics_RemoveHealthPool Parms{};

	Parms.Context = Context;
	Parms.HealthType = HealthType;
	Parms.Pool = Pool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.ResetHealthAndDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::ResetHealthAndDamage(class AActor* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "ResetHealthAndDamage");

	Params::DamageStatics_ResetHealthAndDamage Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.StartHealthRegen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxAttributeInit&         RegenRate                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bStopWhenFull                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TickRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     HealthTags                                             (Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDamageStatics::StartHealthRegen(class AActor* Context, float Duration, const struct FGbxAttributeInit& RegenRate, bool bStopWhenFull, float TickRate, const struct FGameplayTagContainer& HealthTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "StartHealthRegen");

	Params::DamageStatics_StartHealthRegen Parms{};

	Parms.Context = Context;
	Parms.Duration = Duration;
	Parms.RegenRate = std::move(RegenRate);
	Parms.bStopWhenFull = bStopWhenFull;
	Parms.TickRate = TickRate;
	Parms.HealthTags = std::move(HealthTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DamageStatics.StopCausingAllDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamageContextSource                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::StopCausingAllDamage(class AActor* DamageContextSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "StopCausingAllDamage");

	Params::DamageStatics_StopCausingAllDamage Parms{};

	Parms.DamageContextSource = DamageContextSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.StopCausingDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamageContextSource                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageData                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::StopCausingDamage(class AActor* DamageContextSource, FGameDataHandleProperty_ DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "StopCausingDamage");

	Params::DamageStatics_StopCausingDamage Parms{};

	Parms.DamageContextSource = DamageContextSource;
	Parms.DamageData = DamageData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.StopCausingDamageToTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamageContextSource                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageData                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::StopCausingDamageToTarget(class AActor* DamageContextSource, class AActor* DamageTarget, FGameDataHandleProperty_ DamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "StopCausingDamageToTarget");

	Params::DamageStatics_StopCausingDamageToTarget Parms{};

	Parms.DamageContextSource = DamageContextSource;
	Parms.DamageTarget = DamageTarget;
	Parms.DamageData = DamageData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.StopHealthRegen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::StopHealthRegen(class AActor* Context, int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "StopHealthRegen");

	Params::DamageStatics_StopHealthRegen Parms{};

	Parms.Context = Context;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.SubscribeToHealthDepletedEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* DamageReceiver, class AActor* DamageCauser)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::SubscribeToHealthDepletedEvent(class UObject* OwnerContext, TDelegate<void(class AActor* DamageReceiver, class AActor* DamageCauser)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "SubscribeToHealthDepletedEvent");

	Params::DamageStatics_SubscribeToHealthDepletedEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.SubscribeToTakeDamageEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* DamageReceiver, const struct FReceivedDamageDetails& Details)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::SubscribeToTakeDamageEvent(class UObject* OwnerContext, TDelegate<void(class AActor* DamageReceiver, const struct FReceivedDamageDetails& Details)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "SubscribeToTakeDamageEvent");

	Params::DamageStatics_SubscribeToTakeDamageEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.TriggerGore
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Goreable                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageSeverity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::TriggerGore(class AActor* Goreable, class FName BoneName, float DamageSeverity, const struct FVector& HitDirection, const struct FVector& HitForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "TriggerGore");

	Params::DamageStatics_TriggerGore Parms{};

	Parms.Goreable = Goreable;
	Parms.BoneName = BoneName;
	Parms.DamageSeverity = DamageSeverity;
	Parms.HitDirection = std::move(HitDirection);
	Parms.HitForce = std::move(HitForce);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.TryWaterExplosion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     SourceActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::TryWaterExplosion(class AActor* instigator, const class AActor* SourceActor, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "TryWaterExplosion");

	Params::DamageStatics_TryWaterExplosion Parms{};

	Parms.instigator = instigator;
	Parms.SourceActor = SourceActor;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.UnbindHealthPoolSegmentStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolSegmentState           State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 Segment)>          DelegateHandle                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::UnbindHealthPoolSegmentStateEvent(class AActor* Context, int32 layer, EGameResourcePoolSegmentState State, TDelegate<void(int32 Segment)> DelegateHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "UnbindHealthPoolSegmentStateEvent");

	Params::DamageStatics_UnbindHealthPoolSegmentStateEvent Parms{};

	Parms.Context = Context;
	Parms.layer = layer;
	Parms.State = State;
	Parms.DelegateHandle = DelegateHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.UnbindHealthPoolStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolState                  State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       DelegateHandle                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::UnbindHealthPoolStateEvent(class AActor* Context, int32 layer, EGameResourcePoolState State, TDelegate<void()> DelegateHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "UnbindHealthPoolStateEvent");

	Params::DamageStatics_UnbindHealthPoolStateEvent Parms{};

	Parms.Context = Context;
	Parms.layer = layer;
	Parms.State = State;
	Parms.DelegateHandle = DelegateHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.UnregisterDamageableModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Damageable                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Modifier                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::UnregisterDamageableModifier(class AActor* Damageable, FGameDataHandleProperty_ Modifier, class UObject* owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "UnregisterDamageableModifier");

	Params::DamageStatics_UnregisterDamageableModifier Parms{};

	Parms.Damageable = Damageable;
	Parms.Modifier = Modifier;
	Parms.owner = owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.UnregisterDamageCauserModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Modifier                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::UnregisterDamageCauserModifier(class AActor* DamageCauser, FGameDataHandleProperty_ Modifier, class UObject* owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "UnregisterDamageCauserModifier");

	Params::DamageStatics_UnregisterDamageCauserModifier Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.Modifier = Modifier;
	Parms.owner = owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.UnsubscribeFromHealthDepletedEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* DamageReceiver, class AActor* DamageCauser)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::UnsubscribeFromHealthDepletedEvent(class UObject* OwnerContext, TDelegate<void(class AActor* DamageReceiver, class AActor* DamageCauser)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "UnsubscribeFromHealthDepletedEvent");

	Params::DamageStatics_UnsubscribeFromHealthDepletedEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.UnsubscribeFromTakeDamageEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* DamageReceiver, const struct FReceivedDamageDetails& Details)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageStatics::UnsubscribeFromTakeDamageEvent(class UObject* OwnerContext, TDelegate<void(class AActor* DamageReceiver, const struct FReceivedDamageDetails& Details)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DamageStatics", "UnsubscribeFromTakeDamageEvent");

	Params::DamageStatics_UnsubscribeFromTakeDamageEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DamageStatics.IsStructAllowedForValueResolver
// (Final, Native, Protected)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UScriptStruct*              ScriptStruct                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamageStatics::IsStructAllowedForValueResolver(class UObject* Object, const class UScriptStruct* ScriptStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageStatics", "IsStructAllowedForValueResolver");

	Params::DamageStatics_IsStructAllowedForValueResolver Parms{};

	Parms.Object = Object;
	Parms.ScriptStruct = ScriptStruct;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.DangerWarningFunctionLibrary.AddDangerWarningSource
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ThreatRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   damageradius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDangerWarningFunctionLibrary::AddDangerWarningSource(class AActor* Source, float ThreatRadius, float damageradius, class FName type, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DangerWarningFunctionLibrary", "AddDangerWarningSource");

	Params::DangerWarningFunctionLibrary_AddDangerWarningSource Parms{};

	Parms.Source = Source;
	Parms.ThreatRadius = ThreatRadius;
	Parms.damageradius = damageradius;
	Parms.type = type;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DangerWarningFunctionLibrary.RemoveDangerWarningSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDangerWarningFunctionLibrary::RemoveDangerWarningSource(class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DangerWarningFunctionLibrary", "RemoveDangerWarningSource");

	Params::DangerWarningFunctionLibrary_RemoveDangerWarningSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameAudioBlueprintFunctionLibrary.PlayFoleyImpactOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFoleyImpactParams&        FoleyImpactParams                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxGameAudioBlueprintFunctionLibrary::PlayFoleyImpactOnActor(class AActor* Actor, const struct FFoleyImpactParams& FoleyImpactParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameAudioBlueprintFunctionLibrary", "PlayFoleyImpactOnActor");

	Params::GbxGameAudioBlueprintFunctionLibrary_PlayFoleyImpactOnActor Parms{};

	Parms.Actor = Actor;
	Parms.FoleyImpactParams = std::move(FoleyImpactParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameAudioBlueprintFunctionLibrary.PostEventInWorldMulticast
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxAudioEmitterSource&    EmitterSource                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxAudioEvent&            Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     OptionalSwitch                                         (Parm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameAudioBlueprintFunctionLibrary::PostEventInWorldMulticast(class UObject* WorldContextObject, class AActor* ActorInstigator, const struct FGbxAudioEmitterSource& EmitterSource, const struct FGbxAudioEvent& Event, FGbxDefPtrProperty_ OptionalSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameAudioBlueprintFunctionLibrary", "PostEventInWorldMulticast");

	Params::GbxGameAudioBlueprintFunctionLibrary_PostEventInWorldMulticast Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorInstigator = ActorInstigator;
	Parms.EmitterSource = std::move(EmitterSource);
	Parms.Event = std::move(Event);
	Parms.OptionalSwitch = OptionalSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameAudioBlueprintFunctionLibrary.PostWwiseEventOnActorMulticast
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorInstigator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxAudioEvent&            Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FName                       EmitterTag                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     OptionalSwitch                                         (Parm, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameAudioBlueprintFunctionLibrary::PostWwiseEventOnActorMulticast(class UObject* WorldContextObject, class AActor* ActorInstigator, const struct FGbxAudioEvent& Event, const class FName EmitterTag, FGbxDefPtrProperty_ OptionalSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameAudioBlueprintFunctionLibrary", "PostWwiseEventOnActorMulticast");

	Params::GbxGameAudioBlueprintFunctionLibrary_PostWwiseEventOnActorMulticast Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorInstigator = ActorInstigator;
	Parms.Event = std::move(Event);
	Parms.EmitterTag = EmitterTag;
	Parms.OptionalSwitch = OptionalSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameAudioBlueprintFunctionLibrary.TryGetGlobalWetnessForActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  GlobalWetnessValue                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsValueValid                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameAudioBlueprintFunctionLibrary::TryGetGlobalWetnessForActor(class AActor* Actor, float* GlobalWetnessValue, bool* bIsValueValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameAudioBlueprintFunctionLibrary", "TryGetGlobalWetnessForActor");

	Params::GbxGameAudioBlueprintFunctionLibrary_TryGetGlobalWetnessForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GlobalWetnessValue != nullptr)
		*GlobalWetnessValue = Parms.GlobalWetnessValue;

	if (bIsValueValid != nullptr)
		*bIsValueValid = Parms.bIsValueValid;
}


// Function GbxGame.GbxInventorySettings.GetInventoryEffectTypes
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxInventorySettings::GetInventoryEffectTypes(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxInventorySettings", "GetInventoryEffectTypes");

	Params::GbxInventorySettings_GetInventoryEffectTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.DodgingFunctionLibrary.AIDodgeOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAIDodgeData*               DodgeData                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDodgingFunctionLibrary::AIDodgeOverride(class AActor* AIActor, class FName reason, bool Block, const class UAIDodgeData* DodgeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DodgingFunctionLibrary", "AIDodgeOverride");

	Params::DodgingFunctionLibrary_AIDodgeOverride Parms{};

	Parms.AIActor = AIActor;
	Parms.reason = reason;
	Parms.Block = Block;
	Parms.DodgeData = DodgeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DodgingFunctionLibrary.AIScriptedDodge
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIDodgeType                            DodgeType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocalDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipConditions                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDodgingFunctionLibrary::AIScriptedDodge(class AActor* AIActor, EAIDodgeType DodgeType, float LocalDirection, bool bSkipConditions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DodgingFunctionLibrary", "AIScriptedDodge");

	Params::DodgingFunctionLibrary_AIScriptedDodge Parms{};

	Parms.AIActor = AIActor;
	Parms.DodgeType = DodgeType;
	Parms.LocalDirection = LocalDirection;
	Parms.bSkipConditions = bSkipConditions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DodgingFunctionLibrary.LockDodging
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDodgingFunctionLibrary::LockDodging(class AActor* Actor, class FName reason, bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DodgingFunctionLibrary", "LockDodging");

	Params::DodgingFunctionLibrary_LockDodging Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DodgingFunctionLibrary.TriggerBulletDodge
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   MuzzleLoc                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   BulletVel                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDodgingFunctionLibrary::TriggerBulletDodge(class UObject* WorldContextObject, const struct FVector& MuzzleLoc, const struct FVector& BulletVel, class AActor* instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DodgingFunctionLibrary", "TriggerBulletDodge");

	Params::DodgingFunctionLibrary_TriggerBulletDodge Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MuzzleLoc = std::move(MuzzleLoc);
	Parms.BulletVel = std::move(BulletVel);
	Parms.instigator = instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DodgingFunctionLibrary.TriggerGrenadeDodge
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GrenadeLoc                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExtraDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDodgingFunctionLibrary::TriggerGrenadeDodge(class UObject* WorldContextObject, const struct FVector& GrenadeLoc, class AActor* instigator, float ExtraDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DodgingFunctionLibrary", "TriggerGrenadeDodge");

	Params::DodgingFunctionLibrary_TriggerGrenadeDodge Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.GrenadeLoc = std::move(GrenadeLoc);
	Parms.instigator = instigator;
	Parms.ExtraDelay = ExtraDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.DodgingFunctionLibrary.TriggerZoneDodge
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ZoneLoc                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ZoneVel                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorRef                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDodgingFunctionLibrary::TriggerZoneDodge(class UObject* WorldContextObject, class AActor* TargetActor, const struct FVector& ZoneLoc, const struct FVector& ZoneVel, class AActor* ActorRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DodgingFunctionLibrary", "TriggerZoneDodge");

	Params::DodgingFunctionLibrary_TriggerZoneDodge Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TargetActor = TargetActor;
	Parms.ZoneLoc = std::move(ZoneLoc);
	Parms.ZoneVel = std::move(ZoneVel);
	Parms.ActorRef = ActorRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxVisibilityPhaseStatics.GetAllPhaseNames
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxVisibilityPhaseStatics::GetAllPhaseNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxVisibilityPhaseStatics", "GetAllPhaseNames");

	Params::GbxVisibilityPhaseStatics_GetAllPhaseNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.GbxVisibilityPhaseStatics.GetFilteredPhaseNames
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FName                             IgnoredPhaseName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxVisibilityPhaseStatics::GetFilteredPhaseNames(class FName IgnoredPhaseName, TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxVisibilityPhaseStatics", "GetFilteredPhaseNames");

	Params::GbxVisibilityPhaseStatics_GetFilteredPhaseNames Parms{};

	Parms.IgnoredPhaseName = IgnoredPhaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.FactsBlueprintLibrary.BoolToFactValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFactValue                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFactValue UFactsBlueprintLibrary::BoolToFactValue(bool Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "BoolToFactValue");

	Params::FactsBlueprintLibrary_BoolToFactValue Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.BuildFactHandleListFromObjectList
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UObject*>&           ObjectList                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    RegistryChannel                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class UFactHandle*>*             FactHandleList                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::BuildFactHandleListFromObjectList(class UObject* OwnerContext, const TArray<class UObject*>& ObjectList, const class FString& RegistryChannel, const struct FLatentActionInfo& LatentInfo, TArray<class UFactHandle*>* FactHandleList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "BuildFactHandleListFromObjectList");

	Params::FactsBlueprintLibrary_BuildFactHandleListFromObjectList Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.ObjectList = std::move(ObjectList);
	Parms.RegistryChannel = std::move(RegistryChannel);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FactHandleList != nullptr)
		*FactHandleList = std::move(Parms.FactHandleList);
}


// Function GbxGame.FactsBlueprintLibrary.Equal_FactAddressHandle
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFactAddress&              FactAddress                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UFactHandle*                FactHandle                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::Equal_FactAddressHandle(const struct FFactAddress& FactAddress, const class UFactHandle* FactHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "Equal_FactAddressHandle");

	Params::FactsBlueprintLibrary_Equal_FactAddressHandle Parms{};

	Parms.FactAddress = std::move(FactAddress);
	Parms.FactHandle = FactHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.Equal_FactHandle
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UFactHandle*                A                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UFactHandle*                B                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::Equal_FactHandle(const class UFactHandle* A, const class UFactHandle* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "Equal_FactHandle");

	Params::FactsBlueprintLibrary_Equal_FactHandle Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.Equal_FactValueFactValue
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFactValue&                A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FFactValue&                B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::Equal_FactValueFactValue(const struct FFactValue& A, const struct FFactValue& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "Equal_FactValueFactValue");

	Params::FactsBlueprintLibrary_Equal_FactValueFactValue Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactAddress
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RegistryChannel                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFactAddress                     ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFactAddress UFactsBlueprintLibrary::GetFactAddress(class UObject* OwnerContext, const class FString& RegistryChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactAddress");

	Params::FactsBlueprintLibrary_GetFactAddress Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.RegistryChannel = std::move(RegistryChannel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactAddressName
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RegistryChannel                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFactsBlueprintLibrary::GetFactAddressName(class UObject* OwnerContext, const class FString& RegistryChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactAddressName");

	Params::FactsBlueprintLibrary_GetFactAddressName Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.RegistryChannel = std::move(RegistryChannel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactHandleAsBool
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFactHandle*                Param                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::GetFactHandleAsBool(const class UFactHandle* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactHandleAsBool");

	Params::FactsBlueprintLibrary_GetFactHandleAsBool Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactHandleAsFloat
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFactHandle*                Param                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFactsBlueprintLibrary::GetFactHandleAsFloat(const class UFactHandle* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactHandleAsFloat");

	Params::FactsBlueprintLibrary_GetFactHandleAsFloat Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactHandleAsInt32
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFactHandle*                Param                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFactsBlueprintLibrary::GetFactHandleAsInt32(const class UFactHandle* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactHandleAsInt32");

	Params::FactsBlueprintLibrary_GetFactHandleAsInt32 Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactHandleAsName
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFactHandle*                Param                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UFactsBlueprintLibrary::GetFactHandleAsName(const class UFactHandle* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactHandleAsName");

	Params::FactsBlueprintLibrary_GetFactHandleAsName Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactHandleAsString
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFactHandle*                Param                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFactsBlueprintLibrary::GetFactHandleAsString(const class UFactHandle* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactHandleAsString");

	Params::FactsBlueprintLibrary_GetFactHandleAsString Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactValueAsBool
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFactValue&                Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::GetFactValueAsBool(const struct FFactValue& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactValueAsBool");

	Params::FactsBlueprintLibrary_GetFactValueAsBool Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactValueAsInt
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFactValue&                Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFactsBlueprintLibrary::GetFactValueAsInt(const struct FFactValue& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactValueAsInt");

	Params::FactsBlueprintLibrary_GetFactValueAsInt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.GetFactValueAsName
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFactValue&                Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UFactsBlueprintLibrary::GetFactValueAsName(const struct FFactValue& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "GetFactValueAsName");

	Params::FactsBlueprintLibrary_GetFactValueAsName Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.IntToFactValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFactValue                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFactValue UFactsBlueprintLibrary::IntToFactValue(int32 Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "IntToFactValue");

	Params::FactsBlueprintLibrary_IntToFactValue Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.MakeFactAddress
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFactAddress&              FactAddress                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFactAddress                     ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFactAddress UFactsBlueprintLibrary::MakeFactAddress(const struct FFactAddress& FactAddress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "MakeFactAddress");

	Params::FactsBlueprintLibrary_MakeFactAddress Parms{};

	Parms.FactAddress = std::move(FactAddress);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.NameToFactValue
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      Param                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFactValue                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFactValue UFactsBlueprintLibrary::NameToFactValue(const class FName& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "NameToFactValue");

	Params::FactsBlueprintLibrary_NameToFactValue Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.NotEqual_FactAddressHandle
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFactAddress&              FactAddress                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UFactHandle*                FactHandle                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::NotEqual_FactAddressHandle(const struct FFactAddress& FactAddress, const class UFactHandle* FactHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "NotEqual_FactAddressHandle");

	Params::FactsBlueprintLibrary_NotEqual_FactAddressHandle Parms{};

	Parms.FactAddress = std::move(FactAddress);
	Parms.FactHandle = FactHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.NotEqual_FactHandle
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UFactHandle*                A                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UFactHandle*                B                                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::NotEqual_FactHandle(const class UFactHandle* A, const class UFactHandle* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "NotEqual_FactHandle");

	Params::FactsBlueprintLibrary_NotEqual_FactHandle Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.NotEqual_FactValueFactValue
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFactValue&                A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FFactValue&                B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactsBlueprintLibrary::NotEqual_FactValueFactValue(const struct FFactValue& A, const struct FFactValue& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "NotEqual_FactValueFactValue");

	Params::FactsBlueprintLibrary_NotEqual_FactValueFactValue Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.FactsBlueprintLibrary.ReadFact
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    AddressString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            AsName                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  AsInt                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   AsBool                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::ReadFact(class UObject* OwnerContext, const class FString& AddressString, class FName* AsName, int32* AsInt, bool* AsBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "ReadFact");

	Params::FactsBlueprintLibrary_ReadFact Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.AddressString = std::move(AddressString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AsName != nullptr)
		*AsName = Parms.AsName;

	if (AsInt != nullptr)
		*AsInt = Parms.AsInt;

	if (AsBool != nullptr)
		*AsBool = Parms.AsBool;
}


// Function GbxGame.FactsBlueprintLibrary.ReadFactForObject
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RegistryChannel                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            AsName                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  AsInt                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   AsBool                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::ReadFactForObject(class UObject* OwnerContext, const class FString& RegistryChannel, class FName* AsName, int32* AsInt, bool* AsBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "ReadFactForObject");

	Params::FactsBlueprintLibrary_ReadFactForObject Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.RegistryChannel = std::move(RegistryChannel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AsName != nullptr)
		*AsName = Parms.AsName;

	if (AsInt != nullptr)
		*AsInt = Parms.AsInt;

	if (AsBool != nullptr)
		*AsBool = Parms.AsBool;
}


// Function GbxGame.FactsBlueprintLibrary.ReadFactFromObjectGetHandle
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RegistryChannel                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UFactHandle**                     FactHandle                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::ReadFactFromObjectGetHandle(class UObject* OwnerContext, const class FString& RegistryChannel, const struct FLatentActionInfo& LatentInfo, class UFactHandle** FactHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "ReadFactFromObjectGetHandle");

	Params::FactsBlueprintLibrary_ReadFactFromObjectGetHandle Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.RegistryChannel = std::move(RegistryChannel);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FactHandle != nullptr)
		*FactHandle = Parms.FactHandle;
}


// Function GbxGame.FactsBlueprintLibrary.ReadFactGetHandle
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFactAddress&              FactAddress                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFactHandle**                     FactHandle                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::ReadFactGetHandle(class UObject* OwnerContext, const struct FFactAddress& FactAddress, class UFactHandle** FactHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "ReadFactGetHandle");

	Params::FactsBlueprintLibrary_ReadFactGetHandle Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.FactAddress = std::move(FactAddress);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FactHandle != nullptr)
		*FactHandle = Parms.FactHandle;
}


// Function GbxGame.FactsBlueprintLibrary.SetFactHandleValue
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UFactHandle*                      FactHandle                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFactValue&                Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::SetFactHandleValue(class UFactHandle* FactHandle, const struct FFactValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "SetFactHandleValue");

	Params::FactsBlueprintLibrary_SetFactHandleValue Parms{};

	Parms.FactHandle = FactHandle;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.FactsBlueprintLibrary.SetFactHandleValueAsBool
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFactHandle*                      FactHandle                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    BoolValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::SetFactHandleValueAsBool(class UFactHandle* FactHandle, bool BoolValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "SetFactHandleValueAsBool");

	Params::FactsBlueprintLibrary_SetFactHandleValueAsBool Parms{};

	Parms.FactHandle = FactHandle;
	Parms.BoolValue = BoolValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.FactsBlueprintLibrary.SetFactHandleValueAsInt
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFactHandle*                      FactHandle                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IntValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::SetFactHandleValueAsInt(class UFactHandle* FactHandle, int32 IntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "SetFactHandleValueAsInt");

	Params::FactsBlueprintLibrary_SetFactHandleValueAsInt Parms{};

	Parms.FactHandle = FactHandle;
	Parms.IntValue = IntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.FactsBlueprintLibrary.SetFactHandleValueAsName
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UFactHandle*                      FactHandle                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      NameValue                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::SetFactHandleValueAsName(class UFactHandle* FactHandle, const class FName& NameValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "SetFactHandleValueAsName");

	Params::FactsBlueprintLibrary_SetFactHandleValueAsName Parms{};

	Parms.FactHandle = FactHandle;
	Parms.NameValue = NameValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.FactsBlueprintLibrary.WriteFact
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    AddressString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       AsName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             AsInt                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              AsBool                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::WriteFact(class UObject* OwnerContext, const class FString& AddressString, const class FName AsName, const int32 AsInt, const bool AsBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "WriteFact");

	Params::FactsBlueprintLibrary_WriteFact Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.AddressString = std::move(AddressString);
	Parms.AsName = AsName;
	Parms.AsInt = AsInt;
	Parms.AsBool = AsBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.FactsBlueprintLibrary.WriteFactForObject
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RegistryChannel                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       AsName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             AsInt                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              AsBool                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::WriteFactForObject(class UObject* OwnerContext, const class FString& RegistryChannel, const class FName AsName, const int32 AsInt, const bool AsBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "WriteFactForObject");

	Params::FactsBlueprintLibrary_WriteFactForObject Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.RegistryChannel = std::move(RegistryChannel);
	Parms.AsName = AsName;
	Parms.AsInt = AsInt;
	Parms.AsBool = AsBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.FactsBlueprintLibrary.WriteFactForObjectGetHandle
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RegistryChannel                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFactValue&                Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UFactHandle**                     FactHandle                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::WriteFactForObjectGetHandle(class UObject* OwnerContext, const class FString& RegistryChannel, const struct FFactValue& Value, const struct FLatentActionInfo& LatentInfo, class UFactHandle** FactHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "WriteFactForObjectGetHandle");

	Params::FactsBlueprintLibrary_WriteFactForObjectGetHandle Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.RegistryChannel = std::move(RegistryChannel);
	Parms.Value = std::move(Value);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FactHandle != nullptr)
		*FactHandle = Parms.FactHandle;
}


// Function GbxGame.FactsBlueprintLibrary.WriteFactNewGetHandle
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFactAddress&              FactAddress                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFactValue&                Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UFactHandle**                     FactHandle                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactsBlueprintLibrary::WriteFactNewGetHandle(class UObject* OwnerContext, const struct FFactAddress& FactAddress, const struct FFactValue& Value, class UFactHandle** FactHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactsBlueprintLibrary", "WriteFactNewGetHandle");

	Params::FactsBlueprintLibrary_WriteFactNewGetHandle Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.FactAddress = std::move(FactAddress);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FactHandle != nullptr)
		*FactHandle = Parms.FactHandle;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.AdjustResourcePoolValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::AdjustResourcePoolValue(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "AdjustResourcePoolValue");

	Params::GameResourcePoolFunctionLibrary_AdjustResourcePoolValue Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.BindResourcePoolSegmentStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                resource                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolSegmentState           State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 Segment)>          Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::BindResourcePoolSegmentStateEvent(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ resource, EGameResourcePoolSegmentState State, TDelegate<void(int32 Segment)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "BindResourcePoolSegmentStateEvent");

	Params::GameResourcePoolFunctionLibrary_BindResourcePoolSegmentStateEvent Parms{};

	Parms.owner = owner;
	Parms.resource = resource;
	Parms.State = State;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.BindResourcePoolStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                resource                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolState                  State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::BindResourcePoolStateEvent(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ resource, EGameResourcePoolState State, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "BindResourcePoolStateEvent");

	Params::GameResourcePoolFunctionLibrary_BindResourcePoolStateEvent Parms{};

	Parms.owner = owner;
	Parms.resource = resource;
	Parms.State = State;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.ClearResourcePoolRegenDelay
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::ClearResourcePoolRegenDelay(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "ClearResourcePoolRegenDelay");

	Params::GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.CreatePool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResourcePool                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::CreatePool(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResourcePool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "CreatePool");

	Params::GameResourcePoolFunctionLibrary_CreatePool Parms{};

	Parms.owner = owner;
	Parms.InResourcePool = InResourcePool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.DeleteResourcePool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::DeleteResourcePool(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "DeleteResourcePool");

	Params::GameResourcePoolFunctionLibrary_DeleteResourcePool Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.DrainResourcePoolByPercentage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPercentage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::DrainResourcePoolByPercentage(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, float Percentage, float MinPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "DrainResourcePoolByPercentage");

	Params::GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.Percentage = Percentage;
	Parms.MinPercentage = MinPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.DrainResourcePoolSegment
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWholeSegmentsOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::DrainResourcePoolSegment(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, float Percentage, bool bWholeSegmentsOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "DrainResourcePoolSegment");

	Params::GameResourcePoolFunctionLibrary_DrainResourcePoolSegment Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.Percentage = Percentage;
	Parms.bWholeSegmentsOnly = bWholeSegmentsOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.GetResourcePoolPercent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameResourcePoolFunctionLibrary::GetResourcePoolPercent(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "GetResourcePoolPercent");

	Params::GameResourcePoolFunctionLibrary_GetResourcePoolPercent Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.GetResourcePoolValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameResourcePoolFunctionLibrary::GetResourcePoolValue(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "GetResourcePoolValue");

	Params::GameResourcePoolFunctionLibrary_GetResourcePoolValue Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.IsResourcePoolInState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolState                  InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameResourcePoolFunctionLibrary::IsResourcePoolInState(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, EGameResourcePoolState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "IsResourcePoolInState");

	Params::GameResourcePoolFunctionLibrary_IsResourcePoolInState Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.RefillResourcePoolByPercentage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPercentage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::RefillResourcePoolByPercentage(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, float Percentage, float MaxPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "RefillResourcePoolByPercentage");

	Params::GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.Percentage = Percentage;
	Parms.MaxPercentage = MaxPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.RefillResourcePoolSegment
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWholeSegmentsOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::RefillResourcePoolSegment(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, float Percentage, bool bWholeSegmentsOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "RefillResourcePoolSegment");

	Params::GameResourcePoolFunctionLibrary_RefillResourcePoolSegment Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.Percentage = Percentage;
	Parms.bWholeSegmentsOnly = bWholeSegmentsOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.ResetResourcePoolRegenDelay
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::ResetResourcePoolRegenDelay(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "ResetResourcePoolRegenDelay");

	Params::GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.SetResourcePoolValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::SetResourcePoolValue(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "SetResourcePoolValue");

	Params::GameResourcePoolFunctionLibrary_SetResourcePoolValue Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.SetResourcePoolValueByPercentage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                InResource                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::SetResourcePoolValueByPercentage(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ InResource, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "SetResourcePoolValueByPercentage");

	Params::GameResourcePoolFunctionLibrary_SetResourcePoolValueByPercentage Parms{};

	Parms.owner = owner;
	Parms.InResource = InResource;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.UnbindResourcePoolSegmentStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                resource                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolSegmentState           State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(int32 Segment)>          DelegateHandle                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::UnbindResourcePoolSegmentStateEvent(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ resource, EGameResourcePoolSegmentState State, TDelegate<void(int32 Segment)> DelegateHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "UnbindResourcePoolSegmentStateEvent");

	Params::GameResourcePoolFunctionLibrary_UnbindResourcePoolSegmentStateEvent Parms{};

	Parms.owner = owner;
	Parms.resource = resource;
	Parms.State = State;
	Parms.DelegateHandle = DelegateHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GameResourcePoolFunctionLibrary.UnbindResourcePoolStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameResourcePoolOwnerInterface>owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                resource                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameResourcePoolState                  State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       DelegateHandle                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameResourcePoolFunctionLibrary::UnbindResourcePoolStateEvent(TScriptInterface<class IGameResourcePoolOwnerInterface> owner, FGameDataHandleProperty_ resource, EGameResourcePoolState State, TDelegate<void()> DelegateHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameResourcePoolFunctionLibrary", "UnbindResourcePoolStateEvent");

	Params::GameResourcePoolFunctionLibrary_UnbindResourcePoolStateEvent Parms{};

	Parms.owner = owner;
	Parms.resource = resource;
	Parms.State = State;
	Parms.DelegateHandle = DelegateHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxOpportunisticAmbientAudioDebugSettings.GetGbxOpportunisticAmbientAudioDebugSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGbxOpportunisticAmbientAudioDebugSettings*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxOpportunisticAmbientAudioDebugSettings* UGbxOpportunisticAmbientAudioDebugSettings::GetGbxOpportunisticAmbientAudioDebugSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxOpportunisticAmbientAudioDebugSettings", "GetGbxOpportunisticAmbientAudioDebugSettings");

	Params::GbxOpportunisticAmbientAudioDebugSettings_GetGbxOpportunisticAmbientAudioDebugSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxOpportunisticAmbientAudioDebugSettings.SaveConfigChanges
// (Final, Native, Public, BlueprintCallable)

void UGbxOpportunisticAmbientAudioDebugSettings::SaveConfigChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxOpportunisticAmbientAudioDebugSettings", "SaveConfigChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.ApplyActorCameraRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  DeltaRotation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::ApplyActorCameraRotation(class AActor* Actor, const struct FRotator& DeltaRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "ApplyActorCameraRotation");

	Params::PlayerCameraModeManager_ApplyActorCameraRotation Parms{};

	Parms.Actor = Actor;
	Parms.DeltaRotation = std::move(DeltaRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.GetActorCameraMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName APlayerCameraModeManager::GetActorCameraMode(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "GetActorCameraMode");

	Params::PlayerCameraModeManager_GetActorCameraMode Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.PlayerCameraModeManager.GetActorDefaultCameraMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName APlayerCameraModeManager::GetActorDefaultCameraMode(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "GetActorDefaultCameraMode");

	Params::PlayerCameraModeManager_GetActorDefaultCameraMode Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.PlayerCameraModeManager.PopActorCameraMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OptionalTransitionName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTimeOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::PopActorCameraMode(class AActor* Actor, class FName ModeName, class FName OptionalTransitionName, float BlendTimeOverride, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "PopActorCameraMode");

	Params::PlayerCameraModeManager_PopActorCameraMode Parms{};

	Parms.Actor = Actor;
	Parms.ModeName = ModeName;
	Parms.OptionalTransitionName = OptionalTransitionName;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.PopActorCameraModeDef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     CameraModeDef                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     CameraTransitionDef                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTimeOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::PopActorCameraModeDef(class AActor* Actor, FGbxDefPtrProperty_ CameraModeDef, FGbxDefPtrProperty_ CameraTransitionDef, float BlendTimeOverride, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "PopActorCameraModeDef");

	Params::PlayerCameraModeManager_PopActorCameraModeDef Parms{};

	Parms.Actor = Actor;
	Parms.CameraModeDef = CameraModeDef;
	Parms.CameraTransitionDef = CameraTransitionDef;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.PushActorCameraMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OptionalTransitionName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTimeOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::PushActorCameraMode(class AActor* Actor, class FName ModeName, class FName OptionalTransitionName, float BlendTimeOverride, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "PushActorCameraMode");

	Params::PlayerCameraModeManager_PushActorCameraMode Parms{};

	Parms.Actor = Actor;
	Parms.ModeName = ModeName;
	Parms.OptionalTransitionName = OptionalTransitionName;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.PushActorCameraModeDef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     CameraModeDef                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     CameraTransitionDef                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTimeOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::PushActorCameraModeDef(class AActor* Actor, FGbxDefPtrProperty_ CameraModeDef, FGbxDefPtrProperty_ CameraTransitionDef, float BlendTimeOverride, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "PushActorCameraModeDef");

	Params::PlayerCameraModeManager_PushActorCameraModeDef Parms{};

	Parms.Actor = Actor;
	Parms.CameraModeDef = CameraModeDef;
	Parms.CameraTransitionDef = CameraTransitionDef;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.ResetActorCameraRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::ResetActorCameraRotation(class AActor* Actor, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "ResetActorCameraRotation");

	Params::PlayerCameraModeManager_ResetActorCameraRotation Parms{};

	Parms.Actor = Actor;
	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.SetActorCameraMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OptionalTransitionName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTimeOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceResetMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::SetActorCameraMode(class AActor* Actor, class FName ModeName, class FName OptionalTransitionName, float BlendTimeOverride, bool bTeleport, bool bForceResetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "SetActorCameraMode");

	Params::PlayerCameraModeManager_SetActorCameraMode Parms{};

	Parms.Actor = Actor;
	Parms.ModeName = ModeName;
	Parms.OptionalTransitionName = OptionalTransitionName;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.bTeleport = bTeleport;
	Parms.bForceResetMode = bForceResetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.SetActorCameraModeDef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     CameraModeDef                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     CameraTransitionDef                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTimeOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceResetMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::SetActorCameraModeDef(class AActor* Actor, FGbxDefPtrProperty_ CameraModeDef, FGbxDefPtrProperty_ CameraTransitionDef, float BlendTimeOverride, bool bTeleport, bool bForceResetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCameraModeManager", "SetActorCameraModeDef");

	Params::PlayerCameraModeManager_SetActorCameraModeDef Parms{};

	Parms.Actor = Actor;
	Parms.CameraModeDef = CameraModeDef;
	Parms.CameraTransitionDef = CameraTransitionDef;
	Parms.BlendTimeOverride = BlendTimeOverride;
	Parms.bTeleport = bTeleport;
	Parms.bForceResetMode = bForceResetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.OnBaseFOVChanged
// (Final, Native, Public)
// Parameters:
// float                                   NewBaseFOV                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::OnBaseFOVChanged(float NewBaseFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraModeManager", "OnBaseFOVChanged");

	Params::PlayerCameraModeManager_OnBaseFOVChanged Parms{};

	Parms.NewBaseFOV = NewBaseFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.PlayGbxCameraShake
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         ShakeAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraShakePlaySpace                   PlaySpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  UserPlaySpaceRot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bLoopingShake                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::PlayGbxCameraShake(const FGameDataHandleProperty_& ShakeAsset, float scale, ECameraShakePlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot, bool bLoopingShake)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraModeManager", "PlayGbxCameraShake");

	Params::PlayerCameraModeManager_PlayGbxCameraShake Parms{};

	Parms.ShakeAsset = ShakeAsset;
	Parms.scale = scale;
	Parms.PlaySpace = PlaySpace;
	Parms.UserPlaySpaceRot = std::move(UserPlaySpaceRot);
	Parms.bLoopingShake = bLoopingShake;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.StopAllGbxCameraShakes
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::StopAllGbxCameraShakes(bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraModeManager", "StopAllGbxCameraShakes");

	Params::PlayerCameraModeManager_StopAllGbxCameraShakes Parms{};

	Parms.bImmediately = bImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PlayerCameraModeManager.StopAllInstancesOfGbxCameraShake
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         Shake                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraModeManager::StopAllInstancesOfGbxCameraShake(const FGameDataHandleProperty_& Shake, bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCameraModeManager", "StopAllInstancesOfGbxCameraShake");

	Params::PlayerCameraModeManager_StopAllInstancesOfGbxCameraShake Parms{};

	Parms.Shake = Shake;
	Parms.bImmediately = bImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActivityAreaStamp.SetDefaultLayout
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FName&                      SelectedStampLayoutName                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxActivityAreaStamp::SetDefaultLayout(const class FName& SelectedStampLayoutName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActivityAreaStamp", "SetDefaultLayout");

	Params::GbxActivityAreaStamp_SetDefaultLayout Parms{};

	Parms.SelectedStampLayoutName = SelectedStampLayoutName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActivityAreaStamp.UpdateWorldAsset
// (Final, Native, Public)

void AGbxActivityAreaStamp::UpdateWorldAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActivityAreaStamp", "UpdateWorldAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActivityAreaStamp.GetLayoutNames
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AGbxActivityAreaStamp::GetLayoutNames(TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActivityAreaStamp", "GetLayoutNames");

	Params::GbxActivityAreaStamp_GetLayoutNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.GbxActivityBlueprintLibrary.CreateActivityRequest
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     InActivityRequestDef                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_*               AssociatedRegion                                       (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActivityTags&             InExcludedActivityTags                                 (Parm, NativeAccessSpecifierPublic)
// const struct FActivityTags&             InRequiredActivityTags                                 (Parm, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActivityBlueprintLibrary::CreateActivityRequest(FGbxDefPtrProperty_ InActivityRequestDef, FGameDataHandleProperty_* AssociatedRegion, const struct FActivityTags& InExcludedActivityTags, const struct FActivityTags& InRequiredActivityTags, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "CreateActivityRequest");

	Params::GbxActivityBlueprintLibrary_CreateActivityRequest Parms{};

	Parms.InActivityRequestDef = InActivityRequestDef;
	Parms.InExcludedActivityTags = std::move(InExcludedActivityTags);
	Parms.InRequiredActivityTags = std::move(InRequiredActivityTags);
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AssociatedRegion != nullptr)
		*AssociatedRegion = Parms.AssociatedRegion;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetActivityAreaActorTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxActivityBlueprintLibrary::GetActivityAreaActorTags(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetActivityAreaActorTags");

	Params::GbxActivityBlueprintLibrary_GetActivityAreaActorTags Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetActivityInstanceRequestOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxActivityBlueprintLibrary::GetActivityInstanceRequestOwner(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetActivityInstanceRequestOwner");

	Params::GbxActivityBlueprintLibrary_GetActivityInstanceRequestOwner Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetActivityTagNames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxActivityBlueprintLibrary::GetActivityTagNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetActivityTagNames");

	Params::GbxActivityBlueprintLibrary_GetActivityTagNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetAllLoadedStampLayoutDefsIdent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UGbxActivityBlueprintLibrary::GetAllLoadedStampLayoutDefsIdent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetAllLoadedStampLayoutDefsIdent");

	Params::GbxActivityBlueprintLibrary_GetAllLoadedStampLayoutDefsIdent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetAllMissionsHeldInActivityDef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// FGbxDefPtrProperty_                     InActivityRequestDef                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<FGbxDefPtrProperty_>*            OutMissionDefs                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxActivityBlueprintLibrary::GetAllMissionsHeldInActivityDef(FGbxDefPtrProperty_ InActivityRequestDef, TArray<FGbxDefPtrProperty_>* OutMissionDefs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetAllMissionsHeldInActivityDef");

	Params::GbxActivityBlueprintLibrary_GetAllMissionsHeldInActivityDef Parms{};

	Parms.InActivityRequestDef = InActivityRequestDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMissionDefs != nullptr)
		*OutMissionDefs = std::move(Parms.OutMissionDefs);
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetAreaLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ActivityStampActorAddress                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxActivityBlueprintLibrary::GetAreaLocation(class AActor* Context, const class FString& ActivityStampActorAddress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetAreaLocation");

	Params::GbxActivityBlueprintLibrary_GetAreaLocation Parms{};

	Parms.Context = Context;
	Parms.ActivityStampActorAddress = std::move(ActivityStampActorAddress);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetAssociatedActivityAreaTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxActivityBlueprintLibrary::GetAssociatedActivityAreaTags(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetAssociatedActivityAreaTags");

	Params::GbxActivityBlueprintLibrary_GetAssociatedActivityAreaTags Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetAssociatedMissionInstances
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMissionInstanceHandle>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMissionInstanceHandle> UGbxActivityBlueprintLibrary::GetAssociatedMissionInstances(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetAssociatedMissionInstances");

	Params::GbxActivityBlueprintLibrary_GetAssociatedMissionInstances Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.GetStampModelNames
// (Final, Native, Static, Public)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxActivityBlueprintLibrary::GetStampModelNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "GetStampModelNames");

	Params::GbxActivityBlueprintLibrary_GetStampModelNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActivityBlueprintLibrary.SetActivityAreaIsLocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Area                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActivityBlueprintLibrary::SetActivityAreaIsLocked(class AActor* Area, bool bIsLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "SetActivityAreaIsLocked");

	Params::GbxActivityBlueprintLibrary_SetActivityAreaIsLocked Parms{};

	Parms.Area = Area;
	Parms.bIsLocked = bIsLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActivityBlueprintLibrary.SetAreasInLevelInstanceIsLocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ContextActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaSubmapName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLocked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActivityBlueprintLibrary::SetAreasInLevelInstanceIsLocked(class AActor* ContextActor, class FName AreaSubmapName, bool IsLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActivityBlueprintLibrary", "SetAreasInLevelInstanceIsLocked");

	Params::GbxActivityBlueprintLibrary_SetAreasInLevelInstanceIsLocked Parms{};

	Parms.ContextActor = ContextActor;
	Parms.AreaSubmapName = AreaSubmapName;
	Parms.IsLocked = IsLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProjectileMovementComponent.AIDodgeNotify
// (Final, Native, Public)

void UGbxProjectileMovementComponent::AIDodgeNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProjectileMovementComponent", "AIDodgeNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProjectileMovementComponent.ScaleVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxProjectileMovementComponent::ScaleVelocity(float InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProjectileMovementComponent", "ScaleVelocity");

	Params::GbxProjectileMovementComponent_ScaleVelocity Parms{};

	Parms.InScale = InScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.WalkingProjectileMovementComponent.ExplodeOnAirborne
// (Final, Native, Protected)

void UWalkingProjectileMovementComponent::ExplodeOnAirborne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WalkingProjectileMovementComponent", "ExplodeOnAirborne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActivityStampAlwaysLoadedActorRuntime.OnRep_ReplicatedFXData
// (Final, Native, Private)

void AGbxActivityStampAlwaysLoadedActorRuntime::OnRep_ReplicatedFXData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActivityStampAlwaysLoadedActorRuntime", "OnRep_ReplicatedFXData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationChannelEnabled
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationChannelEnabled(class AActor* Actor, const struct FGameplayTag& ChannelTag, bool bNewEnabled, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationChannelEnabled");

	Params::GbxRotationBlueprintLibrary_SetRotationChannelEnabled Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.bNewEnabled = bNewEnabled;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationChannelPaused
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewPaused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationChannelPaused(class AActor* Actor, const struct FGameplayTag& ChannelTag, bool bNewPaused, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationChannelPaused");

	Params::GbxRotationBlueprintLibrary_SetRotationChannelPaused Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.bNewPaused = bNewPaused;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationTargetActor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationTargetActor(class AActor* Actor, const struct FGameplayTag& ChannelTag, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationTargetActor");

	Params::GbxRotationBlueprintLibrary_SetRotationTargetActor Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationTargetActorEyes
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationTargetActorEyes(class AActor* Actor, const struct FGameplayTag& ChannelTag, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationTargetActorEyes");

	Params::GbxRotationBlueprintLibrary_SetRotationTargetActorEyes Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationTargetActorSocket
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationTargetActorSocket(class AActor* Actor, const struct FGameplayTag& ChannelTag, class AActor* TargetActor, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationTargetActorSocket");

	Params::GbxRotationBlueprintLibrary_SetRotationTargetActorSocket Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.TargetActor = TargetActor;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationTargetDefault
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationTargetDefault(class AActor* Actor, const struct FGameplayTag& ChannelTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationTargetDefault");

	Params::GbxRotationBlueprintLibrary_SetRotationTargetDefault Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationTargetLocation
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationTargetLocation(class AActor* Actor, const struct FGameplayTag& ChannelTag, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationTargetLocation");

	Params::GbxRotationBlueprintLibrary_SetRotationTargetLocation Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationTargetRotation
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationTargetRotation(class AActor* Actor, const struct FGameplayTag& ChannelTag, const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationTargetRotation");

	Params::GbxRotationBlueprintLibrary_SetRotationTargetRotation Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRotationBlueprintLibrary.SetRotationTargetRotationLocal
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  LocalRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGbxRotationBlueprintLibrary::SetRotationTargetRotationLocal(class AActor* Actor, const struct FGameplayTag& ChannelTag, const struct FRotator& LocalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRotationBlueprintLibrary", "SetRotationTargetRotationLocal");

	Params::GbxRotationBlueprintLibrary_SetRotationTargetRotationLocal Parms{};

	Parms.Actor = Actor;
	Parms.ChannelTag = std::move(ChannelTag);
	Parms.LocalRotation = std::move(LocalRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_Material.InterpColor
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     MaterialID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_Material::InterpColor(const struct FGbxSkillComponentReference& ComponentReference, const struct FLinearColor& Color, const struct FGuid& MaterialID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_Material", "InterpColor");

	Params::GbxSkillComponentFunctions_Material_InterpColor Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.Color = std::move(Color);
	Parms.MaterialID = std::move(MaterialID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_Material.InterpScalar
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Scalar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     MaterialID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_Material::InterpScalar(const struct FGbxSkillComponentReference& ComponentReference, float Scalar, const struct FGuid& MaterialID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_Material", "InterpScalar");

	Params::GbxSkillComponentFunctions_Material_InterpScalar Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.Scalar = Scalar;
	Parms.MaterialID = std::move(MaterialID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxReplicatedNiagaraActor.OnSystemFinished
// (Final, Native, Public)
// Parameters:
// class UNiagaraComponent*                Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxReplicatedNiagaraActor::OnSystemFinished(class UNiagaraComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxReplicatedNiagaraActor", "OnSystemFinished");

	Params::GbxReplicatedNiagaraActor_OnSystemFinished Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ManagedActorFunctionLibrary.AddManagedActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManagedActorFunctionLibrary::AddManagedActor(FGameDataHandleProperty_ definition, class AActor* Actor, class AActor* owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManagedActorFunctionLibrary", "AddManagedActor");

	Params::ManagedActorFunctionLibrary_AddManagedActor Parms{};

	Parms.definition = definition;
	Parms.Actor = Actor;
	Parms.owner = owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ManagedActorFunctionLibrary.GetManagedActorCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UManagedActorFunctionLibrary::GetManagedActorCount(FGameDataHandleProperty_ definition, class AActor* owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManagedActorFunctionLibrary", "GetManagedActorCount");

	Params::ManagedActorFunctionLibrary_GetManagedActorCount Parms{};

	Parms.definition = definition;
	Parms.owner = owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ManagedActorFunctionLibrary.RemoveManagedActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestroyActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManagedActorFunctionLibrary::RemoveManagedActor(class AActor* Actor, bool bDestroyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManagedActorFunctionLibrary", "RemoveManagedActor");

	Params::ManagedActorFunctionLibrary_RemoveManagedActor Parms{};

	Parms.Actor = Actor;
	Parms.bDestroyActor = bDestroyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorScript_DeliverySpawnPoint.GetLoopTricks
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class UGbxTrick_Loop*>*          OutTricks                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxActorScript_DeliverySpawnPoint::GetLoopTricks(TArray<class UGbxTrick_Loop*>* OutTricks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxActorScript_DeliverySpawnPoint", "GetLoopTricks");

	Params::GbxActorScript_DeliverySpawnPoint_GetLoopTricks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTricks != nullptr)
		*OutTricks = std::move(Parms.OutTricks);
}


// Function GbxGame.GbxActorStateSequence.GetSequenceState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             StateMachine                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxActorStateSequence::GetSequenceState(class FName StateMachine, class UObject* OwnerContext, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorStateSequence", "GetSequenceState");

	Params::GbxActorStateSequence_GetSequenceState Parms{};

	Parms.StateMachine = StateMachine;
	Parms.OwnerContext = OwnerContext;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorStateSequence.GetSequenceStateAsBool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             StateMachine                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxActorStateSequence::GetSequenceStateAsBool(class FName StateMachine, class UObject* OwnerContext, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorStateSequence", "GetSequenceStateAsBool");

	Params::GbxActorStateSequence_GetSequenceStateAsBool Parms{};

	Parms.StateMachine = StateMachine;
	Parms.OwnerContext = OwnerContext;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxActorStateSequence.SetSequenceState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             StateMachine                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActorStateSequence::SetSequenceState(class FName StateMachine, class FName State, class UObject* OwnerContext, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorStateSequence", "SetSequenceState");

	Params::GbxActorStateSequence_SetSequenceState Parms{};

	Parms.StateMachine = StateMachine;
	Parms.State = State;
	Parms.OwnerContext = OwnerContext;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxActorStateSequence.SetSequenceStateAsBool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             StateMachine                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Prefix                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxActorStateSequence::SetSequenceStateAsBool(class FName StateMachine, bool bEnabled, class UObject* OwnerContext, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxActorStateSequence", "SetSequenceStateAsBool");

	Params::GbxActorStateSequence_SetSequenceStateAsBool Parms{};

	Parms.StateMachine = StateMachine;
	Parms.bEnabled = bEnabled;
	Parms.OwnerContext = OwnerContext;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINode.AttachActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxAINode::AttachActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINode", "AttachActor");

	Params::GbxAINode_AttachActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINode.GetOrWaitForSpawnedActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor**                          OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxAINode::GetOrWaitForSpawnedActor(const struct FLatentActionInfo& LatentInfo, class AActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINode", "GetOrWaitForSpawnedActor");

	Params::GbxAINode_GetOrWaitForSpawnedActor Parms{};

	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;
}


// Function GbxGame.GbxAINode.IsNodeEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxAINode::IsNodeEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINode", "IsNodeEnabled");

	Params::GbxAINode_IsNodeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxAINode.ResetNodeSpawn
// (Final, Native, Public, BlueprintCallable)

void AGbxAINode::ResetNodeSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINode", "ResetNodeSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINode.SetGbxActorDef
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const FGameDataHandleProperty_&         NewGbxActorDef                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxAINode::SetGbxActorDef(const FGameDataHandleProperty_& NewGbxActorDef, bool bResetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINode", "SetGbxActorDef");

	Params::GbxAINode_SetGbxActorDef Parms{};

	Parms.NewGbxActorDef = NewGbxActorDef;
	Parms.bResetActor = bResetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINode.SetNodeEnabled
// (Final, Native, Public, BlueprintCallable)

void AGbxAINode::SetNodeEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINode", "SetNodeEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAINode.GetSpawnedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGbxAINode::GetSpawnedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAINode", "GetSpawnedActor");

	Params::GbxAINode_GetSpawnedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.PerchStatics.AIScriptedPerch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Perch                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxBrainExec*                          Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPerchStatics::AIScriptedPerch(class AActor* AIActor, class AActor* Perch, EGbxBrainExec* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerchStatics", "AIScriptedPerch");

	Params::PerchStatics_AIScriptedPerch Parms{};

	Parms.AIActor = AIActor;
	Parms.Perch = Perch;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxGame.PerchStatics.SetPerchEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Perch                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerchStatics::SetPerchEnabled(class AActor* Perch, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerchStatics", "SetPerchEnabled");

	Params::PerchStatics_SetPerchEnabled Parms{};

	Parms.Perch = Perch;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAnimBlueprintLibrary.CalculateAnimations
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     GbxCharacter                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAnimBlueprintLibrary::CalculateAnimations(const class AActor* GbxCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxAnimBlueprintLibrary", "CalculateAnimations");

	Params::GbxAnimBlueprintLibrary_CalculateAnimations Parms{};

	Parms.GbxCharacter = GbxCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.CleanUpPuddleById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuddleHazard::CleanUpPuddleById(class UObject* WorldContext, int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PuddleHazard", "CleanUpPuddleById");

	Params::PuddleHazard_CleanUpPuddleById Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.CleanUpPuddleByOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PuddleOwner                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuddleHazard::CleanUpPuddleByOwner(class AActor* PuddleOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PuddleHazard", "CleanUpPuddleByOwner");

	Params::PuddleHazard_CleanUpPuddleByOwner Parms{};

	Parms.PuddleOwner = PuddleOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.ForEachPuddle_Owner
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           PuddleOwner                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(class APuddleHazard* Puddle)>&Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuddleHazard::ForEachPuddle_Owner(class AActor* PuddleOwner, const TDelegate<void(class APuddleHazard* Puddle)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PuddleHazard", "ForEachPuddle_Owner");

	Params::PuddleHazard_ForEachPuddle_Owner Parms{};

	Parms.PuddleOwner = PuddleOwner;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.SpawnPuddleHazard
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PuddleOwner                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageSourceContainer&    DamageSource                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const bool                              bCanDamageOwner                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bCanDamageFriendlies                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifespan_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdjustSpawnTransform                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLevelSyncDamage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GroundPlacementRadius                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APuddleHazard::SpawnPuddleHazard(class UObject* WorldContext, class AActor* PuddleOwner, const struct FTransform& Transform, FGameDataHandleProperty_ definition, const struct FDamageSourceContainer& DamageSource, const bool bCanDamageOwner, const bool bCanDamageFriendlies, float Radius, float lifespan_0, bool bAdjustSpawnTransform, float DamageOverride, bool bLevelSyncDamage, float GroundPlacementRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PuddleHazard", "SpawnPuddleHazard");

	Params::PuddleHazard_SpawnPuddleHazard Parms{};

	Parms.WorldContext = WorldContext;
	Parms.PuddleOwner = PuddleOwner;
	Parms.Transform = std::move(Transform);
	Parms.definition = definition;
	Parms.DamageSource = std::move(DamageSource);
	Parms.bCanDamageOwner = bCanDamageOwner;
	Parms.bCanDamageFriendlies = bCanDamageFriendlies;
	Parms.Radius = Radius;
	Parms.lifespan_0 = lifespan_0;
	Parms.bAdjustSpawnTransform = bAdjustSpawnTransform;
	Parms.DamageOverride = DamageOverride;
	Parms.bLevelSyncDamage = bLevelSyncDamage;
	Parms.GroundPlacementRadius = GroundPlacementRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.PuddleHazard.BeginInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                NewState                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SourceDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewInstigator                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuddleHazard::BeginInteraction(FGameDataHandleProperty_ NewState, bool bIsSource, float SourceDuration, class AActor* NewInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuddleHazard", "BeginInteraction");

	Params::PuddleHazard_BeginInteraction Parms{};

	Parms.NewState = NewState;
	Parms.bIsSource = bIsSource;
	Parms.SourceDuration = SourceDuration;
	Parms.NewInstigator = NewInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.Convert
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                NewDef                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuddleHazard::Convert(FGameDataHandleProperty_ NewDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuddleHazard", "Convert");

	Params::PuddleHazard_Convert Parms{};

	Parms.NewDef = NewDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.OnRep_CleanUpPuddle
// (Final, Native, Protected)

void APuddleHazard::OnRep_CleanUpPuddle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuddleHazard", "OnRep_CleanUpPuddle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.OnRep_DefHandle
// (Final, Native, Protected)

void APuddleHazard::OnRep_DefHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuddleHazard", "OnRep_DefHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.PuddleHazard.OnRep_InteractionState
// (Final, Native, Protected)

void APuddleHazard::OnRep_InteractionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuddleHazard", "OnRep_InteractionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMusicBlueprintFunctions.PostMusicEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              MusicEventTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMusicBlueprintFunctions::PostMusicEvent(class UObject* WorldContextObject, const struct FGameplayTag& MusicEventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMusicBlueprintFunctions", "PostMusicEvent");

	Params::GbxMusicBlueprintFunctions_PostMusicEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MusicEventTag = std::move(MusicEventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStandIn.GetLinkedActorDefName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AGbxStandIn::GetLinkedActorDefName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStandIn", "GetLinkedActorDefName");

	Params::GbxStandIn_GetLinkedActorDefName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStandIn.GetLinkedPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* AGbxStandIn::GetLinkedPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStandIn", "GetLinkedPlayerState");

	Params::GbxStandIn_GetLinkedPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxAOEComponent.AttachTargetQueryFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(class AActor* target)>   Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAOEComponent::AttachTargetQueryFunction(TDelegate<void(class AActor* target)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAOEComponent", "AttachTargetQueryFunction");

	Params::GbxAOEComponent_AttachTargetQueryFunction Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAOEComponent.OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxAOEComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAOEComponent", "OnBeginOverlap");

	Params::GbxAOEComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxAOEComponent.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxAOEComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAOEComponent", "OnEndOverlap");

	Params::GbxAOEComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformKillVolume.GetAvailablePlatformStates
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OptionList                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AGbxMovingPlatformKillVolume::GetAvailablePlatformStates(TArray<class FName>* OptionList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformKillVolume", "GetAvailablePlatformStates");

	Params::GbxMovingPlatformKillVolume_GetAvailablePlatformStates Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OptionList != nullptr)
		*OptionList = std::move(Parms.OptionList);
}


// Function GbxGame.GbxAudioVolumeComponent.IsInsideVolume
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   LocationToTest                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxAudioVolumeComponent::IsInsideVolume(const struct FVector& LocationToTest) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAudioVolumeComponent", "IsInsideVolume");

	Params::GbxAudioVolumeComponent_IsInsideVolume Parms{};

	Parms.LocationToTest = std::move(LocationToTest);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxLocalPlayer.SetCameraShakeIntensity
// (Final, Native, Public)
// Parameters:
// float                                   InCameraShakeIntensity                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetCameraShakeIntensity(float InCameraShakeIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetCameraShakeIntensity");

	Params::GbxLocalPlayer_SetCameraShakeIntensity Parms{};

	Parms.InCameraShakeIntensity = InCameraShakeIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetDialogVolume
// (Final, Native, Public)
// Parameters:
// float                                   NewDialogVolume                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetDialogVolume(float NewDialogVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetDialogVolume");

	Params::GbxLocalPlayer_SetDialogVolume Parms{};

	Parms.NewDialogVolume = NewDialogVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetMusicVolume
// (Final, Native, Public)
// Parameters:
// float                                   NewMusicVolume                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetMusicVolume(float NewMusicVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetMusicVolume");

	Params::GbxLocalPlayer_SetMusicVolume Parms{};

	Parms.NewMusicVolume = NewMusicVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetMuteHitNotifies
// (Final, Native, Public)
// Parameters:
// bool                                    NewMHN                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetMuteHitNotifies(bool NewMHN)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetMuteHitNotifies");

	Params::GbxLocalPlayer_SetMuteHitNotifies Parms{};

	Parms.NewMHN = NewMHN;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetOverallVolume
// (Final, Native, Public)
// Parameters:
// float                                   NewOverallVolume                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetOverallVolume(float NewOverallVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetOverallVolume");

	Params::GbxLocalPlayer_SetOverallVolume Parms{};

	Parms.NewOverallVolume = NewOverallVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetPlayInBackground
// (Final, Native, Public)
// Parameters:
// bool                                    NewPIB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetPlayInBackground(bool NewPIB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetPlayInBackground");

	Params::GbxLocalPlayer_SetPlayInBackground Parms{};

	Parms.NewPIB = NewPIB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetReactiveTriggersEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bInReactiveTriggersEnabled                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetReactiveTriggersEnabled(bool bInReactiveTriggersEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetReactiveTriggersEnabled");

	Params::GbxLocalPlayer_SetReactiveTriggersEnabled Parms{};

	Parms.bInReactiveTriggersEnabled = bInReactiveTriggersEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetRumbleEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bInRumbleEnabled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetRumbleEnabled(bool bInRumbleEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetRumbleEnabled");

	Params::GbxLocalPlayer_SetRumbleEnabled Parms{};

	Parms.bInRumbleEnabled = bInRumbleEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.SetSFXVolume
// (Final, Native, Public)
// Parameters:
// float                                   NewSFXVolume                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxLocalPlayer::SetSFXVolume(float NewSFXVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "SetSFXVolume");

	Params::GbxLocalPlayer_SetSFXVolume Parms{};

	Parms.NewSFXVolume = NewSFXVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLocalPlayer.GetCameraShakeIntensity
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxLocalPlayer::GetCameraShakeIntensity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "GetCameraShakeIntensity");

	Params::GbxLocalPlayer_GetCameraShakeIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxLocalPlayer.GetMuteHitNotifies
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxLocalPlayer::GetMuteHitNotifies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "GetMuteHitNotifies");

	Params::GbxLocalPlayer_GetMuteHitNotifies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxLocalPlayer.GetReactiveTriggersEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxLocalPlayer::GetReactiveTriggersEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "GetReactiveTriggersEnabled");

	Params::GbxLocalPlayer_GetReactiveTriggersEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxLocalPlayer.GetRumbleEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxLocalPlayer::GetRumbleEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLocalPlayer", "GetRumbleEnabled");

	Params::GbxLocalPlayer_GetRumbleEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxBodyFunctionLibrary.AttachBody
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGbxAttachableBodyData*           Body                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBodyFunctionLibrary::AttachBody(class UGbxAttachableBodyData* Body, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyFunctionLibrary", "AttachBody");

	Params::GbxBodyFunctionLibrary_AttachBody Parms{};

	Parms.Body = Body;
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxBodyFunctionLibrary.DetachBody
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGbxAttachableBodyData*           Body                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBodyFunctionLibrary::DetachBody(class UGbxAttachableBodyData* Body, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyFunctionLibrary", "DetachBody");

	Params::GbxBodyFunctionLibrary_DetachBody Parms{};

	Parms.Body = Body;
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxBodyFunctionLibrary.GetBodyComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    owner                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class USceneComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UGbxBodyFunctionLibrary::GetBodyComponent(const class UObject* owner, TSubclassOf<class USceneComponent> ComponentClass, class FName Name_0, class FName socket, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyFunctionLibrary", "GetBodyComponent");

	Params::GbxBodyFunctionLibrary_GetBodyComponent Parms{};

	Parms.owner = owner;
	Parms.ComponentClass = ComponentClass;
	Parms.Name_0 = Name_0;
	Parms.socket = socket;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxBodyFunctionLibrary.GetBodyComponents
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    owner                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class USceneComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class USceneComponent*> UGbxBodyFunctionLibrary::GetBodyComponents(const class UObject* owner, TSubclassOf<class USceneComponent> ComponentClass, class FName Name_0, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyFunctionLibrary", "GetBodyComponents");

	Params::GbxBodyFunctionLibrary_GetBodyComponents Parms{};

	Parms.owner = owner;
	Parms.ComponentClass = ComponentClass;
	Parms.Name_0 = Name_0;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxBodyFunctionLibrary.GetBodyParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxParam*                       OutValue                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBodyFunctionLibrary::GetBodyParameter(class FName Parameter, struct FGbxParam* OutValue, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyFunctionLibrary", "GetBodyParameter");

	Params::GbxBodyFunctionLibrary_GetBodyParameter Parms{};

	Parms.Parameter = Parameter;
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);
}


// Function GbxGame.GbxBodyFunctionLibrary.SetBodyParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxParam&                 Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UGbxBodyData>      Body                                                   (Parm, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxBodyFunctionLibrary::SetBodyParameter(class FName Parameter, const struct FGbxParam& Value, class UObject* OwnerContext, TSoftObjectPtr<class UGbxBodyData> Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxBodyFunctionLibrary", "SetBodyParameter");

	Params::GbxBodyFunctionLibrary_SetBodyParameter Parms{};

	Parms.Parameter = Parameter;
	Parms.Value = std::move(Value);
	Parms.OwnerContext = OwnerContext;
	Parms.Body = Body;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStatusEffectSignatureParam.AddParam_Actor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGbxStatusEffectPushSpec&        Spec                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGbxStatusEffectSignatureParam>ParamType                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxStatusEffectPushSpec         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxStatusEffectPushSpec UGbxStatusEffectSignatureParam::AddParam_Actor(struct FGbxStatusEffectPushSpec& Spec, TSubclassOf<class UGbxStatusEffectSignatureParam> ParamType, class AActor* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam", "AddParam_Actor");

	Params::GbxStatusEffectSignatureParam_AddParam_Actor Parms{};

	Parms.Spec = std::move(Spec);
	Parms.ParamType = ParamType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Spec = std::move(Parms.Spec);

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam.AddParam_Float
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGbxStatusEffectPushSpec&        Spec                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGbxStatusEffectSignatureParam>ParamType                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxStatusEffectPushSpec         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxStatusEffectPushSpec UGbxStatusEffectSignatureParam::AddParam_Float(struct FGbxStatusEffectPushSpec& Spec, TSubclassOf<class UGbxStatusEffectSignatureParam> ParamType, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam", "AddParam_Float");

	Params::GbxStatusEffectSignatureParam_AddParam_Float Parms{};

	Parms.Spec = std::move(Spec);
	Parms.ParamType = ParamType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Spec = std::move(Parms.Spec);

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam.AddParam_GbxDef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGbxStatusEffectPushSpec&        Spec                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGbxStatusEffectSignatureParam>ParamType                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Value                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxStatusEffectPushSpec         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxStatusEffectPushSpec UGbxStatusEffectSignatureParam::AddParam_GbxDef(struct FGbxStatusEffectPushSpec& Spec, TSubclassOf<class UGbxStatusEffectSignatureParam> ParamType, FGbxDefPtrProperty_ Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam", "AddParam_GbxDef");

	Params::GbxStatusEffectSignatureParam_AddParam_GbxDef Parms{};

	Parms.Spec = std::move(Spec);
	Parms.ParamType = ParamType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Spec = std::move(Parms.Spec);

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam_DmgSourceDef.GetDmgSourceDef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGbxDefPtrProperty_ UGbxStatusEffectSignatureParam_DmgSourceDef::GetDmgSourceDef(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_DmgSourceDef", "GetDmgSourceDef");

	Params::GbxStatusEffectSignatureParam_DmgSourceDef_GetDmgSourceDef Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacter.ClientOxygenDepleted
// (Net, NetReliable, Native, Event, Public, NetClient)

void AGbxCharacter::ClientOxygenDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "ClientOxygenDepleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.NetMulticast_PlayJumped
// (Net, Native, Event, NetMulticast, Public)

void AGbxCharacter::NetMulticast_PlayJumped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "NetMulticast_PlayJumped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.NetMulticast_PlayLanded
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ImpactSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLandFromJump                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LandingDefOverrideName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxCharacter::NetMulticast_PlayLanded(const struct FHitResult& Hit, float ImpactSpeed, bool bLandFromJump, class FName LandingDefOverrideName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "NetMulticast_PlayLanded");

	Params::GbxCharacter_NetMulticast_PlayLanded Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ImpactSpeed = ImpactSpeed;
	Parms.bLandFromJump = bLandFromJump;
	Parms.LandingDefOverrideName = LandingDefOverrideName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_AppearanceNetChannels
// (Final, Native, Public)

void AGbxCharacter::OnRep_AppearanceNetChannels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_AppearanceNetChannels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_ControlRotation
// (Final, Native, Public)

void AGbxCharacter::OnRep_ControlRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_ControlRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_FactsConduit
// (Final, Native, Protected)

void AGbxCharacter::OnRep_FactsConduit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_FactsConduit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_GbxActorPartOwnerState
// (Final, Native, Public)

void AGbxCharacter::OnRep_GbxActorPartOwnerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_GbxActorPartOwnerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_GbxDialogSpeaker
// (Final, Native, Public)

void AGbxCharacter::OnRep_GbxDialogSpeaker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_GbxDialogSpeaker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_GestaltMeshParts
// (Final, Native, Public)

void AGbxCharacter::OnRep_GestaltMeshParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_GestaltMeshParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_NetAttachableBodies
// (Final, Native, Protected)

void AGbxCharacter::OnRep_NetAttachableBodies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_NetAttachableBodies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_ReplicateForwardDynamicsUpdate
// (Final, Native, Private)

void AGbxCharacter::OnRep_ReplicateForwardDynamicsUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_ReplicateForwardDynamicsUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_RotationState
// (Final, Native, Public)

void AGbxCharacter::OnRep_RotationState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_RotationState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.OnRep_VisibilityPhaseState
// (Final, Native, Public)

void AGbxCharacter::OnRep_VisibilityPhaseState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "OnRep_VisibilityPhaseState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.SetTerritory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGbxTerritoryComponent*           NewTerritory                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxCharacter::SetTerritory(class UGbxTerritoryComponent* NewTerritory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "SetTerritory");

	Params::GbxCharacter_SetTerritory Parms{};

	Parms.NewTerritory = NewTerritory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.SetTerritoryFromProvider
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGbxTerritoryProvider>TerritoryProvider                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxCharacter::SetTerritoryFromProvider(TScriptInterface<class IGbxTerritoryProvider> TerritoryProvider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "SetTerritoryFromProvider");

	Params::GbxCharacter_SetTerritoryFromProvider Parms{};

	Parms.TerritoryProvider = TerritoryProvider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.SetWantsToSlide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewWantsToSlide                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxCharacter::SetWantsToSlide(bool bNewWantsToSlide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "SetWantsToSlide");

	Params::GbxCharacter_SetWantsToSlide Parms{};

	Parms.bNewWantsToSlide = bNewWantsToSlide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacter.CanRagdollRecover
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxCharacter::CanRagdollRecover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "CanRagdollRecover");

	Params::GbxCharacter_CanRagdollRecover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacter.GetTerritory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGbxTerritoryComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxTerritoryComponent* AGbxCharacter::GetTerritory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "GetTerritory");

	Params::GbxCharacter_GetTerritory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacter.IsCharacterSliding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxCharacter::IsCharacterSliding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "IsCharacterSliding");

	Params::GbxCharacter_IsCharacterSliding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacter.IsRagdolling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxCharacter::IsRagdolling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "IsRagdolling");

	Params::GbxCharacter_IsRagdolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacter.IsRagdollRecovering
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxCharacter::IsRagdollRecovering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "IsRagdollRecovering");

	Params::GbxCharacter_IsRagdollRecovering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacter.SupportsLiveRagdoll
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxCharacter::SupportsLiveRagdoll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacter", "SupportsLiveRagdoll");

	Params::GbxCharacter_SupportsLiveRagdoll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameAnimInstance.GetAnimationFromTag
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              InKey                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* UGbxGameAnimInstance::GetAnimationFromTag(const struct FGameplayTag& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameAnimInstance", "GetAnimationFromTag");

	Params::GbxGameAnimInstance_GetAnimationFromTag Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameAnimInstance.NamedParametersChanged
// (Native, Event, Protected, BlueprintEvent)

void UGbxGameAnimInstance::NamedParametersChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameAnimInstance", "NamedParametersChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameAnimInstance.NamedParametersIngest
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TMap<class FName, float>&         IngestParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxGameAnimInstance::NamedParametersIngest(const TMap<class FName, float>& IngestParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameAnimInstance", "NamedParametersIngest");

	Params::GbxGameAnimInstance_NamedParametersIngest Parms{};

	Parms.IngestParams = std::move(IngestParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillActionExecHandler.K2_ActionEnded
// (Event, Protected, BlueprintEvent)

void UGbxSkillActionExecHandler::K2_ActionEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_ActionEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxSkillActionExecHandler.K2_ActionStarted
// (Event, Protected, BlueprintEvent)

void UGbxSkillActionExecHandler::K2_ActionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_ActionStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxSkillActionExecHandler.K2_BranchOnActionState
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EGbxSkillActionHandlerState             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExecHandler::K2_BranchOnActionState(EGbxSkillActionHandlerState ActionState, ESkillStateScriptExec* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_BranchOnActionState");

	Params::GbxSkillActionExecHandler_K2_BranchOnActionState Parms{};

	Parms.ActionState = ActionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillActionExecHandler.K2_Prepare
// (Event, Protected, BlueprintEvent)

void UGbxSkillActionExecHandler::K2_Prepare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_Prepare");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxSkillActionExecHandler.K2_Reset
// (Event, Protected, BlueprintEvent)

void UGbxSkillActionExecHandler::K2_Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_Reset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxSkillActionExecHandler.K2_SkillConditionBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     ConditionDef                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExecHandler::K2_SkillConditionBranch(FGbxDefPtrProperty_ ConditionDef, ESkillStateScriptExec* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_SkillConditionBranch");

	Params::GbxSkillActionExecHandler_K2_SkillConditionBranch Parms{};

	Parms.ConditionDef = ConditionDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillActionExecHandler.K2_SkillStateBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     StateDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExecHandler::K2_SkillStateBranch(FGbxDefPtrProperty_ StateDef, ESkillStateScriptExec* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_SkillStateBranch");

	Params::GbxSkillActionExecHandler_K2_SkillStateBranch Parms{};

	Parms.StateDef = StateDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillActionExecHandler.Publish
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EGbxSkillActionHandlerResult            Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExecHandler::Publish(EGbxSkillActionHandlerResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "Publish");

	Params::GbxSkillActionExecHandler_Publish Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillActionExecHandler.SetTargetActionItem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             InActionItemName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExecHandler::SetTargetActionItem(class FName InActionItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "SetTargetActionItem");

	Params::GbxSkillActionExecHandler_SetTargetActionItem Parms{};

	Parms.InActionItemName = InActionItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillActionExecHandler.IsSkillConditionEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGbxDefPtrProperty_                     ConditionDef                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillActionExecHandler::IsSkillConditionEnabled(FGbxDefPtrProperty_ ConditionDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "IsSkillConditionEnabled");

	Params::GbxSkillActionExecHandler_IsSkillConditionEnabled Parms{};

	Parms.ConditionDef = ConditionDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillActionExecHandler.IsSkillStateEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGbxDefPtrProperty_                     StateDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillActionExecHandler::IsSkillStateEnabled(FGbxDefPtrProperty_ StateDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "IsSkillStateEnabled");

	Params::GbxSkillActionExecHandler_IsSkillStateEnabled Parms{};

	Parms.StateDef = StateDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillActionExecHandler.K2_CanExecute
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UGbxSkill*                        Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillActionExecHandler::K2_CanExecute(class UGbxSkill* Context, class AActor* target) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExecHandler", "K2_CanExecute");

	Params::GbxSkillActionExecHandler_K2_CanExecute Parms{};

	Parms.Context = Context;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterFunctionLibrary.ChangeNavType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxNavCharacterType                    NavType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterFunctionLibrary::ChangeNavType(class AActor* Actor, EGbxNavCharacterType NavType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCharacterFunctionLibrary", "ChangeNavType");

	Params::GbxCharacterFunctionLibrary_ChangeNavType Parms{};

	Parms.Actor = Actor;
	Parms.NavType = NavType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterFunctionLibrary.GetCharacterJumpedCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxCharacterFunctionLibrary::GetCharacterJumpedCount(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCharacterFunctionLibrary", "GetCharacterJumpedCount");

	Params::GbxCharacterFunctionLibrary_GetCharacterJumpedCount Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterFunctionLibrary.IsCharacterFalling
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterFunctionLibrary::IsCharacterFalling(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCharacterFunctionLibrary", "IsCharacterFalling");

	Params::GbxCharacterFunctionLibrary_IsCharacterFalling Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterFunctionLibrary.IsCharacterJumping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterFunctionLibrary::IsCharacterJumping(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCharacterFunctionLibrary", "IsCharacterJumping");

	Params::GbxCharacterFunctionLibrary_IsCharacterJumping Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementBlueprintLibrary.SetMovementLocked
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    reason                                                 (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementBlueprintLibrary::SetMovementLocked(class AActor* Character, bool bLocked, const class FString& reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCharacterMovementBlueprintLibrary", "SetMovementLocked");

	Params::GbxCharacterMovementBlueprintLibrary_SetMovementLocked Parms{};

	Parms.Character = Character;
	Parms.bLocked = bLocked;
	Parms.reason = std::move(reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxFlyToActorFunctionLibrary.EndActorFlight
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           FlightActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxFlyToActorFunctionLibrary::EndActorFlight(class AActor* FlightActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxFlyToActorFunctionLibrary", "EndActorFlight");

	Params::GbxFlyToActorFunctionLibrary_EndActorFlight Parms{};

	Parms.FlightActor = FlightActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxFlyToActorFunctionLibrary.FlyActorToActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     FlightConfig                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           FlightActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxFlyToActorFunctionLibrary::FlyActorToActor(FGbxDefPtrProperty_ FlightConfig, class AActor* FlightActor, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxFlyToActorFunctionLibrary", "FlyActorToActor");

	Params::GbxFlyToActorFunctionLibrary_FlyActorToActor Parms{};

	Parms.FlightConfig = FlightConfig;
	Parms.FlightActor = FlightActor;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.ClientAdjustControlledMovePosition
// (Final, Net, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FControlledMoveNetCorrection&ServerCMData                                           (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   NewLoc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewVel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              NewBase                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewBaseBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::ClientAdjustControlledMovePosition(float Timestamp, const struct FControlledMoveNetCorrection& ServerCMData, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "ClientAdjustControlledMovePosition");

	Params::GbxCharacterMovementComponent_ClientAdjustControlledMovePosition Parms{};

	Parms.Timestamp = Timestamp;
	Parms.ServerCMData = std::move(ServerCMData);
	Parms.NewLoc = std::move(NewLoc);
	Parms.NewVel = std::move(NewVel);
	Parms.NewBase = NewBase;
	Parms.NewBaseBoneName = NewBaseBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.Net_ResetSwimmingState
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)

void UGbxCharacterMovementComponent::Net_ResetSwimmingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "Net_ResetSwimmingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnCapsuleBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::OnCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnCapsuleBeginOverlap");

	Params::GbxCharacterMovementComponent_OnCapsuleBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnCapsuleEndOverlap
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::OnCapsuleEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnCapsuleEndOverlap");

	Params::GbxCharacterMovementComponent_OnCapsuleEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnRep_bRepInDelayedFall
// (Final, Native, Protected)

void UGbxCharacterMovementComponent::OnRep_bRepInDelayedFall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnRep_bRepInDelayedFall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnRep_ControlledMove
// (Final, Native, Protected)

void UGbxCharacterMovementComponent::OnRep_ControlledMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnRep_ControlledMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnRep_CurrentJump
// (Final, Native, Protected)

void UGbxCharacterMovementComponent::OnRep_CurrentJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnRep_CurrentJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnRep_SwimmingState
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FReplicatedSwimmingState&  PreviousState                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::OnRep_SwimmingState(const struct FReplicatedSwimmingState& PreviousState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnRep_SwimmingState");

	Params::GbxCharacterMovementComponent_OnRep_SwimmingState Parms{};

	Parms.PreviousState = std::move(PreviousState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnRep_TurnState
// (Final, Native, Private)

void UGbxCharacterMovementComponent::OnRep_TurnState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnRep_TurnState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.OnSlidingImpactParticleSystemFinished
// (Final, Native, Public)
// Parameters:
// class UFXSystemComponent*               PSC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::OnSlidingImpactParticleSystemFinished(class UFXSystemComponent* PSC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "OnSlidingImpactParticleSystemFinished");

	Params::GbxCharacterMovementComponent_OnSlidingImpactParticleSystemFinished Parms{};

	Parms.PSC = PSC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.PopJumpGoalCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::PopJumpGoalCollection(class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "PopJumpGoalCollection");

	Params::GbxCharacterMovementComponent_PopJumpGoalCollection Parms{};

	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.PushJumpGoalCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Collection                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::PushJumpGoalCollection(class FName reason, FGbxDefPtrProperty_ Collection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "PushJumpGoalCollection");

	Params::GbxCharacterMovementComponent_PushJumpGoalCollection Parms{};

	Parms.reason = reason;
	Parms.Collection = Collection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.ServerAttemptMantle
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// const struct FMantleAttemptInfo&        ClientData                                             (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::ServerAttemptMantle(const struct FMantleAttemptInfo& ClientData, float Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "ServerAttemptMantle");

	Params::GbxCharacterMovementComponent_ServerAttemptMantle Parms{};

	Parms.ClientData = std::move(ClientData);
	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.ServerDebugGrantMovementType
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EGrantedMovementType                    type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGranted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::ServerDebugGrantMovementType(EGrantedMovementType type, bool bGranted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "ServerDebugGrantMovementType");

	Params::GbxCharacterMovementComponent_ServerDebugGrantMovementType Parms{};

	Parms.type = type;
	Parms.bGranted = bGranted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.ServerStartAutonomousControlledMove
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FControlledMoveServerStartData&ServerStartData                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::ServerStartAutonomousControlledMove(const struct FControlledMoveServerStartData& ServerStartData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "ServerStartAutonomousControlledMove");

	Params::GbxCharacterMovementComponent_ServerStartAutonomousControlledMove Parms{};

	Parms.ServerStartData = std::move(ServerStartData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.ServerStartMoveTo
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FCharacterMoveToCommand&   MoveToCommand                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::ServerStartMoveTo(const struct FCharacterMoveToCommand& MoveToCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "ServerStartMoveTo");

	Params::GbxCharacterMovementComponent_ServerStartMoveTo Parms{};

	Parms.MoveToCommand = std::move(MoveToCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.ServerStopAutonomousControlledMove
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// ECMStopMoveFlags                        StopMoveFlags                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::ServerStopAutonomousControlledMove(ECMStopMoveFlags StopMoveFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "ServerStopAutonomousControlledMove");

	Params::GbxCharacterMovementComponent_ServerStopAutonomousControlledMove Parms{};

	Parms.StopMoveFlags = StopMoveFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.ServerStopMoveTo
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UGbxCharacterMovementComponent::ServerStopMoveTo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "ServerStopMoveTo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.SetCurrentJumpType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              JumpType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::SetCurrentJumpType(const struct FGameplayTag& JumpType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "SetCurrentJumpType");

	Params::GbxCharacterMovementComponent_SetCurrentJumpType Parms{};

	Parms.JumpType = std::move(JumpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.StartAutonomousControlledMove
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UControlledMove*            ControlledMove                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::StartAutonomousControlledMove(const class UControlledMove* ControlledMove, class AActor* target, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "StartAutonomousControlledMove");

	Params::GbxCharacterMovementComponent_StartAutonomousControlledMove Parms{};

	Parms.ControlledMove = ControlledMove;
	Parms.target = target;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.StartControlledMove
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UControlledMove*            ControlledMove                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchAngleOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::StartControlledMove(const class UControlledMove* ControlledMove, class AActor* instigator, float SpeedOverride, float DurationOverride, float LaunchAngleOverride, class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "StartControlledMove");

	Params::GbxCharacterMovementComponent_StartControlledMove Parms{};

	Parms.ControlledMove = ControlledMove;
	Parms.instigator = instigator;
	Parms.SpeedOverride = SpeedOverride;
	Parms.DurationOverride = DurationOverride;
	Parms.LaunchAngleOverride = LaunchAngleOverride;
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.StopAutonomousControlledMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   StopMoveFlags                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::StopAutonomousControlledMove(int32 StopMoveFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "StopAutonomousControlledMove");

	Params::GbxCharacterMovementComponent_StopAutonomousControlledMove Parms{};

	Parms.StopMoveFlags = StopMoveFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.StopControlledMove
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UControlledMove*            ControlledMove                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StopMoveFlags                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCharacterMovementComponent::StopControlledMove(const class UControlledMove* ControlledMove, int32 StopMoveFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "StopControlledMove");

	Params::GbxCharacterMovementComponent_StopControlledMove Parms{};

	Parms.ControlledMove = ControlledMove;
	Parms.StopMoveFlags = StopMoveFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCharacterMovementComponent.CanStartMantle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::CanStartMantle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "CanStartMantle");

	Params::GbxCharacterMovementComponent_CanStartMantle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.CanStartPassiveMantle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::CanStartPassiveMantle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "CanStartPassiveMantle");

	Params::GbxCharacterMovementComponent_CanStartPassiveMantle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.GetCurrentJumpType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag UGbxCharacterMovementComponent::GetCurrentJumpType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "GetCurrentJumpType");

	Params::GbxCharacterMovementComponent_GetCurrentJumpType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.GetJumpGoalForJumpType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              JumpType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGbxDefPtrProperty_ UGbxCharacterMovementComponent::GetJumpGoalForJumpType(const struct FGameplayTag& JumpType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "GetJumpGoalForJumpType");

	Params::GbxCharacterMovementComponent_GetJumpGoalForJumpType Parms{};

	Parms.JumpType = std::move(JumpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.HasJumpGoalCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::HasJumpGoalCollection(class FName reason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "HasJumpGoalCollection");

	Params::GbxCharacterMovementComponent_HasJumpGoalCollection Parms{};

	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.HasJumpGoalForJumpType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              JumpType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::HasJumpGoalForJumpType(const struct FGameplayTag& JumpType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "HasJumpGoalForJumpType");

	Params::GbxCharacterMovementComponent_HasJumpGoalForJumpType Parms{};

	Parms.JumpType = std::move(JumpType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsCameraUnderwater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsCameraUnderwater() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsCameraUnderwater");

	Params::GbxCharacterMovementComponent_IsCameraUnderwater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsGbxSurfaceSwimming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsGbxSurfaceSwimming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsGbxSurfaceSwimming");

	Params::GbxCharacterMovementComponent_IsGbxSurfaceSwimming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsGbxSwimming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsGbxSwimming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsGbxSwimming");

	Params::GbxCharacterMovementComponent_IsGbxSwimming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsGbxSwimmingJumpAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsGbxSwimmingJumpAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsGbxSwimmingJumpAllowed");

	Params::GbxCharacterMovementComponent_IsGbxSwimmingJumpAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsGbxSwimmingUnderwater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bAllowIncidental                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsGbxSwimmingUnderwater(bool bAllowIncidental) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsGbxSwimmingUnderwater");

	Params::GbxCharacterMovementComponent_IsGbxSwimmingUnderwater Parms{};

	Parms.bAllowIncidental = bAllowIncidental;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsMantling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsMantling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsMantling");

	Params::GbxCharacterMovementComponent_IsMantling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsMantlingAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsMantlingAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsMantlingAllowed");

	Params::GbxCharacterMovementComponent_IsMantlingAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsMovementTypeGranted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGrantedMovementType_Script             type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsMovementTypeGranted(EGrantedMovementType_Script type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsMovementTypeGranted");

	Params::GbxCharacterMovementComponent_IsMovementTypeGranted Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsMovingOnLadder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsMovingOnLadder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsMovingOnLadder");

	Params::GbxCharacterMovementComponent_IsMovingOnLadder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsPerformingControlledMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsPerformingControlledMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsPerformingControlledMove");

	Params::GbxCharacterMovementComponent_IsPerformingControlledMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsPerformingSpecificControlledMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UControlledMove*            ControlledMove                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsPerformingSpecificControlledMove(const class UControlledMove* ControlledMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsPerformingSpecificControlledMove");

	Params::GbxCharacterMovementComponent_IsPerformingSpecificControlledMove Parms{};

	Parms.ControlledMove = ControlledMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterMovementComponent.IsWading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxCharacterMovementComponent::IsWading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterMovementComponent", "IsWading");

	Params::GbxCharacterMovementComponent_IsWading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCharacterPushComponent.OnCapsuleBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxCharacterPushComponent::OnCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCharacterPushComponent", "OnCapsuleBeginOverlap");

	Params::GbxCharacterPushComponent_OnCapsuleBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewardsManager.Client_GivenPackage
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FGbxRewardPackage&         Package                                                (Parm, NativeAccessSpecifierPublic)

void UGbxRewardsManager::Client_GivenPackage(const struct FGbxRewardPackage& Package)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxRewardsManager", "Client_GivenPackage");

	Params::GbxRewardsManager_Client_GivenPackage Parms{};

	Parms.Package = std::move(Package);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewardsManager.Client_OpenedPackage
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FGbxRewardPackage&         Package                                                (Parm, NativeAccessSpecifierPublic)

void UGbxRewardsManager::Client_OpenedPackage(const struct FGbxRewardPackage& Package)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxRewardsManager", "Client_OpenedPackage");

	Params::GbxRewardsManager_Client_OpenedPackage Parms{};

	Parms.Package = std::move(Package);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewardsManager.Client_OpenedPackages
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const TArray<struct FGbxRewardPackage>& OpenedPackages                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxRewardsManager::Client_OpenedPackages(const TArray<struct FGbxRewardPackage>& OpenedPackages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxRewardsManager", "Client_OpenedPackages");

	Params::GbxRewardsManager_Client_OpenedPackages Parms{};

	Parms.OpenedPackages = std::move(OpenedPackages);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewardsManager.Server_DeletePackage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   PackageIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRewardsManager::Server_DeletePackage(int32 PackageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxRewardsManager", "Server_DeletePackage");

	Params::GbxRewardsManager_Server_DeletePackage Parms{};

	Parms.PackageIndex = PackageIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewardsManager.Server_OpenAllPackages
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UGbxRewardsManager::Server_OpenAllPackages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxRewardsManager", "Server_OpenAllPackages");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewardsManager.Server_OpenPackage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   PackageIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRewardsManager::Server_OpenPackage(int32 PackageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxRewardsManager", "Server_OpenPackage");

	Params::GbxRewardsManager_Server_OpenPackage Parms{};

	Parms.PackageIndex = PackageIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.ClearGlobalCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::ClearGlobalCinematicMode(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "ClearGlobalCinematicMode");

	Params::GbxCinematicFunctionLibrary_ClearGlobalCinematicMode Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.ClearPlayerCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::ClearPlayerCinematicMode(class AActor* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "ClearPlayerCinematicMode");

	Params::GbxCinematicFunctionLibrary_ClearPlayerCinematicMode Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PopGlobalCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CinematicMode                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PopGlobalCinematicMode(class UObject* WorldContext, FGameDataHandleProperty_ CinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PopGlobalCinematicMode");

	Params::GbxCinematicFunctionLibrary_PopGlobalCinematicMode Parms{};

	Parms.WorldContext = WorldContext;
	Parms.CinematicMode = CinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PopGlobalCinematicModeWithReason
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PopGlobalCinematicModeWithReason(class UObject* WorldContext, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PopGlobalCinematicModeWithReason");

	Params::GbxCinematicFunctionLibrary_PopGlobalCinematicModeWithReason Parms{};

	Parms.WorldContext = WorldContext;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PopPlayerCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CinematicMode                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PopPlayerCinematicMode(class AActor* player, FGameDataHandleProperty_ CinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PopPlayerCinematicMode");

	Params::GbxCinematicFunctionLibrary_PopPlayerCinematicMode Parms{};

	Parms.player = player;
	Parms.CinematicMode = CinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PopPlayerCinematicModeWithReason
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PopPlayerCinematicModeWithReason(class AActor* player, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PopPlayerCinematicModeWithReason");

	Params::GbxCinematicFunctionLibrary_PopPlayerCinematicModeWithReason Parms{};

	Parms.player = player;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PushGlobalCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CinematicMode                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PushGlobalCinematicMode(class UObject* WorldContext, FGameDataHandleProperty_ CinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PushGlobalCinematicMode");

	Params::GbxCinematicFunctionLibrary_PushGlobalCinematicMode Parms{};

	Parms.WorldContext = WorldContext;
	Parms.CinematicMode = CinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PushGlobalCinematicModeWithReason
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CinematicMode                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PushGlobalCinematicModeWithReason(class UObject* WorldContext, FGameDataHandleProperty_ CinematicMode, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PushGlobalCinematicModeWithReason");

	Params::GbxCinematicFunctionLibrary_PushGlobalCinematicModeWithReason Parms{};

	Parms.WorldContext = WorldContext;
	Parms.CinematicMode = CinematicMode;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PushPlayerCinematicMode
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CinematicMode                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PushPlayerCinematicMode(class AActor* player, FGameDataHandleProperty_ CinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PushPlayerCinematicMode");

	Params::GbxCinematicFunctionLibrary_PushPlayerCinematicMode Parms{};

	Parms.player = player;
	Parms.CinematicMode = CinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCinematicFunctionLibrary.PushPlayerCinematicModeWithReason
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CinematicMode                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCinematicFunctionLibrary::PushPlayerCinematicModeWithReason(class AActor* player, FGameDataHandleProperty_ CinematicMode, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCinematicFunctionLibrary", "PushPlayerCinematicModeWithReason");

	Params::GbxCinematicFunctionLibrary_PushPlayerCinematicModeWithReason Parms{};

	Parms.player = player;
	Parms.CinematicMode = CinematicMode;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxConsoleCommands.PopulateAutoCompleteEntries
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<struct FAutoCompleteCommand>*    Entries                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxConsoleCommands::PopulateAutoCompleteEntries(TArray<struct FAutoCompleteCommand>* Entries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxConsoleCommands", "PopulateAutoCompleteEntries");

	Params::GbxConsoleCommands_PopulateAutoCompleteEntries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Entries != nullptr)
		*Entries = std::move(Parms.Entries);
}


// Function GbxGame.GbxStatusEffectSignatureParam_DmgSource.GetDmgSource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxStatusEffectSignatureParam_DmgSource::GetDmgSource(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_DmgSource", "GetDmgSource");

	Params::GbxStatusEffectSignatureParam_DmgSource_GetDmgSource Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxCurrencyFunctionLibrary.GiveCurrency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     currency                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxCurrencyFunctionLibrary::GiveCurrency(class UObject* OwnerContext, FGbxDefPtrProperty_ currency, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxCurrencyFunctionLibrary", "GiveCurrency");

	Params::GbxCurrencyFunctionLibrary_GiveCurrency Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.currency = currency;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxCurrencyManager.OnRep_Currencies
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FGbxCurrency>*            OldCurrencies                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxCurrencyManager::OnRep_Currencies(TArray<struct FGbxCurrency>* OldCurrencies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxCurrencyManager", "OnRep_Currencies");

	Params::GbxCurrencyManager_OnRep_Currencies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldCurrencies != nullptr)
		*OldCurrencies = std::move(Parms.OldCurrencies);
}


// Function GbxGame.GbxDangerZone.BroadcastProjectileHit
// (Final, Native, Private)

void AGbxDangerZone::BroadcastProjectileHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZone", "BroadcastProjectileHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDangerZone.DangerZoneDestroyOnProjectileEvent
// (Final, Native, Private)

void AGbxDangerZone::DangerZoneDestroyOnProjectileEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZone", "DangerZoneDestroyOnProjectileEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDangerZone.GetDistanceFromLinkedProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float AGbxDangerZone::GetDistanceFromLinkedProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZone", "GetDistanceFromLinkedProjectile");

	Params::GbxDangerZone_GetDistanceFromLinkedProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDangerZone.GetDistanceRatioOfProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float AGbxDangerZone::GetDistanceRatioOfProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZone", "GetDistanceRatioOfProjectile");

	Params::GbxDangerZone_GetDistanceRatioOfProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDangerZone.LinkProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class Aprojectile*                      LinkedProjectile                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldDespawnOnProjectileHit                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayDespawnOnHit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetDangerZoneAsHomingTarget                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxDangerZone::LinkProjectile(class Aprojectile* LinkedProjectile, bool bShouldDespawnOnProjectileHit, float DelayDespawnOnHit, bool bSetDangerZoneAsHomingTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZone", "LinkProjectile");

	Params::GbxDangerZone_LinkProjectile Parms{};

	Parms.LinkedProjectile = LinkedProjectile;
	Parms.bShouldDespawnOnProjectileHit = bShouldDespawnOnProjectileHit;
	Parms.DelayDespawnOnHit = DelayDespawnOnHit;
	Parms.bSetDangerZoneAsHomingTarget = bSetDangerZoneAsHomingTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDangerZone.OnRep_FactsConduit
// (Final, Native, Protected)

void AGbxDangerZone::OnRep_FactsConduit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZone", "OnRep_FactsConduit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDangerZoneBlueprintFunctionLibrary.CauseDamageOverlapDangerZoneCracks
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AGbxDangerZoneCracks*             DangerZoneCracks                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            DamageInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageData                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageOverride                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                TargetedHitInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageTypeOverride                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageSourceOverride                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SourceActorOverride                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SourceLocationOverride                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRadiusOverride                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FForceSelection&           ImpactForceOverride                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FImpactEffectSelection&    SourceEffectOverride                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DurationOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamageOnlyPlayers                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDangerZoneBlueprintFunctionLibrary::CauseDamageOverlapDangerZoneCracks(class AGbxDangerZoneCracks* DangerZoneCracks, class AActor* DamageCauser, class APawn* DamageInstigator, FGameDataHandleProperty_ DamageData, float DamageOverride, const struct FHitResult& TargetedHitInfo, FGameDataHandleProperty_ DamageTypeOverride, FGameDataHandleProperty_ DamageSourceOverride, class AActor* SourceActorOverride, const struct FVector& SourceLocationOverride, float DamageRadiusOverride, const struct FForceSelection& ImpactForceOverride, const struct FImpactEffectSelection& SourceEffectOverride, float DurationOverride, bool bDamageOnlyPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDangerZoneBlueprintFunctionLibrary", "CauseDamageOverlapDangerZoneCracks");

	Params::GbxDangerZoneBlueprintFunctionLibrary_CauseDamageOverlapDangerZoneCracks Parms{};

	Parms.DangerZoneCracks = DangerZoneCracks;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageInstigator = DamageInstigator;
	Parms.DamageData = DamageData;
	Parms.DamageOverride = DamageOverride;
	Parms.TargetedHitInfo = std::move(TargetedHitInfo);
	Parms.DamageTypeOverride = DamageTypeOverride;
	Parms.DamageSourceOverride = DamageSourceOverride;
	Parms.SourceActorOverride = SourceActorOverride;
	Parms.SourceLocationOverride = std::move(SourceLocationOverride);
	Parms.DamageRadiusOverride = DamageRadiusOverride;
	Parms.ImpactForceOverride = std::move(ImpactForceOverride);
	Parms.SourceEffectOverride = std::move(SourceEffectOverride);
	Parms.DurationOverride = DurationOverride;
	Parms.bDamageOnlyPlayers = bDamageOnlyPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDangerZoneBlueprintFunctionLibrary.SpawnDangerZoneAtActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                DangerZoneDef                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageDataDef                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDangerZoneSpawnOptions&   SpawnOptions                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AGbxDangerZone**                  Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxDangerZoneBlueprintFunctionLibrary::SpawnDangerZoneAtActor(FGameDataHandleProperty_ DangerZoneDef, FGameDataHandleProperty_ DamageDataDef, class AActor* Context, class AActor* target, const struct FDangerZoneSpawnOptions& SpawnOptions, class AGbxDangerZone** Result, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDangerZoneBlueprintFunctionLibrary", "SpawnDangerZoneAtActor");

	Params::GbxDangerZoneBlueprintFunctionLibrary_SpawnDangerZoneAtActor Parms{};

	Parms.DangerZoneDef = DangerZoneDef;
	Parms.DamageDataDef = DamageDataDef;
	Parms.Context = Context;
	Parms.target = target;
	Parms.SpawnOptions = std::move(SpawnOptions);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxDangerZoneBlueprintFunctionLibrary.SpawnDangerZoneAtTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                DangerZoneDef                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                DamageDataDef                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDangerZoneSpawnOptions&   SpawnOptions                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AGbxDangerZone**                  Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxDangerZoneBlueprintFunctionLibrary::SpawnDangerZoneAtTransform(FGameDataHandleProperty_ DangerZoneDef, FGameDataHandleProperty_ DamageDataDef, class AActor* Context, const struct FTransform& Transform, const struct FDangerZoneSpawnOptions& SpawnOptions, class AGbxDangerZone** Result, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDangerZoneBlueprintFunctionLibrary", "SpawnDangerZoneAtTransform");

	Params::GbxDangerZoneBlueprintFunctionLibrary_SpawnDangerZoneAtTransform Parms{};

	Parms.DangerZoneDef = DangerZoneDef;
	Parms.DamageDataDef = DamageDataDef;
	Parms.Context = Context;
	Parms.Transform = std::move(Transform);
	Parms.SpawnOptions = std::move(SpawnOptions);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.RadiateDamageAreaActor.OnActorBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARadiateDamageAreaActor::OnActorBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiateDamageAreaActor", "OnActorBeginOverlap");

	Params::RadiateDamageAreaActor_OnActorBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.RadiateDamageAreaActor.OnActorEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARadiateDamageAreaActor::OnActorEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadiateDamageAreaActor", "OnActorEndOverlap");

	Params::RadiateDamageAreaActor_OnActorEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDangerZoneCracks.GetCracks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FDangerZoneCrack>   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<struct FDangerZoneCrack> AGbxDangerZoneCracks::GetCracks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZoneCracks", "GetCracks");

	Params::GbxDangerZoneCracks_GetCracks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDangerZoneCracks.OnRep_RandomSeed
// (Final, Native, Private)

void AGbxDangerZoneCracks::OnRep_RandomSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDangerZoneCracks", "OnRep_RandomSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDangerZoneSubsystem.MakeDangerZoneSpawnOptions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bShouldPredictMovement                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeForMovementPrediction                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseRandomHorizontalOffset                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinHorizontalSpawnOffset                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHorizontalSpawnOffset                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldLookForCollisionOnOffset                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OffsetOnCollision                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifespan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDangerZoneSpawnOptions          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDangerZoneSpawnOptions UGbxDangerZoneSubsystem::MakeDangerZoneSpawnOptions(bool bShouldPredictMovement, float TimeForMovementPrediction, bool bUseRandomHorizontalOffset, float MinHorizontalSpawnOffset, float MaxHorizontalSpawnOffset, bool bShouldLookForCollisionOnOffset, float OffsetOnCollision, float lifespan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDangerZoneSubsystem", "MakeDangerZoneSpawnOptions");

	Params::GbxDangerZoneSubsystem_MakeDangerZoneSpawnOptions Parms{};

	Parms.bShouldPredictMovement = bShouldPredictMovement;
	Parms.TimeForMovementPrediction = TimeForMovementPrediction;
	Parms.bUseRandomHorizontalOffset = bUseRandomHorizontalOffset;
	Parms.MinHorizontalSpawnOffset = MinHorizontalSpawnOffset;
	Parms.MaxHorizontalSpawnOffset = MaxHorizontalSpawnOffset;
	Parms.bShouldLookForCollisionOnOffset = bShouldLookForCollisionOnOffset;
	Parms.OffsetOnCollision = OffsetOnCollision;
	Parms.lifespan = lifespan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDecoCharacter.GetInteractionStateOptions
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AGbxDecoCharacter::GetInteractionStateOptions(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDecoCharacter", "GetInteractionStateOptions");

	Params::GbxDecoCharacter_GetInteractionStateOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.GbxDecoCharacter.OnNewState
// (Final, Native, Private)

void AGbxDecoCharacter::OnNewState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDecoCharacter", "OnNewState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDecoCharacter.OnRep_GestaltMeshParts
// (Final, Native, Public)

void AGbxDecoCharacter::OnRep_GestaltMeshParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDecoCharacter", "OnRep_GestaltMeshParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.ApplyNewVSyncValue
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::ApplyNewVSyncValue(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "ApplyNewVSyncValue");

	Params::GbxGameUserSettings_ApplyNewVSyncValue Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.GetActiveGraphicsPreset
// (Final, Native, Public)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxGameUserSettings::GetActiveGraphicsPreset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetActiveGraphicsPreset");

	Params::GbxGameUserSettings_GetActiveGraphicsPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetAvailableGraphicsPresets
// (Final, Native, Public)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxGameUserSettings::GetAvailableGraphicsPresets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetAvailableGraphicsPresets");

	Params::GbxGameUserSettings_GetAvailableGraphicsPresets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetDefaultGraphicsPreset
// (Final, Native, Public)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxGameUserSettings::GetDefaultGraphicsPreset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetDefaultGraphicsPreset");

	Params::GbxGameUserSettings_GetDefaultGraphicsPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetFrameGenerationState
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameUserSettings::GetFrameGenerationState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetFrameGenerationState");

	Params::GbxGameUserSettings_GetFrameGenerationState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetMaxFrameGenerationGeneratedFrames
// (Final, Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxGameUserSettings::GetMaxFrameGenerationGeneratedFrames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetMaxFrameGenerationGeneratedFrames");

	Params::GbxGameUserSettings_GetMaxFrameGenerationGeneratedFrames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetMotionblurAmout
// (Final, Native, Public)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxGameUserSettings::GetMotionblurAmout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetMotionblurAmout");

	Params::GbxGameUserSettings_GetMotionblurAmout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.IsFrameGenerationSupported
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameUserSettings::IsFrameGenerationSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "IsFrameGenerationSupported");

	Params::GbxGameUserSettings_IsFrameGenerationSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.IsNvidiaReflexSupported
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameUserSettings::IsNvidiaReflexSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "IsNvidiaReflexSupported");

	Params::GbxGameUserSettings_IsNvidiaReflexSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.RevertGraphicsSetting
// (Final, Native, Public)
// Parameters:
// class FName                             GraphicsSetting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::RevertGraphicsSetting(class FName GraphicsSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "RevertGraphicsSetting");

	Params::GbxGameUserSettings_RevertGraphicsSetting Parms{};

	Parms.GraphicsSetting = GraphicsSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.RevertGraphicsSettings
// (Final, Native, Public)

void UGbxGameUserSettings::RevertGraphicsSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "RevertGraphicsSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetBaseFOV
// (Final, Native, Public)
// Parameters:
// float                                   InBaseFOV                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetBaseFOV(float InBaseFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetBaseFOV");

	Params::GbxGameUserSettings_SetBaseFOV Parms{};

	Parms.InBaseFOV = InBaseFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetBlackLevel
// (Final, Native, Public)
// Parameters:
// float                                   NewBlackLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetBlackLevel(float NewBlackLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetBlackLevel");

	Params::GbxGameUserSettings_SetBlackLevel Parms{};

	Parms.NewBlackLevel = NewBlackLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetFrameGenerationState
// (Final, Native, Public)
// Parameters:
// bool                                    NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetFrameGenerationState(bool NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetFrameGenerationState");

	Params::GbxGameUserSettings_SetFrameGenerationState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetFramesToGenerate
// (Final, Native, Public)
// Parameters:
// int32                                   FramesToGenerate_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetFramesToGenerate(int32 FramesToGenerate_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetFramesToGenerate");

	Params::GbxGameUserSettings_SetFramesToGenerate Parms{};

	Parms.FramesToGenerate_0 = FramesToGenerate_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetGraphicsPreset
// (Final, Native, Public)
// Parameters:
// class FName                             newPreset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetGraphicsPreset(class FName newPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetGraphicsPreset");

	Params::GbxGameUserSettings_SetGraphicsPreset Parms{};

	Parms.newPreset = newPreset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetGraphicsPresetToDefault
// (Final, Native, Public)

void UGbxGameUserSettings::SetGraphicsPresetToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetGraphicsPresetToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetGraphicsSettingOption
// (Final, Native, Public)
// Parameters:
// class FName                             GraphicsSetting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetGraphicsSettingOption(class FName GraphicsSetting, class FName Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetGraphicsSettingOption");

	Params::GbxGameUserSettings_SetGraphicsSettingOption Parms{};

	Parms.GraphicsSetting = GraphicsSetting;
	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetHDRBrightness
// (Final, Native, Public)
// Parameters:
// float                                   NewHDRBrightness                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetHDRBrightness(float NewHDRBrightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetHDRBrightness");

	Params::GbxGameUserSettings_SetHDRBrightness Parms{};

	Parms.NewHDRBrightness = NewHDRBrightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetLumenHardwareRayTracing
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetLumenHardwareRayTracing(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetLumenHardwareRayTracing");

	Params::GbxGameUserSettings_SetLumenHardwareRayTracing Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetMotionblurAmount
// (Final, Native, Public)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetMotionblurAmount(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetMotionblurAmount");

	Params::GbxGameUserSettings_SetMotionblurAmount Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetNvidiaStreamlineMode
// (Final, Native, Public)
// Parameters:
// EGbxNvidiaReflexMode                    ReflexMode_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetNvidiaStreamlineMode(EGbxNvidiaReflexMode ReflexMode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetNvidiaStreamlineMode");

	Params::GbxGameUserSettings_SetNvidiaStreamlineMode Parms{};

	Parms.ReflexMode_0 = ReflexMode_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.SetShowFPSMode
// (Final, Native, Public)
// Parameters:
// EShowFPSMode                            ShowFPSMode_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::SetShowFPSMode(EShowFPSMode ShowFPSMode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "SetShowFPSMode");

	Params::GbxGameUserSettings_SetShowFPSMode Parms{};

	Parms.ShowFPSMode_0 = ShowFPSMode_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.ToggleHDR
// (Final, Native, Public)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameUserSettings::ToggleHDR(bool Activate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "ToggleHDR");

	Params::GbxGameUserSettings_ToggleHDR Parms{};

	Parms.Activate = Activate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameUserSettings.GetActiveGraphicsSettingOption
// (Final, Native, Public, Const)
// Parameters:
// class FName                             GraphicsSetting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxGameUserSettings::GetActiveGraphicsSettingOption(class FName GraphicsSetting) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetActiveGraphicsSettingOption");

	Params::GbxGameUserSettings_GetActiveGraphicsSettingOption Parms{};

	Parms.GraphicsSetting = GraphicsSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetAvailableGraphicsSettingOptions
// (Final, Native, Public, Const)
// Parameters:
// class FName                             GraphicsSetting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxGameUserSettings::GetAvailableGraphicsSettingOptions(class FName GraphicsSetting) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetAvailableGraphicsSettingOptions");

	Params::GbxGameUserSettings_GetAvailableGraphicsSettingOptions Parms{};

	Parms.GraphicsSetting = GraphicsSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetAvailableGraphicsSettings
// (Final, Native, Public, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxGameUserSettings::GetAvailableGraphicsSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetAvailableGraphicsSettings");

	Params::GbxGameUserSettings_GetAvailableGraphicsSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetBaseFOV
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxGameUserSettings::GetBaseFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetBaseFOV");

	Params::GbxGameUserSettings_GetBaseFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetFramesToGenerate
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxGameUserSettings::GetFramesToGenerate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetFramesToGenerate");

	Params::GbxGameUserSettings_GetFramesToGenerate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetHDRBrightness
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxGameUserSettings::GetHDRBrightness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetHDRBrightness");

	Params::GbxGameUserSettings_GetHDRBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetNvidiaReflexMode
// (Final, Native, Public, Const)
// Parameters:
// EGbxNvidiaReflexMode                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGbxNvidiaReflexMode UGbxGameUserSettings::GetNvidiaReflexMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetNvidiaReflexMode");

	Params::GbxGameUserSettings_GetNvidiaReflexMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.GetShowFPSMode
// (Final, Native, Public, Const)
// Parameters:
// EShowFPSMode                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EShowFPSMode UGbxGameUserSettings::GetShowFPSMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "GetShowFPSMode");

	Params::GbxGameUserSettings_GetShowFPSMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.HasOverridenGraphicsSettings
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameUserSettings::HasOverridenGraphicsSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "HasOverridenGraphicsSettings");

	Params::GbxGameUserSettings_HasOverridenGraphicsSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameUserSettings.IsLumenHardwareRayTracingEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameUserSettings::IsLumenHardwareRayTracingEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameUserSettings", "IsLumenHardwareRayTracingEnabled");

	Params::GbxGameUserSettings_IsLumenHardwareRayTracingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDestructibleComponent.GetDestructibleData
// (Native, Public, BlueprintCallable)
// Parameters:
// const class UGbxDestructibleStaticMeshData*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UGbxDestructibleStaticMeshData* UGbxDestructibleComponent::GetDestructibleData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDestructibleComponent", "GetDestructibleData");

	Params::GbxDestructibleComponent_GetDestructibleData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDestructibleComponent.OnComponentHitInternal
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxDestructibleComponent::OnComponentHitInternal(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDestructibleComponent", "OnComponentHitInternal");

	Params::GbxDestructibleComponent_OnComponentHitInternal Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDestructibleComponent.SetDestructibleData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UGbxDestructibleData*       NewDestructibleData                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDestructibleComponent::SetDestructibleData(const class UGbxDestructibleData* NewDestructibleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDestructibleComponent", "SetDestructibleData");

	Params::GbxDestructibleComponent_SetDestructibleData Parms{};

	Parms.NewDestructibleData = NewDestructibleData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDestructibleScript.OnApplyCollision
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class UGbxDestructibleComponent*        Destructible                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   CollisionSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDestructibleScript::OnApplyCollision(class UGbxDestructibleComponent* Destructible, const struct FHitResult& HitResult, float CollisionSpeed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDestructibleScript", "OnApplyCollision");

	Params::GbxDestructibleScript_OnApplyCollision Parms{};

	Parms.Destructible = Destructible;
	Parms.HitResult = std::move(HitResult);
	Parms.CollisionSpeed = CollisionSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxDestructibleScript.OnApplyHit
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class UGbxDestructibleComponent*        Destructible                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDestructionHitProperties& Properties                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxDestructibleScript::OnApplyHit(class UGbxDestructibleComponent* Destructible, const struct FDestructionHitProperties& Properties) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDestructibleScript", "OnApplyHit");

	Params::GbxDestructibleScript_OnApplyHit Parms{};

	Parms.Destructible = Destructible;
	Parms.Properties = std::move(Properties);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxDialogBlueprintLibrary.ActivateScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     script                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDialogBlueprintLibrary::ActivateScript(class UObject* WorldContextObject, FGbxDefPtrProperty_ script)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "ActivateScript");

	Params::GbxDialogBlueprintLibrary_ActivateScript Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.script = script;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogBlueprintLibrary.DectivateScript
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     script                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDialogBlueprintLibrary::DectivateScript(class UObject* WorldContextObject, FGbxDefPtrProperty_ script)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "DectivateScript");

	Params::GbxDialogBlueprintLibrary_DectivateScript Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.script = script;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogBlueprintLibrary.EnableDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDialogBlueprintLibrary::EnableDialog(bool bEnable, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "EnableDialog");

	Params::GbxDialogBlueprintLibrary_EnableDialog Parms{};

	Parms.bEnable = bEnable;
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogBlueprintLibrary.IsDialogThreadPlaying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ThreadID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxDialogBlueprintLibrary::IsDialogThreadPlaying(class UObject* WorldContextObject, int32 ThreadID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "IsDialogThreadPlaying");

	Params::GbxDialogBlueprintLibrary_IsDialogThreadPlaying Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ThreadID = ThreadID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.NewDialogContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InstigatorActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogContext                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDialogContext UGbxDialogBlueprintLibrary::NewDialogContext(class AActor* InstigatorActor, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "NewDialogContext");

	Params::GbxDialogBlueprintLibrary_NewDialogContext Parms{};

	Parms.InstigatorActor = InstigatorActor;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.SetDialogNametag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     NameTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          NametagOwner                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDialogBlueprintLibrary::SetDialogNametag(FGbxDefPtrProperty_ NameTag, class UObject* NametagOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "SetDialogNametag");

	Params::GbxDialogBlueprintLibrary_SetDialogNametag Parms{};

	Parms.NameTag = NameTag;
	Parms.NametagOwner = NametagOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogBlueprintLibrary.ToDialogParameterFromBoolean
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogParameterValue            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDialogParameterValue UGbxDialogBlueprintLibrary::ToDialogParameterFromBoolean(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "ToDialogParameterFromBoolean");

	Params::GbxDialogBlueprintLibrary_ToDialogParameterFromBoolean Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.ToDialogParameterFromDialogEnum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDialogEnumValue&          Value                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogParameterValue            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDialogParameterValue UGbxDialogBlueprintLibrary::ToDialogParameterFromDialogEnum(const struct FDialogEnumValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "ToDialogParameterFromDialogEnum");

	Params::GbxDialogBlueprintLibrary_ToDialogParameterFromDialogEnum Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.ToDialogParameterFromFactAddress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FFactAddress&              Value                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogParameterValue            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDialogParameterValue UGbxDialogBlueprintLibrary::ToDialogParameterFromFactAddress(const struct FFactAddress& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "ToDialogParameterFromFactAddress");

	Params::GbxDialogBlueprintLibrary_ToDialogParameterFromFactAddress Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.ToDialogParameterFromNexusDef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FGbxDefPtrProperty_                     Value                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogParameterValue            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDialogParameterValue UGbxDialogBlueprintLibrary::ToDialogParameterFromNexusDef(FGbxDefPtrProperty_ Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "ToDialogParameterFromNexusDef");

	Params::GbxDialogBlueprintLibrary_ToDialogParameterFromNexusDef Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.ToDialogParameterFromNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogParameterValue            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDialogParameterValue UGbxDialogBlueprintLibrary::ToDialogParameterFromNumber(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "ToDialogParameterFromNumber");

	Params::GbxDialogBlueprintLibrary_ToDialogParameterFromNumber Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.ToDialogParameterFromObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogParameterValue            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDialogParameterValue UGbxDialogBlueprintLibrary::ToDialogParameterFromObject(class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "ToDialogParameterFromObject");

	Params::GbxDialogBlueprintLibrary_ToDialogParameterFromObject Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.TriggerCharacterSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     SoundTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxDialogBlueprintLibrary::TriggerCharacterSound(FGbxDefPtrProperty_ SoundTag, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "TriggerCharacterSound");

	Params::GbxDialogBlueprintLibrary_TriggerCharacterSound Parms{};

	Parms.SoundTag = SoundTag;
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.TriggerDialogEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogContext&                  Context                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDialogConversation&       ContinueConversation                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDialogConversation*             Conversation                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  ThreadID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxDialogBlueprintLibrary::TriggerDialogEvent(class UObject* WorldContextObject, FGbxDefPtrProperty_ EventDef, struct FDialogContext& Context, const struct FDialogConversation& ContinueConversation, struct FDialogConversation* Conversation, float StartDelay, int32* ThreadID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "TriggerDialogEvent");

	Params::GbxDialogBlueprintLibrary_TriggerDialogEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventDef = EventDef;
	Parms.Context = std::move(Context);
	Parms.ContinueConversation = std::move(ContinueConversation);
	Parms.StartDelay = StartDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Context = std::move(Parms.Context);

	if (Conversation != nullptr)
		*Conversation = std::move(Parms.Conversation);

	if (ThreadID != nullptr)
		*ThreadID = Parms.ThreadID;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogBlueprintLibrary.TriggerDialogEventEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<FGbxDefPtrProperty_, struct FDialogParameterValue>&ParameterValues                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDialogConversation&       ContinueConversation                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDialogConversation*             Conversation                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FDialogPlayOptions&        PlayOptions                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32*                                  ThreadID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxDialogBlueprintLibrary::TriggerDialogEventEx(class UObject* WorldContextObject, FGbxDefPtrProperty_ EventDef, const TMap<FGbxDefPtrProperty_, struct FDialogParameterValue>& ParameterValues, const struct FDialogConversation& ContinueConversation, struct FDialogConversation* Conversation, const struct FDialogPlayOptions& PlayOptions, int32* ThreadID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDialogBlueprintLibrary", "TriggerDialogEventEx");

	Params::GbxDialogBlueprintLibrary_TriggerDialogEventEx Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventDef = EventDef;
	Parms.ParameterValues = std::move(ParameterValues);
	Parms.ContinueConversation = std::move(ContinueConversation);
	Parms.PlayOptions = std::move(PlayOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Conversation != nullptr)
		*Conversation = std::move(Parms.Conversation);

	if (ThreadID != nullptr)
		*ThreadID = Parms.ThreadID;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDialogComponent.OnRep_DialogProvider
// (Final, Native, Protected)

void UGbxDialogComponent::OnRep_DialogProvider()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogComponent", "OnRep_DialogProvider");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.Usable.BP_OnUsed
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FUseEvent&                 UseEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IUsable::BP_OnUsed(const struct FUseEvent& UseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Usable", "BP_OnUsed");

	Params::Usable_BP_OnUsed Parms{};

	Parms.UseEvent = std::move(UseEvent);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxDialogLiveSpeaker.OnProviderDialogFinished
// (Final, Native, Protected)

void UGbxDialogLiveSpeaker::OnProviderDialogFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogLiveSpeaker", "OnProviderDialogFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogLiveSpeaker.OnRep_AttachedActor
// (Final, Native, Protected)

void UGbxDialogLiveSpeaker::OnRep_AttachedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogLiveSpeaker", "OnRep_AttachedActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogLiveSpeaker.OnRep_DialogProvider
// (Final, Native, Protected)

void UGbxDialogLiveSpeaker::OnRep_DialogProvider()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogLiveSpeaker", "OnRep_DialogProvider");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogProvider.NetMulticast_StartDialog
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FStartDialogParams&        params                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxDialogProvider::NetMulticast_StartDialog(const struct FStartDialogParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogProvider", "NetMulticast_StartDialog");

	Params::GbxDialogProvider_NetMulticast_StartDialog Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogProvider.NetMulticast_StopDialog
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   DialogThreadID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTimeSeconds                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDialogProvider::NetMulticast_StopDialog(int32 DialogThreadID, float FadeTimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogProvider", "NetMulticast_StopDialog");

	Params::GbxDialogProvider_NetMulticast_StopDialog Parms{};

	Parms.DialogThreadID = DialogThreadID;
	Parms.FadeTimeSeconds = FadeTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogProvider.OnRep_InitialDialogInProgress
// (Final, Native, Protected)

void UGbxDialogProvider::OnRep_InitialDialogInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogProvider", "OnRep_InitialDialogInProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogProvider.OnRep_IsRegisteredOnServer
// (Final, Native, Protected)

void UGbxDialogProvider::OnRep_IsRegisteredOnServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogProvider", "OnRep_IsRegisteredOnServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDialogProvider.OnRep_NameTagHandle
// (Final, Native, Protected)

void UGbxDialogProvider::OnRep_NameTagHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDialogProvider", "OnRep_NameTagHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameplayStatics.AreAllPlayersOverlappingActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameplayStatics::AreAllPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "AreAllPlayersOverlappingActor");

	Params::GbxGameplayStatics_AreAllPlayersOverlappingActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.AreAllPlayersOverlappingActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameplayStatics::AreAllPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "AreAllPlayersOverlappingActors");

	Params::GbxGameplayStatics_AreAllPlayersOverlappingActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.AreAnyPlayersOverlappingActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameplayStatics::AreAnyPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "AreAnyPlayersOverlappingActor");

	Params::GbxGameplayStatics_AreAnyPlayersOverlappingActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.AreAnyPlayersOverlappingActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameplayStatics::AreAnyPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "AreAnyPlayersOverlappingActors");

	Params::GbxGameplayStatics_AreAnyPlayersOverlappingActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.BranchOnAreAllPlayersOverlappingActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayersOverlappingActorOutput*         Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::BranchOnAreAllPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor, EPlayersOverlappingActorOutput* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "BranchOnAreAllPlayersOverlappingActor");

	Params::GbxGameplayStatics_BranchOnAreAllPlayersOverlappingActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function GbxGame.GbxGameplayStatics.BranchOnAreAllPlayersOverlappingActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EPlayersOverlappingActorOutput*         Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::BranchOnAreAllPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors, EPlayersOverlappingActorOutput* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "BranchOnAreAllPlayersOverlappingActors");

	Params::GbxGameplayStatics_BranchOnAreAllPlayersOverlappingActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function GbxGame.GbxGameplayStatics.BranchOnAreAnyPlayersOverlappingActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayersOverlappingActorOutput*         Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::BranchOnAreAnyPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor, EPlayersOverlappingActorOutput* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "BranchOnAreAnyPlayersOverlappingActor");

	Params::GbxGameplayStatics_BranchOnAreAnyPlayersOverlappingActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function GbxGame.GbxGameplayStatics.BranchOnAreAnyPlayersOverlappingActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EPlayersOverlappingActorOutput*         Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::BranchOnAreAnyPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors, EPlayersOverlappingActorOutput* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "BranchOnAreAnyPlayersOverlappingActors");

	Params::GbxGameplayStatics_BranchOnAreAnyPlayersOverlappingActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function GbxGame.GbxGameplayStatics.CalculateConeVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Fraction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxGameplayStatics::CalculateConeVector(float Fraction, const struct FVector& Origin, const struct FVector& Direction, float AngleWidth, float AngleHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "CalculateConeVector");

	Params::GbxGameplayStatics_CalculateConeVector Parms{};

	Parms.Fraction = Fraction;
	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.AngleWidth = AngleWidth;
	Parms.AngleHeight = AngleHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.GeneratePointsOnCone
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SampleCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpreadAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotateAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OriginOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTransform> UGbxGameplayStatics::GeneratePointsOnCone(const struct FVector& Origin, const struct FVector& Direction, int32 SampleCount, float SpreadAngle, float RotateAngle, float OriginOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "GeneratePointsOnCone");

	Params::GbxGameplayStatics_GeneratePointsOnCone Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.SampleCount = SampleCount;
	Parms.SpreadAngle = SpreadAngle;
	Parms.RotateAngle = RotateAngle;
	Parms.OriginOffset = OriginOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.GeneratePointsOnFan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SampleCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpreadAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotateAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OriginOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTransform> UGbxGameplayStatics::GeneratePointsOnFan(const struct FVector& Origin, const struct FVector& Direction, int32 SampleCount, float SpreadAngle, float RotateAngle, float OriginOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "GeneratePointsOnFan");

	Params::GbxGameplayStatics_GeneratePointsOnFan Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.SampleCount = SampleCount;
	Parms.SpreadAngle = SpreadAngle;
	Parms.RotateAngle = RotateAngle;
	Parms.OriginOffset = OriginOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.GetAssociatedPrimaryCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGbxCharacter* UGbxGameplayStatics::GetAssociatedPrimaryCharacter(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "GetAssociatedPrimaryCharacter");

	Params::GbxGameplayStatics_GetAssociatedPrimaryCharacter Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.GetGameplayDirector
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxGameplayDirector*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGbxGameplayDirector* UGbxGameplayStatics::GetGameplayDirector(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "GetGameplayDirector");

	Params::GbxGameplayStatics_GetGameplayDirector Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.GetViewRelativeSpawnLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      RelativeLocation                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   ViewRelativeOffset                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxGameplayStatics::GetViewRelativeSpawnLocation(class AActor* Source, const struct FGbxRelativeLocation& RelativeLocation, const struct FVector& ViewRelativeOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "GetViewRelativeSpawnLocation");

	Params::GbxGameplayStatics_GetViewRelativeSpawnLocation Parms{};

	Parms.Source = Source;
	Parms.RelativeLocation = std::move(RelativeLocation);
	Parms.ViewRelativeOffset = std::move(ViewRelativeOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.SetCanCharacterStepUpOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECanBeCharacterBase                     CanCharacterStepUpOn                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameplayStatics::SetCanCharacterStepUpOn(class AActor* Actor, ECanBeCharacterBase CanCharacterStepUpOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SetCanCharacterStepUpOn");

	Params::GbxGameplayStatics_SetCanCharacterStepUpOn Parms{};

	Parms.Actor = Actor;
	Parms.CanCharacterStepUpOn = CanCharacterStepUpOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.SpawnEmitterAtActorSocketMulticast
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   EmitterTemplate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivateSystem                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::SpawnEmitterAtActorSocketMulticast(const class UObject* WorldContextObject, class UFXSystemAsset* EmitterTemplate, class AActor* Actor, class FName socket, bool bAutoDestroy, bool bAutoActivateSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SpawnEmitterAtActorSocketMulticast");

	Params::GbxGameplayStatics_SpawnEmitterAtActorSocketMulticast Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EmitterTemplate = EmitterTemplate;
	Parms.Actor = Actor;
	Parms.socket = socket;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.bAutoActivateSystem = bAutoActivateSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameplayStatics.SpawnEmitterAtComponentSocketMulticast
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   EmitterTemplate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivateSystem                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::SpawnEmitterAtComponentSocketMulticast(const class UObject* WorldContextObject, class UFXSystemAsset* EmitterTemplate, class USceneComponent* Component, class FName socket, bool bAutoDestroy, bool bAutoActivateSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SpawnEmitterAtComponentSocketMulticast");

	Params::GbxGameplayStatics_SpawnEmitterAtComponentSocketMulticast Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EmitterTemplate = EmitterTemplate;
	Parms.Component = Component;
	Parms.socket = socket;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.bAutoActivateSystem = bAutoActivateSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameplayStatics.SpawnEmitterAtLocation_Generic
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   EmitterTemplate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&EmitterParameters                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPSCPoolMethod                          PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivateSystem                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectVisibility               Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectReplication              Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UGbxGameplayStatics::SpawnEmitterAtLocation_Generic(const class UObject* WorldContextObject, class UFXSystemAsset* EmitterTemplate, const TArray<struct FGbxParticleParameter>& EmitterParameters, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& scale, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivateSystem, EGameplayEffectVisibility Visibility, EGameplayEffectReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SpawnEmitterAtLocation_Generic");

	Params::GbxGameplayStatics_SpawnEmitterAtLocation_Generic Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EmitterTemplate = EmitterTemplate;
	Parms.EmitterParameters = std::move(EmitterParameters);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.scale = std::move(scale);
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;
	Parms.bAutoActivateSystem = bAutoActivateSystem;
	Parms.Visibility = Visibility;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.SpawnEmitterAtLocation_GenericConst
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   EmitterTemplate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&EmitterParameters                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPSCPoolMethod                          PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivateSystem                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectVisibility               Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectReplication              Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UGbxGameplayStatics::SpawnEmitterAtLocation_GenericConst(const class UObject* WorldContextObject, class UFXSystemAsset* EmitterTemplate, const TArray<struct FGbxParticleParameter>& EmitterParameters, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& scale, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivateSystem, EGameplayEffectVisibility Visibility, EGameplayEffectReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SpawnEmitterAtLocation_GenericConst");

	Params::GbxGameplayStatics_SpawnEmitterAtLocation_GenericConst Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EmitterTemplate = EmitterTemplate;
	Parms.EmitterParameters = std::move(EmitterParameters);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.scale = std::move(scale);
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;
	Parms.bAutoActivateSystem = bAutoActivateSystem;
	Parms.Visibility = Visibility;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayStatics.SpawnEmitterAtLocationMulticast
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   EmitterTemplate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivateSystem                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::SpawnEmitterAtLocationMulticast(const class UObject* WorldContextObject, class UFXSystemAsset* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& scale, bool bAutoDestroy, bool bAutoActivateSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SpawnEmitterAtLocationMulticast");

	Params::GbxGameplayStatics_SpawnEmitterAtLocationMulticast Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EmitterTemplate = EmitterTemplate;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.scale = std::move(scale);
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.bAutoActivateSystem = bAutoActivateSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameplayStatics.SpawnEmitterAttached_Body
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   EmitterTemplate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&EmitterParameters                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           AttachToActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPSCPoolMethod                          PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectBodyVisibility           Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectReplication              Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameplayStatics::SpawnEmitterAttached_Body(class UFXSystemAsset* EmitterTemplate, const TArray<struct FGbxParticleParameter>& EmitterParameters, class AActor* AttachToActor, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& scale, EAttachLocation LocationType, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivate, EGameplayEffectBodyVisibility Visibility, EGameplayEffectReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SpawnEmitterAttached_Body");

	Params::GbxGameplayStatics_SpawnEmitterAttached_Body Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.EmitterParameters = std::move(EmitterParameters);
	Parms.AttachToActor = AttachToActor;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.scale = std::move(scale);
	Parms.LocationType = LocationType;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;
	Parms.bAutoActivate = bAutoActivate;
	Parms.Visibility = Visibility;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameplayStatics.SpawnEmitterAttached_Generic
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   EmitterTemplate                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&EmitterParameters                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPSCPoolMethod                          PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectVisibility               Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectReplication              Replication                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* UGbxGameplayStatics::SpawnEmitterAttached_Generic(class UFXSystemAsset* EmitterTemplate, const TArray<struct FGbxParticleParameter>& EmitterParameters, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& scale, EAttachLocation LocationType, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivate, EGameplayEffectVisibility Visibility, EGameplayEffectReplication Replication)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameplayStatics", "SpawnEmitterAttached_Generic");

	Params::GbxGameplayStatics_SpawnEmitterAttached_Generic Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.EmitterParameters = std::move(EmitterParameters);
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.scale = std::move(scale);
	Parms.LocationType = LocationType;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;
	Parms.bAutoActivate = bAutoActivate;
	Parms.Visibility = Visibility;
	Parms.Replication = Replication;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDiscoveryFunctionLibrary.MakeActorDiscoverable
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     InLocationType                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGbxDiscoveryLocationComponent>InComponentType                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDiscoveryFunctionLibrary::MakeActorDiscoverable(class AActor* InActor, FGbxDefPtrProperty_ InLocationType, TSubclassOf<class UGbxDiscoveryLocationComponent> InComponentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDiscoveryFunctionLibrary", "MakeActorDiscoverable");

	Params::GbxDiscoveryFunctionLibrary_MakeActorDiscoverable Parms{};

	Parms.InActor = InActor;
	Parms.InLocationType = InLocationType;
	Parms.InComponentType = InComponentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDiscoveryFunctionLibrary.MakeLiveLocationDiscoverable
// (Final, RequiredAPI, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InAttachToSocket                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     InLocationType                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDiscoveryFunctionLibrary::MakeLiveLocationDiscoverable(class AActor* InActor, class FName InAttachToSocket, FGbxDefPtrProperty_ InLocationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDiscoveryFunctionLibrary", "MakeLiveLocationDiscoverable");

	Params::GbxDiscoveryFunctionLibrary_MakeLiveLocationDiscoverable Parms{};

	Parms.InActor = InActor;
	Parms.InAttachToSocket = InAttachToSocket;
	Parms.InLocationType = InLocationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDiscoveryFunctionLibrary.RemoveActorDiscoverability
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDiscoveryFunctionLibrary::RemoveActorDiscoverability(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDiscoveryFunctionLibrary", "RemoveActorDiscoverability");

	Params::GbxDiscoveryFunctionLibrary_RemoveActorDiscoverability Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDiscoveryFunctionLibrary.RemoveLiveLocationDiscoverability
// (Final, RequiredAPI, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDiscoveryFunctionLibrary::RemoveLiveLocationDiscoverability(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDiscoveryFunctionLibrary", "RemoveLiveLocationDiscoverability");

	Params::GbxDiscoveryFunctionLibrary_RemoveLiveLocationDiscoverability Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDiscoveryLocationComponent.CreateNewDiscoveryLocationId
// (Final, Native, Protected)

void UGbxDiscoveryLocationComponent::CreateNewDiscoveryLocationId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDiscoveryLocationComponent", "CreateNewDiscoveryLocationId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDiscoveryLocationComponent.OnRep_LocationType
// (Final, Native, Protected)

void UGbxDiscoveryLocationComponent::OnRep_LocationType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDiscoveryLocationComponent", "OnRep_LocationType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGamePhysicsBlueprintLibrary.GrabIt_Crosshair
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                ControllerToUse                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGrabItParams&             params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AGbxCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGbxCharacter* UGbxGamePhysicsBlueprintLibrary::GrabIt_Crosshair(class APlayerController* ControllerToUse, const struct FGrabItParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGamePhysicsBlueprintLibrary", "GrabIt_Crosshair");

	Params::GbxGamePhysicsBlueprintLibrary_GrabIt_Crosshair Parms{};

	Parms.ControllerToUse = ControllerToUse;
	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxLevelSequencePlayer.CreateGbxLevelSequencePlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxLevelSequence*                LevelSequence                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMovieSceneSequencePlaybackSettings&settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CinematicMode_0                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class FName, class AActor*>& GbxBindingOverrides                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AGbxLevelSequenceActor**          OutActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxLevelSequencePlayer*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxLevelSequencePlayer* UGbxLevelSequencePlayer::CreateGbxLevelSequencePlayer(class UObject* WorldContextObject, class UGbxLevelSequence* LevelSequence, const struct FMovieSceneSequencePlaybackSettings& settings, FGameDataHandleProperty_ CinematicMode_0, const TMap<class FName, class AActor*>& GbxBindingOverrides, class AGbxLevelSequenceActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxLevelSequencePlayer", "CreateGbxLevelSequencePlayer");

	Params::GbxLevelSequencePlayer_CreateGbxLevelSequencePlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelSequence = LevelSequence;
	Parms.settings = std::move(settings);
	Parms.CinematicMode_0 = CinematicMode_0;
	Parms.GbxBindingOverrides = std::move(GbxBindingOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxLevelSequencePlayer.Multicast_StartLoadingAssets
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UGbxLevelSequencePlayer::Multicast_StartLoadingAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLevelSequencePlayer", "Multicast_StartLoadingAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.JunkSystemFunctionLibrary.DestroyJunkItem
// (Final, RequiredAPI, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunkId&                   JunkId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunkSystemFunctionLibrary::DestroyJunkItem(class UObject* WorldContextObject, const struct FJunkId& JunkId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunkSystemFunctionLibrary", "DestroyJunkItem");

	Params::JunkSystemFunctionLibrary_DestroyJunkItem Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.JunkId = std::move(JunkId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.JunkSystemFunctionLibrary.DestroyJunkWithinBounds
// (Final, RequiredAPI, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UJunkSystemFunctionLibrary::DestroyJunkWithinBounds(class UObject* WorldContextObject, const struct FBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunkSystemFunctionLibrary", "DestroyJunkWithinBounds");

	Params::JunkSystemFunctionLibrary_DestroyJunkWithinBounds Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.JunkSystemFunctionLibrary.DetachJunkItem
// (Final, RequiredAPI, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunkId&                   JunkId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SpawnPattern                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunkSystemFunctionLibrary::DetachJunkItem(class UObject* WorldContextObject, const struct FJunkId& JunkId, FGbxDefPtrProperty_ SpawnPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunkSystemFunctionLibrary", "DetachJunkItem");

	Params::JunkSystemFunctionLibrary_DetachJunkItem Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.JunkId = std::move(JunkId);
	Parms.SpawnPattern = SpawnPattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.JunkSystemFunctionLibrary.GetJunkAttachedToActor
// (Final, RequiredAPI, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunkId>*                 OutJunkIds                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunkSystemFunctionLibrary::GetJunkAttachedToActor(class AActor* Actor, TArray<struct FJunkId>* OutJunkIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunkSystemFunctionLibrary", "GetJunkAttachedToActor");

	Params::JunkSystemFunctionLibrary_GetJunkAttachedToActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutJunkIds != nullptr)
		*OutJunkIds = std::move(Parms.OutJunkIds);
}


// Function GbxGame.JunkSystemFunctionLibrary.RemoveOnlyPickupableByOwnerRestriction
// (Final, RequiredAPI, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunkId&                   JunkId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunkSystemFunctionLibrary::RemoveOnlyPickupableByOwnerRestriction(class UObject* WorldContextObject, const struct FJunkId& JunkId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunkSystemFunctionLibrary", "RemoveOnlyPickupableByOwnerRestriction");

	Params::JunkSystemFunctionLibrary_RemoveOnlyPickupableByOwnerRestriction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.JunkId = std::move(JunkId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLevelSequenceManager.OnRep_PlaybackRequests
// (Final, Native, Private)

void AGbxLevelSequenceManager::OnRep_PlaybackRequests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLevelSequenceManager", "OnRep_PlaybackRequests");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLevelSequenceManager.OnRep_PreloadRequests
// (Final, Native, Private)

void AGbxLevelSequenceManager::OnRep_PreloadRequests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLevelSequenceManager", "OnRep_PreloadRequests");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLevelSequenceManager.OnRep_StreamingSourceData
// (Final, Native, Private)

void AGbxLevelSequenceManager::OnRep_StreamingSourceData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLevelSequenceManager", "OnRep_StreamingSourceData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDiscoveryDiscoverableActorData.OnDiscoverableActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           InDestroyedActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDiscoveryDiscoverableActorData::OnDiscoverableActorDestroyed(class AActor* InDestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDiscoveryDiscoverableActorData", "OnDiscoverableActorDestroyed");

	Params::GbxDiscoveryDiscoverableActorData_OnDiscoverableActorDestroyed Parms{};

	Parms.InDestroyedActor = InDestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewards_BlueprintFunctions.GiveReward
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     RewardDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRewards_BlueprintFunctions::GiveReward(FGbxDefPtrProperty_ RewardDef, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRewards_BlueprintFunctions", "GiveReward");

	Params::GbxRewards_BlueprintFunctions_GiveReward Parms{};

	Parms.RewardDef = RewardDef;
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewards_BlueprintFunctions.GiveRewardAllPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     RewardDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRewards_BlueprintFunctions::GiveRewardAllPlayers(FGbxDefPtrProperty_ RewardDef, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRewards_BlueprintFunctions", "GiveRewardAllPlayers");

	Params::GbxRewards_BlueprintFunctions_GiveRewardAllPlayers Parms{};

	Parms.RewardDef = RewardDef;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewards_BlueprintFunctions.GiveRewardPackage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     RewardDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRewards_BlueprintFunctions::GiveRewardPackage(FGbxDefPtrProperty_ RewardDef, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRewards_BlueprintFunctions", "GiveRewardPackage");

	Params::GbxRewards_BlueprintFunctions_GiveRewardPackage Parms{};

	Parms.RewardDef = RewardDef;
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewards_BlueprintFunctions.GiveRewardPackageAllPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     RewardDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxRewards_BlueprintFunctions::GiveRewardPackageAllPlayers(FGbxDefPtrProperty_ RewardDef, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRewards_BlueprintFunctions", "GiveRewardPackageAllPlayers");

	Params::GbxRewards_BlueprintFunctions_GiveRewardPackageAllPlayers Parms{};

	Parms.RewardDef = RewardDef;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxRewards_BlueprintFunctions.HasReward
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxRewardRef&             RewardRef                                              (Parm, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxRewards_BlueprintFunctions::HasReward(const struct FGbxRewardRef& RewardRef, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRewards_BlueprintFunctions", "HasReward");

	Params::GbxRewards_BlueprintFunctions_HasReward Parms{};

	Parms.RewardRef = std::move(RewardRef);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxRewards_BlueprintFunctions.MakeGbxRewardRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxRewardRef&             RewardRef                                              (Parm, NativeAccessSpecifierPublic)
// struct FGbxRewardRef                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxRewardRef UGbxRewards_BlueprintFunctions::MakeGbxRewardRef(const struct FGbxRewardRef& RewardRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxRewards_BlueprintFunctions", "MakeGbxRewardRef");

	Params::GbxRewards_BlueprintFunctions_MakeGbxRewardRef Parms{};

	Parms.RewardRef = std::move(RewardRef);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_EightParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_EightParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G, int32 H)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_EightParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_EightParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;
	Parms.H = H;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_FiveParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_FiveParams(int32 A, int32 B, int32 C, int32 D, int32 E)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_FiveParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_FiveParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_FourParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_FourParams(int32 A, int32 B, int32 C, int32 D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_FourParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_FourParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_NineParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   I                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_NineParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G, int32 H, int32 I)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_NineParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_NineParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;
	Parms.H = H;
	Parms.I = I;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_SevenParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_SevenParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_SevenParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_SevenParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_SixParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_SixParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_SixParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_SixParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_TenParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   I                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   J                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_TenParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G, int32 H, int32 I, int32 J)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_TenParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_TenParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;
	Parms.H = H;
	Parms.I = I;
	Parms.J = J;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.AskSkillQuestionInternal_ThreeParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkillQuestionResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSkillQuestionResult UGbxSkillBlueprintPrivate::AskSkillQuestionInternal_ThreeParams(int32 A, int32 B, int32 C)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "AskSkillQuestionInternal_ThreeParams");

	Params::GbxSkillBlueprintPrivate_AskSkillQuestionInternal_ThreeParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.BranchFilteredEvent
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UGbxSkill*                        Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxSkillEventNetFilter                 filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxFilteredEventExec*                  Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::BranchFilteredEvent(class UGbxSkill* Context, EGbxSkillEventNetFilter filter, EGbxFilteredEventExec* Exec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "BranchFilteredEvent");

	Params::GbxSkillBlueprintPrivate_BranchFilteredEvent Parms{};

	Parms.Context = Context;
	Parms.filter = filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_EightParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_EightParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G, int32 H)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_EightParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_EightParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;
	Parms.H = H;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_FiveParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_FiveParams(int32 A, int32 B, int32 C, int32 D, int32 E)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_FiveParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_FiveParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_FourParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_FourParams(int32 A, int32 B, int32 C, int32 D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_FourParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_FourParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_NineParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   I                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_NineParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G, int32 H, int32 I)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_NineParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_NineParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;
	Parms.H = H;
	Parms.I = I;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_SevenParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_SevenParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_SevenParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_SevenParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_SixParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_SixParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_SixParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_SixParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_TenParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   E                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   I                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   J                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_TenParams(int32 A, int32 B, int32 C, int32 D, int32 E, int32 F, int32 G, int32 H, int32 I, int32 J)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_TenParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_TenParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;
	Parms.D = D;
	Parms.E = E;
	Parms.F = F;
	Parms.G = G;
	Parms.H = H;
	Parms.I = I;
	Parms.J = J;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.CallSkillMessageInternal_ThreeParams
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   C                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::CallSkillMessageInternal_ThreeParams(int32 A, int32 B, int32 C)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "CallSkillMessageInternal_ThreeParams");

	Params::GbxSkillBlueprintPrivate_CallSkillMessageInternal_ThreeParams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.C = C;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.ForceDoubleToFloat
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxSkillBlueprintPrivate::ForceDoubleToFloat(double Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "ForceDoubleToFloat");

	Params::GbxSkillBlueprintPrivate_ForceDoubleToFloat Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.ForceFloatToDouble
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UGbxSkillBlueprintPrivate::ForceFloatToDouble(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "ForceFloatToDouble");

	Params::GbxSkillBlueprintPrivate_ForceFloatToDouble Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_actor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxSkillBlueprintPrivate::GetRefSkillParam_actor(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_actor");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_actor Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_bool
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillBlueprintPrivate::GetRefSkillParam_bool(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_bool");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_bool Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_double
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UGbxSkillBlueprintPrivate::GetRefSkillParam_double(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_double");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_double Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_float
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxSkillBlueprintPrivate::GetRefSkillParam_float(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_float");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_float Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_int
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxSkillBlueprintPrivate::GetRefSkillParam_int(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_int");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_int Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_name
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxSkillBlueprintPrivate::GetRefSkillParam_name(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_name");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_name Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_object
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UGbxSkillBlueprintPrivate::GetRefSkillParam_object(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_object");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_object Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_rotator
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UGbxSkillBlueprintPrivate::GetRefSkillParam_rotator(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_rotator");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_rotator Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_string
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGbxSkillBlueprintPrivate::GetRefSkillParam_string(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_string");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_string Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetRefSkillParam_vector
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxSkillBlueprintPrivate::GetRefSkillParam_vector(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetRefSkillParam_vector");

	Params::GbxSkillBlueprintPrivate_GetRefSkillParam_vector Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_actor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxSkillBlueprintPrivate::GetSkillParam_actor(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_actor");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_actor Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_bool
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillBlueprintPrivate::GetSkillParam_bool(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_bool");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_bool Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_double
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UGbxSkillBlueprintPrivate::GetSkillParam_double(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_double");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_double Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_float
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxSkillBlueprintPrivate::GetSkillParam_float(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_float");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_float Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_int
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxSkillBlueprintPrivate::GetSkillParam_int(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_int");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_int Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_name
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxSkillBlueprintPrivate::GetSkillParam_name(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_name");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_name Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_object
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UGbxSkillBlueprintPrivate::GetSkillParam_object(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_object");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_object Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_rotator
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UGbxSkillBlueprintPrivate::GetSkillParam_rotator(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_rotator");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_rotator Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_string
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGbxSkillBlueprintPrivate::GetSkillParam_string(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_string");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_string Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.GetSkillParam_vector
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxSkillBlueprintPrivate::GetSkillParam_vector(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "GetSkillParam_vector");

	Params::GbxSkillBlueprintPrivate_GetSkillParam_vector Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_actor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_actor(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, class AActor* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_actor");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_actor Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_bool
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_bool(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_bool");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_bool Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_float
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_float(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_float");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_float Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_int
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_int(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_int");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_int Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_name
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_name(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, class FName Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_name");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_name Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_object
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_object(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_object");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_object Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_rotator
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_rotator(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, const struct FRotator& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_rotator");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_rotator Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_string
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_string(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_string");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_string Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.PrepareSkillParam_vector
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::PrepareSkillParam_vector(class UGbxSkillActionExecHandler* Context, class UGbxSkillParamData* ParamData, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "PrepareSkillParam_vector");

	Params::GbxSkillBlueprintPrivate_PrepareSkillParam_vector Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.RegisterRespondant
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillQuestionData*            SkillQuestionData                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          FunctionContext                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::RegisterRespondant(class UObject* Context, class UGbxSkillQuestionData* SkillQuestionData, class UObject* FunctionContext, class FName FunctionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "RegisterRespondant");

	Params::GbxSkillBlueprintPrivate_RegisterRespondant Parms{};

	Parms.Context = Context;
	Parms.SkillQuestionData = SkillQuestionData;
	Parms.FunctionContext = FunctionContext;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_actor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_actor(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, class AActor* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_actor");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_actor Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_bool
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_bool(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_bool");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_bool Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_double
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_double(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, double Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_double");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_double Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_float
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_float(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_float");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_float Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_int
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_int(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_int");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_int Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_name
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_name(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, class FName Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_name");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_name Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_object
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_object(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_object");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_object Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_rotator
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_rotator(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, const struct FRotator& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_rotator");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_rotator Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_string
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_string(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_string");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_string Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetRefSkillParam_vector
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   ContextType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetRefSkillParam_vector(int32 ContextType, class UObject* Context, FGbxDefPtrProperty_ SkillDef, class UGbxSkillParamData* ParamData, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetRefSkillParam_vector");

	Params::GbxSkillBlueprintPrivate_SetRefSkillParam_vector Parms{};

	Parms.ContextType = ContextType;
	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_actor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_actor(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, class AActor* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_actor");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_actor Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_bool
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_bool(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_bool");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_bool Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_double
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_double(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, double Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_double");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_double Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_float
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_float(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_float");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_float Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_int
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_int(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_int");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_int Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_name
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_name(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, class FName Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_name");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_name Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_object
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_object(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_object");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_object Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_rotator
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_rotator(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, const struct FRotator& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_rotator");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_rotator Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_string
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_string(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_string");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_string Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillBlueprintPrivate.SetSkillParam_vector
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkillParamData*               ParamData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillBlueprintPrivate::SetSkillParam_vector(class UGbxSkillScript* Context, class UGbxSkillParamData* ParamData, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillBlueprintPrivate", "SetSkillParam_vector");

	Params::GbxSkillBlueprintPrivate_SetSkillParam_vector Parms{};

	Parms.Context = Context;
	Parms.ParamData = ParamData;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxManagedSkeletalMeshComponent.NotifyAnimInitialized
// (Final, Native, Protected)

void UGbxManagedSkeletalMeshComponent::NotifyAnimInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxManagedSkeletalMeshComponent", "NotifyAnimInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.AddExternalGestaltMeshes_BP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class USkeletalMesh*>&     InGestaltMeshes                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::AddExternalGestaltMeshes_BP(const TArray<class USkeletalMesh*>& InGestaltMeshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "AddExternalGestaltMeshes_BP");

	Params::GbxSkeletalMeshComponent_AddExternalGestaltMeshes_BP Parms{};

	Parms.InGestaltMeshes = std::move(InGestaltMeshes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.ForceDisableSimulatePhysics
// (Final, Native, Public, BlueprintCallable)

void UGbxSkeletalMeshComponent::ForceDisableSimulatePhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "ForceDisableSimulatePhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.GetForwardDynamicAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxSkeletalMeshComponent::GetForwardDynamicAngularVelocity(class FName BodyName, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "GetForwardDynamicAngularVelocity");

	Params::GbxSkeletalMeshComponent_GetForwardDynamicAngularVelocity Parms{};

	Parms.BodyName = BodyName;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkeletalMeshComponent.GetForwardDynamicLinearVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxSkeletalMeshComponent::GetForwardDynamicLinearVelocity(class FName BodyName, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "GetForwardDynamicLinearVelocity");

	Params::GbxSkeletalMeshComponent_GetForwardDynamicLinearVelocity Parms{};

	Parms.BodyName = BodyName;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkeletalMeshComponent.GetForwardDynamicTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UGbxSkeletalMeshComponent::GetForwardDynamicTransform(class FName BodyName, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "GetForwardDynamicTransform");

	Params::GbxSkeletalMeshComponent_GetForwardDynamicTransform Parms{};

	Parms.BodyName = BodyName;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkeletalMeshComponent.RemoveBodyAndChildren
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::RemoveBodyAndChildren(const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "RemoveBodyAndChildren");

	Params::GbxSkeletalMeshComponent_RemoveBodyAndChildren Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.RemoveBodyTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::RemoveBodyTarget(class FName BodyName, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "RemoveBodyTarget");

	Params::GbxSkeletalMeshComponent_RemoveBodyTarget Parms{};

	Parms.BodyName = BodyName;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.RemoveExternalGestaltMeshes_BP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class USkeletalMesh*>&     InGestaltMeshes                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::RemoveExternalGestaltMeshes_BP(const TArray<class USkeletalMesh*>& InGestaltMeshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "RemoveExternalGestaltMeshes_BP");

	Params::GbxSkeletalMeshComponent_RemoveExternalGestaltMeshes_BP Parms{};

	Parms.InGestaltMeshes = std::move(InGestaltMeshes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.ResetPrimarySimulationTag
// (Final, Native, Public, BlueprintCallable)

void UGbxSkeletalMeshComponent::ResetPrimarySimulationTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "ResetPrimarySimulationTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.SetBodyTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Pose                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Stiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  TargetSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::SetBodyTarget(class FName BodyName, const struct FVector& Pose, double Radius, double Stiffness, double TargetSpeed, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "SetBodyTarget");

	Params::GbxSkeletalMeshComponent_SetBodyTarget Parms{};

	Parms.BodyName = BodyName;
	Parms.Pose = std::move(Pose);
	Parms.Radius = Radius;
	Parms.Stiffness = Stiffness;
	Parms.TargetSpeed = TargetSpeed;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.SetBodyTargetDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  TargetSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::SetBodyTargetDirection(class FName BodyName, const struct FVector& Direction, double TargetSpeed, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "SetBodyTargetDirection");

	Params::GbxSkeletalMeshComponent_SetBodyTargetDirection Parms{};

	Parms.BodyName = BodyName;
	Parms.Direction = std::move(Direction);
	Parms.TargetSpeed = TargetSpeed;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.SetBodyTargetParams
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDBodyTargetParams&        params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::SetBodyTargetParams(class FName BodyName, const struct FDBodyTargetParams& params, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "SetBodyTargetParams");

	Params::GbxSkeletalMeshComponent_SetBodyTargetParams Parms{};

	Parms.BodyName = BodyName;
	Parms.params = std::move(params);
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.SetCollisionResponse
// (Native, Public, BlueprintCallable)
// Parameters:
// ECollisionEnabled                       CollisionEnabled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::SetCollisionResponse(ECollisionEnabled CollisionEnabled, class FName BodyName, bool bIncludeChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "SetCollisionResponse");

	Params::GbxSkeletalMeshComponent_SetCollisionResponse Parms{};

	Parms.CollisionEnabled = CollisionEnabled;
	Parms.BodyName = BodyName;
	Parms.bIncludeChildren = bIncludeChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.SetGravityOverride
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Gravity                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::SetGravityOverride(bool bEnabled, const struct FVector& Gravity, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "SetGravityOverride");

	Params::GbxSkeletalMeshComponent_SetGravityOverride Parms{};

	Parms.bEnabled = bEnabled;
	Parms.Gravity = std::move(Gravity);
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.SetPrimarySimulationTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceSet                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::SetPrimarySimulationTag(class FName Tag, bool bForceSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "SetPrimarySimulationTag");

	Params::GbxSkeletalMeshComponent_SetPrimarySimulationTag Parms{};

	Parms.Tag = Tag;
	Parms.bForceSet = bForceSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.TeleportPrimarySimulation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkeletalMeshComponent::TeleportPrimarySimulation(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "TeleportPrimarySimulation");

	Params::GbxSkeletalMeshComponent_TeleportPrimarySimulation Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkeletalMeshComponent.GetAnimationFromTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InKey                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* UGbxSkeletalMeshComponent::GetAnimationFromTag(const struct FGameplayTag& InKey) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkeletalMeshComponent", "GetAnimationFromTag");

	Params::GbxSkeletalMeshComponent_GetAnimationFromTag Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.deactivate
// (Final, Native, Public, BlueprintCallable)

void AGbxDrone::deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.EnableTargetingForMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::EnableTargetingForMovement(bool bUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "EnableTargetingForMovement");

	Params::GbxDrone_EnableTargetingForMovement Parms{};

	Parms.bUse = bUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.EnableTargetingForOrientation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::EnableTargetingForOrientation(bool bUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "EnableTargetingForOrientation");

	Params::GbxDrone_EnableTargetingForOrientation Parms{};

	Parms.bUse = bUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.OnDeactivatedChanged
// (Final, Native, Private)

void AGbxDrone::OnDeactivatedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "OnDeactivatedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.OnDeadChanged
// (Final, Native, Private)

void AGbxDrone::OnDeadChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "OnDeadChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.OnProjectileCollisionChanged
// (Final, Native, Private)

void AGbxDrone::OnProjectileCollisionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "OnProjectileCollisionChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.OnRep_AppearanceNetChannels
// (Final, Native, Public)

void AGbxDrone::OnRep_AppearanceNetChannels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "OnRep_AppearanceNetChannels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.OnRep_GbxActorPartOwnerState
// (Final, Native, Protected)

void AGbxDrone::OnRep_GbxActorPartOwnerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "OnRep_GbxActorPartOwnerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.OnRep_MovementMode
// (Final, Native, Private)

void AGbxDrone::OnRep_MovementMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "OnRep_MovementMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetMovementMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EGbxDroneMovementMode                   NewMovementMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetMovementMode(EGbxDroneMovementMode NewMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetMovementMode");

	Params::GbxDrone_SetMovementMode Parms{};

	Parms.NewMovementMode = NewMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetMovementTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewMovementTarget                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxDroneMovementMode                   ReachedTargetMovementMode                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetOrientationTarget                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetMovementTarget(class AActor* NewMovementTarget, bool bSetMovementMode, EGbxDroneMovementMode ReachedTargetMovementMode, bool bSetOrientationTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetMovementTarget");

	Params::GbxDrone_SetMovementTarget Parms{};

	Parms.NewMovementTarget = NewMovementTarget;
	Parms.bSetMovementMode = bSetMovementMode;
	Parms.ReachedTargetMovementMode = ReachedTargetMovementMode;
	Parms.bSetOrientationTarget = bSetOrientationTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetMovementTargetComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxDroneMovementMode                   ReachedTargetMovementMode                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetMovementTargetComponent(class USceneComponent* SceneComponent, bool bSetMovementMode, EGbxDroneMovementMode ReachedTargetMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetMovementTargetComponent");

	Params::GbxDrone_SetMovementTargetComponent Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.bSetMovementMode = bSetMovementMode;
	Parms.ReachedTargetMovementMode = ReachedTargetMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetMovementTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxDroneMovementMode                   ReachedTargetMovementMode                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetMovementTargetLocation(const struct FVector& TargetLocation, bool bSetMovementMode, EGbxDroneMovementMode ReachedTargetMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetMovementTargetLocation");

	Params::GbxDrone_SetMovementTargetLocation Parms{};

	Parms.TargetLocation = std::move(TargetLocation);
	Parms.bSetMovementMode = bSetMovementMode;
	Parms.ReachedTargetMovementMode = ReachedTargetMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetMovementTowardsGPSQuery
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UGpsQueryAsset>    Query                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxDroneMovementMode                   ReachedTargetMovementMode                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetMovementTowardsGPSQuery(TSoftObjectPtr<class UGpsQueryAsset> Query, bool bSetMovementMode, EGbxDroneMovementMode ReachedTargetMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetMovementTowardsGPSQuery");

	Params::GbxDrone_SetMovementTowardsGPSQuery Parms{};

	Parms.Query = Query;
	Parms.bSetMovementMode = bSetMovementMode;
	Parms.ReachedTargetMovementMode = ReachedTargetMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetOrientationMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EGbxDroneOrientationMode                NewOrientationMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetOrientationMode(EGbxDroneOrientationMode NewOrientationMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetOrientationMode");

	Params::GbxDrone_SetOrientationMode Parms{};

	Parms.NewOrientationMode = NewOrientationMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetOrientationTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewOrientationTarget                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetOrientationTarget(class AActor* NewOrientationTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetOrientationTarget");

	Params::GbxDrone_SetOrientationTarget Parms{};

	Parms.NewOrientationTarget = NewOrientationTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.SetProjectileCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxDrone::SetProjectileCollision(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "SetProjectileCollision");

	Params::GbxDrone_SetProjectileCollision Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDrone.GetBestTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGbxDrone::GetBestTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "GetBestTarget");

	Params::GbxDrone_GetBestTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.GetMovementTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGbxDrone::GetMovementTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "GetMovementTarget");

	Params::GbxDrone_GetMovementTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.GetMovementTargetLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AGbxDrone::GetMovementTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "GetMovementTargetLocation");

	Params::GbxDrone_GetMovementTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.GetOrientationTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGbxDrone::GetOrientationTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "GetOrientationTarget");

	Params::GbxDrone_GetOrientationTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.GetOrientationTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AGbxDrone::GetOrientationTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "GetOrientationTargetLocation");

	Params::GbxDrone_GetOrientationTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.GetTargetReachedDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGbxDrone::GetTargetReachedDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "GetTargetReachedDistance");

	Params::GbxDrone_GetTargetReachedDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.IsAboveTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxDrone::IsAboveTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "IsAboveTarget");

	Params::GbxDrone_IsAboveTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDrone.IsTargetInRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxDrone::IsTargetInRange(float Distance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxDrone", "IsTargetInRange");

	Params::GbxDrone_IsTargetInRange Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.GetChosenOrbitAltitude
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxDroneStatics::GetChosenOrbitAltitude(class AGbxDrone* Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "GetChosenOrbitAltitude");

	Params::GbxDroneStatics_GetChosenOrbitAltitude Parms{};

	Parms.Drone = Drone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.GetChosenOrbitRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxDroneStatics::GetChosenOrbitRadius(class AGbxDrone* Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "GetChosenOrbitRadius");

	Params::GbxDroneStatics_GetChosenOrbitRadius Parms{};

	Parms.Drone = Drone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.GetOrbitAltitude
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNumericRange                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FNumericRange UGbxDroneStatics::GetOrbitAltitude(class AGbxDrone* Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "GetOrbitAltitude");

	Params::GbxDroneStatics_GetOrbitAltitude Parms{};

	Parms.Drone = Drone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.GetOrbitAltitudeVaryRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxDroneStatics::GetOrbitAltitudeVaryRate(class AGbxDrone* Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "GetOrbitAltitudeVaryRate");

	Params::GbxDroneStatics_GetOrbitAltitudeVaryRate Parms{};

	Parms.Drone = Drone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.GetOrbitRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNumericRange                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FNumericRange UGbxDroneStatics::GetOrbitRadius(class AGbxDrone* Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "GetOrbitRadius");

	Params::GbxDroneStatics_GetOrbitRadius Parms{};

	Parms.Drone = Drone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.GetOrbitRadiusVaryRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxDroneStatics::GetOrbitRadiusVaryRate(class AGbxDrone* Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "GetOrbitRadiusVaryRate");

	Params::GbxDroneStatics_GetOrbitRadiusVaryRate Parms{};

	Parms.Drone = Drone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.GetOrbitSpeed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxDroneStatics::GetOrbitSpeed(class AGbxDrone* Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "GetOrbitSpeed");

	Params::GbxDroneStatics_GetOrbitSpeed Parms{};

	Parms.Drone = Drone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDroneStatics.IncrementOrbitAltitudeRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::IncrementOrbitAltitudeRange(class AGbxDrone* Drone, float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "IncrementOrbitAltitudeRange");

	Params::GbxDroneStatics_IncrementOrbitAltitudeRange Parms{};

	Parms.Drone = Drone;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.IncrementOrbitRadiusRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::IncrementOrbitRadiusRange(class AGbxDrone* Drone, float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "IncrementOrbitRadiusRange");

	Params::GbxDroneStatics_IncrementOrbitRadiusRange Parms{};

	Parms.Drone = Drone;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetOrbitAltitudeMinMax
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Minimum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Maximum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetOrbitAltitudeMinMax(class AGbxDrone* Drone, float Minimum, float Maximum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetOrbitAltitudeMinMax");

	Params::GbxDroneStatics_SetOrbitAltitudeMinMax Parms{};

	Parms.Drone = Drone;
	Parms.Minimum = Minimum;
	Parms.Maximum = Maximum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetOrbitAltitudeRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Variance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetOrbitAltitudeRange(class AGbxDrone* Drone, float Value, float Variance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetOrbitAltitudeRange");

	Params::GbxDroneStatics_SetOrbitAltitudeRange Parms{};

	Parms.Drone = Drone;
	Parms.Value = Value;
	Parms.Variance = Variance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetOrbitAltitudeVaryRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetOrbitAltitudeVaryRate(class AGbxDrone* Drone, float rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetOrbitAltitudeVaryRate");

	Params::GbxDroneStatics_SetOrbitAltitudeVaryRate Parms{};

	Parms.Drone = Drone;
	Parms.rate = rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetOrbitRadiusMinMax
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Minimum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Maximum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetOrbitRadiusMinMax(class AGbxDrone* Drone, float Minimum, float Maximum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetOrbitRadiusMinMax");

	Params::GbxDroneStatics_SetOrbitRadiusMinMax Parms{};

	Parms.Drone = Drone;
	Parms.Minimum = Minimum;
	Parms.Maximum = Maximum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetOrbitRadiusRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Variance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetOrbitRadiusRange(class AGbxDrone* Drone, float Value, float Variance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetOrbitRadiusRange");

	Params::GbxDroneStatics_SetOrbitRadiusRange Parms{};

	Parms.Drone = Drone;
	Parms.Value = Value;
	Parms.Variance = Variance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetOrbitRadiusVaryRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetOrbitRadiusVaryRate(class AGbxDrone* Drone, float rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetOrbitRadiusVaryRate");

	Params::GbxDroneStatics_SetOrbitRadiusVaryRate Parms{};

	Parms.Drone = Drone;
	Parms.rate = rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetOrbitSpeed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetOrbitSpeed(class AGbxDrone* Drone, float InSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetOrbitSpeed");

	Params::GbxDroneStatics_SetOrbitSpeed Parms{};

	Parms.Drone = Drone;
	Parms.InSpeed = InSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetVaryAltitudeRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVary                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetVaryAltitudeRadius(class AGbxDrone* Drone, bool bVary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetVaryAltitudeRadius");

	Params::GbxDroneStatics_SetVaryAltitudeRadius Parms{};

	Parms.Drone = Drone;
	Parms.bVary = bVary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDroneStatics.SetVaryOrbitRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxDrone*                        Drone                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVary                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxDroneStatics::SetVaryOrbitRadius(class AGbxDrone* Drone, bool bVary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDroneStatics", "SetVaryOrbitRadius");

	Params::GbxDroneStatics_SetVaryOrbitRadius Parms{};

	Parms.Drone = Drone;
	Parms.bVary = bVary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxDynamicBindingResolverLibrary.ResolveWithPrimaryPlayerStandIn
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMovieSceneDynamicBindingResolveParams&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              StandInCategory                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneDynamicBindingResolveResultReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMovieSceneDynamicBindingResolveResult UGbxDynamicBindingResolverLibrary::ResolveWithPrimaryPlayerStandIn(class UObject* WorldContextObject, const struct FMovieSceneDynamicBindingResolveParams& params, const struct FGameplayTag& StandInCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDynamicBindingResolverLibrary", "ResolveWithPrimaryPlayerStandIn");

	Params::GbxDynamicBindingResolverLibrary_ResolveWithPrimaryPlayerStandIn Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.params = std::move(params);
	Parms.StandInCategory = std::move(StandInCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxDynamicBindingResolverLibrary.ResolveWithStandIn
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMovieSceneDynamicBindingResolveParams&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              StandInTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneDynamicBindingResolveResultReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMovieSceneDynamicBindingResolveResult UGbxDynamicBindingResolverLibrary::ResolveWithStandIn(class UObject* WorldContextObject, const struct FMovieSceneDynamicBindingResolveParams& params, const struct FGameplayTag& StandInTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxDynamicBindingResolverLibrary", "ResolveWithStandIn");

	Params::GbxDynamicBindingResolverLibrary_ResolveWithStandIn Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.params = std::move(params);
	Parms.StandInTag = std::move(StandInTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxEffectsManagerProxy.OnParticleSystemFinished
// (Final, Native, Public)
// Parameters:
// class UFXSystemComponent*               PSC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxEffectsManagerProxy::OnParticleSystemFinished(class UFXSystemComponent* PSC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxEffectsManagerProxy", "OnParticleSystemFinished");

	Params::GbxEffectsManagerProxy_OnParticleSystemFinished Parms{};

	Parms.PSC = PSC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxEffectsFunctionLibrary.ExtractAudioImpactParameters
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// const struct FImpactAudioParameter&     AudioParameter                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FImpactEffectParams*             OutParams                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UGbxEffectsFunctionLibrary::ExtractAudioImpactParameters(const struct FImpactAudioParameter& AudioParameter, struct FImpactEffectParams* OutParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectsFunctionLibrary", "ExtractAudioImpactParameters");

	Params::GbxEffectsFunctionLibrary_ExtractAudioImpactParameters Parms{};

	Parms.AudioParameter = std::move(AudioParameter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutParams != nullptr)
		*OutParams = std::move(Parms.OutParams);
}


// Function GbxGame.GbxEffectsFunctionLibrary.GetCollectionParticle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                Collection                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ContextHandle                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* UGbxEffectsFunctionLibrary::GetCollectionParticle(FGameDataHandleProperty_ Collection, class UObject* ContextObject, FGameDataHandleProperty_ ContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectsFunctionLibrary", "GetCollectionParticle");

	Params::GbxEffectsFunctionLibrary_GetCollectionParticle Parms{};

	Parms.Collection = Collection;
	Parms.ContextObject = ContextObject;
	Parms.ContextHandle = ContextHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxEffectsFunctionLibrary.MakeImpactEffectSelection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FGameDataHandleProperty_                Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactEffectSelection           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FImpactEffectSelection UGbxEffectsFunctionLibrary::MakeImpactEffectSelection(FGameDataHandleProperty_ Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectsFunctionLibrary", "MakeImpactEffectSelection");

	Params::GbxEffectsFunctionLibrary_MakeImpactEffectSelection Parms{};

	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxEffectsFunctionLibrary.PlayHitResultImpact
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                ImpactEffect                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bReplicate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&ParticleParameters                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FImpactAudioParameter&     AudioParameter                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDilation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxEffectsFunctionLibrary::PlayHitResultImpact(FGameDataHandleProperty_ ImpactEffect, class AActor* instigator, const struct FHitResult& HitInfo, bool bReplicate, const TArray<struct FGbxParticleParameter>& ParticleParameters, const struct FImpactAudioParameter& AudioParameter, float Size, float TimeDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectsFunctionLibrary", "PlayHitResultImpact");

	Params::GbxEffectsFunctionLibrary_PlayHitResultImpact Parms{};

	Parms.ImpactEffect = ImpactEffect;
	Parms.instigator = instigator;
	Parms.HitInfo = std::move(HitInfo);
	Parms.bReplicate = bReplicate;
	Parms.ParticleParameters = std::move(ParticleParameters);
	Parms.AudioParameter = std::move(AudioParameter);
	Parms.Size = Size;
	Parms.TimeDilation = TimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxEffectsFunctionLibrary.PlayTraceImpact
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                ImpactEffect                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TraceStart                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TraceEnd                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayOnNoHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&ParticleParameters                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FImpactAudioParameter&     AudioParameter                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDilation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxEffectsFunctionLibrary::PlayTraceImpact(FGameDataHandleProperty_ ImpactEffect, class AActor* instigator, const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bReplicate, bool bPlayOnNoHit, const TArray<struct FGbxParticleParameter>& ParticleParameters, const struct FImpactAudioParameter& AudioParameter, ECollisionChannel TraceChannel, float Size, float TimeDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectsFunctionLibrary", "PlayTraceImpact");

	Params::GbxEffectsFunctionLibrary_PlayTraceImpact Parms{};

	Parms.ImpactEffect = ImpactEffect;
	Parms.instigator = instigator;
	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceEnd = std::move(TraceEnd);
	Parms.bReplicate = bReplicate;
	Parms.bPlayOnNoHit = bPlayOnNoHit;
	Parms.ParticleParameters = std::move(ParticleParameters);
	Parms.AudioParameter = std::move(AudioParameter);
	Parms.TraceChannel = TraceChannel;
	Parms.Size = Size;
	Parms.TimeDilation = TimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxEffectsFunctionLibrary.PlayWorldImpact
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                ImpactEffect                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&ParticleParameters                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FImpactAudioParameter&     AudioParameter                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDilation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ImpactActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ImpactComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxEffectsFunctionLibrary::PlayWorldImpact(FGameDataHandleProperty_ ImpactEffect, class AActor* instigator, const struct FVector& Location, const struct FVector& Normal, bool bReplicate, const TArray<struct FGbxParticleParameter>& ParticleParameters, const struct FImpactAudioParameter& AudioParameter, float Size, float TimeDilation, class AActor* ImpactActor, class UPrimitiveComponent* ImpactComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxEffectsFunctionLibrary", "PlayWorldImpact");

	Params::GbxEffectsFunctionLibrary_PlayWorldImpact Parms{};

	Parms.ImpactEffect = ImpactEffect;
	Parms.instigator = instigator;
	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.bReplicate = bReplicate;
	Parms.ParticleParameters = std::move(ParticleParameters);
	Parms.AudioParameter = std::move(AudioParameter);
	Parms.Size = Size;
	Parms.TimeDilation = TimeDilation;
	Parms.ImpactActor = ImpactActor;
	Parms.ImpactComponent = ImpactComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrick_Ragdoll.ComponentHitCallback
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxTrick_Ragdoll::ComponentHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTrick_Ragdoll", "ComponentHitCallback");

	Params::GbxTrick_Ragdoll_ComponentHitCallback Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleStateManager.OnScreenParticleFinished
// (Native, Protected)
// Parameters:
// class UFXSystemComponent*               Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenParticleStateManager::OnScreenParticleFinished(class UFXSystemComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenParticleStateManager", "OnScreenParticleFinished");

	Params::ScreenParticleStateManager_OnScreenParticleFinished Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxFeedbackBlueprintLibrary.PlayGbxFeedback2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const FGameDataHandleProperty_          data                                                   (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IGbxFeedbackObserver>Observer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreObserver                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceContext                                          (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxFeedbackBlueprintLibrary::PlayGbxFeedback2D(class UObject* WorldContext, const FGameDataHandleProperty_ data, TScriptInterface<class IGbxFeedbackObserver> Observer, bool bIgnoreObserver, int32 PlayFlags, bool bLoop, float scale, class UObject* SourceContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxFeedbackBlueprintLibrary", "PlayGbxFeedback2D");

	Params::GbxFeedbackBlueprintLibrary_PlayGbxFeedback2D Parms{};

	Parms.WorldContext = WorldContext;
	Parms.data = data;
	Parms.Observer = Observer;
	Parms.bIgnoreObserver = bIgnoreObserver;
	Parms.PlayFlags = PlayFlags;
	Parms.bLoop = bLoop;
	Parms.scale = scale;
	Parms.SourceContext = SourceContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxFeedbackBlueprintLibrary.PlayGbxFeedback3D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const FGameDataHandleProperty_          data                                                   (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IGbxFeedbackObserver>Observer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreObserver                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceContext                                          (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SourceLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EffectFalloffMinDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EffectFalloffMaxDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxFeedbackBlueprintLibrary::PlayGbxFeedback3D(class UObject* WorldContext, const FGameDataHandleProperty_ data, TScriptInterface<class IGbxFeedbackObserver> Observer, bool bIgnoreObserver, int32 PlayFlags, bool bLoop, float scale, class UObject* SourceContext, const struct FVector& SourceLocation, float EffectFalloffMinDistance, float EffectFalloffMaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxFeedbackBlueprintLibrary", "PlayGbxFeedback3D");

	Params::GbxFeedbackBlueprintLibrary_PlayGbxFeedback3D Parms{};

	Parms.WorldContext = WorldContext;
	Parms.data = data;
	Parms.Observer = Observer;
	Parms.bIgnoreObserver = bIgnoreObserver;
	Parms.PlayFlags = PlayFlags;
	Parms.bLoop = bLoop;
	Parms.scale = scale;
	Parms.SourceContext = SourceContext;
	Parms.SourceLocation = std::move(SourceLocation);
	Parms.EffectFalloffMinDistance = EffectFalloffMinDistance;
	Parms.EffectFalloffMaxDistance = EffectFalloffMaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxFeedbackBlueprintLibrary.ResetGbxFeedbackPlayTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const FGameDataHandleProperty_          data                                                   (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IGbxFeedbackObserver>Observer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreObserver                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxFeedbackBlueprintLibrary::ResetGbxFeedbackPlayTime(class UObject* WorldContext, const FGameDataHandleProperty_ data, TScriptInterface<class IGbxFeedbackObserver> Observer, bool bIgnoreObserver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxFeedbackBlueprintLibrary", "ResetGbxFeedbackPlayTime");

	Params::GbxFeedbackBlueprintLibrary_ResetGbxFeedbackPlayTime Parms{};

	Parms.WorldContext = WorldContext;
	Parms.data = data;
	Parms.Observer = Observer;
	Parms.bIgnoreObserver = bIgnoreObserver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxFeedbackBlueprintLibrary.StopGbxFeedback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const FGameDataHandleProperty_          data                                                   (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IGbxFeedbackObserver>Observer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreObserver                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxFeedbackBlueprintLibrary::StopGbxFeedback(class UObject* WorldContext, const FGameDataHandleProperty_ data, TScriptInterface<class IGbxFeedbackObserver> Observer, bool bIgnoreObserver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxFeedbackBlueprintLibrary", "StopGbxFeedback");

	Params::GbxFeedbackBlueprintLibrary_StopGbxFeedback Parms{};

	Parms.WorldContext = WorldContext;
	Parms.data = data;
	Parms.Observer = Observer;
	Parms.bIgnoreObserver = bIgnoreObserver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_Destroy
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_Destroy(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_Destroy");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_Destroy Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_Detonate
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKillSelfOnDetonate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewExplosive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatorOverride                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_Detonate(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType, bool bKillSelfOnDetonate, bool bRequestNewExplosive, class AActor* InstigatorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_Detonate");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_Detonate Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.bKillSelfOnDetonate = bKillSelfOnDetonate;
	Parms.bRequestNewExplosive = bRequestNewExplosive;
	Parms.InstigatorOverride = InstigatorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatorOverride                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_Drop(class AActor* AIActor, bool bRequestNewHeldActor, class FName ID, EGbxAIHeldFilterType FilterType, class AActor* InstigatorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_Drop");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_Drop Parms{};

	Parms.AIActor = AIActor;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.InstigatorOverride = InstigatorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_GetActors
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class Aprojectile*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class Aprojectile*> UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_GetActors(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_GetActors");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_GetActors Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_SetChildActorDef
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                NewActorDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_SetChildActorDef(class AActor* AIActor, FGameDataHandleProperty_ NewActorDef, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_SetChildActorDef");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_SetChildActorDef Parms{};

	Parms.AIActor = AIActor;
	Parms.NewActorDef = NewActorDef;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_Spawn
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_Spawn(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_Spawn");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_Spawn Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_ThrowAtActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_ThrowAtActor(class AActor* AIActor, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_ThrowAtActor");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_ThrowAtActor Parms{};

	Parms.AIActor = AIActor;
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_ThrowAtCrosshair
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_ThrowAtCrosshair(class AActor* AIActor, const struct FTrajectoryOptions& TrajectoryOptions, float TraceDistance, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_ThrowAtCrosshair");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_ThrowAtCrosshair Parms{};

	Parms.AIActor = AIActor;
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.TraceDistance = TraceDistance;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_ThrowAtTarget
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_ThrowAtTarget(class AActor* AIActor, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_ThrowAtTarget");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_ThrowAtTarget Parms{};

	Parms.AIActor = AIActor;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldExplosive_ThrowHeldActorAtLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ThrowAtLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldExplosive_ThrowHeldActorAtLocation(class AActor* AIActor, const struct FVector& ThrowAtLocation, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldExplosive_ThrowHeldActorAtLocation");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldExplosive_ThrowHeldActorAtLocation Parms{};

	Parms.AIActor = AIActor;
	Parms.ThrowAtLocation = std::move(ThrowAtLocation);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_Destroy
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_Destroy(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_Destroy");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_Destroy Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatorOverride                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_Drop(class AActor* AIActor, bool bRequestNewHeldActor, class FName ID, EGbxAIHeldFilterType FilterType, class AActor* InstigatorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_Drop");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_Drop Parms{};

	Parms.AIActor = AIActor;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.InstigatorOverride = InstigatorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_GetActors
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class Aprojectile*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class Aprojectile*> UGbxGameHeldActorFunctionLibrary::AIHeldMelee_GetActors(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_GetActors");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_GetActors Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_SetChildActorDef
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                NewActorDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_SetChildActorDef(class AActor* AIActor, FGameDataHandleProperty_ NewActorDef, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_SetChildActorDef");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_SetChildActorDef Parms{};

	Parms.AIActor = AIActor;
	Parms.NewActorDef = NewActorDef;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_Spawn
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_Spawn(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_Spawn");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_Spawn Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_ThrowAtActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_ThrowAtActor(class AActor* AIActor, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_ThrowAtActor");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_ThrowAtActor Parms{};

	Parms.AIActor = AIActor;
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_ThrowAtCrosshair
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_ThrowAtCrosshair(class AActor* AIActor, const struct FTrajectoryOptions& TrajectoryOptions, float TraceDistance, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_ThrowAtCrosshair");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_ThrowAtCrosshair Parms{};

	Parms.AIActor = AIActor;
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.TraceDistance = TraceDistance;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_ThrowAtTarget
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_ThrowAtTarget(class AActor* AIActor, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_ThrowAtTarget");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_ThrowAtTarget Parms{};

	Parms.AIActor = AIActor;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldMelee_ThrowHeldActorAtLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ThrowAtLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldMelee_ThrowHeldActorAtLocation(class AActor* AIActor, const struct FVector& ThrowAtLocation, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldMelee_ThrowHeldActorAtLocation");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldMelee_ThrowHeldActorAtLocation Parms{};

	Parms.AIActor = AIActor;
	Parms.ThrowAtLocation = std::move(ThrowAtLocation);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_Destroy
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_Destroy(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_Destroy");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_Destroy Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatorOverride                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_Drop(class AActor* AIActor, bool bRequestNewHeldActor, class FName ID, EGbxAIHeldFilterType FilterType, class AActor* InstigatorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_Drop");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_Drop Parms{};

	Parms.AIActor = AIActor;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.InstigatorOverride = InstigatorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_GetActors
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class Aprojectile*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class Aprojectile*> UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_GetActors(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_GetActors");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_GetActors Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_GetImpactEffect
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactEffectSelection           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FImpactEffectSelection UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_GetImpactEffect(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_GetImpactEffect");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_GetImpactEffect Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_SetChildActorDef
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                NewActorDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_SetChildActorDef(class AActor* AIActor, FGameDataHandleProperty_ NewActorDef, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_SetChildActorDef");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_SetChildActorDef Parms{};

	Parms.AIActor = AIActor;
	Parms.NewActorDef = NewActorDef;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_Spawn
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_Spawn(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_Spawn");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_Spawn Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_ThrowAtActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_ThrowAtActor(class AActor* AIActor, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_ThrowAtActor");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_ThrowAtActor Parms{};

	Parms.AIActor = AIActor;
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_ThrowAtCrosshair
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_ThrowAtCrosshair(class AActor* AIActor, const struct FTrajectoryOptions& TrajectoryOptions, float TraceDistance, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_ThrowAtCrosshair");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_ThrowAtCrosshair Parms{};

	Parms.AIActor = AIActor;
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.TraceDistance = TraceDistance;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_ThrowAtTarget
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_ThrowAtTarget(class AActor* AIActor, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_ThrowAtTarget");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_ThrowAtTarget Parms{};

	Parms.AIActor = AIActor;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldProjectile_ThrowHeldActorAtLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ThrowAtLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldProjectile_ThrowHeldActorAtLocation(class AActor* AIActor, const struct FVector& ThrowAtLocation, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldProjectile_ThrowHeldActorAtLocation");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldProjectile_ThrowHeldActorAtLocation Parms{};

	Parms.AIActor = AIActor;
	Parms.ThrowAtLocation = std::move(ThrowAtLocation);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_Destroy
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_Destroy(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_Destroy");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_Destroy Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatorOverride                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_Drop(class AActor* AIActor, bool bRequestNewHeldActor, class FName ID, EGbxAIHeldFilterType FilterType, class AActor* InstigatorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_Drop");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_Drop Parms{};

	Parms.AIActor = AIActor;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.InstigatorOverride = InstigatorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_GetActors
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class Aprojectile*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class Aprojectile*> UGbxGameHeldActorFunctionLibrary::AIHeldShield_GetActors(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_GetActors");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_GetActors Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_SetChildActorDef
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                NewActorDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_SetChildActorDef(class AActor* AIActor, FGameDataHandleProperty_ NewActorDef, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_SetChildActorDef");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_SetChildActorDef Parms{};

	Parms.AIActor = AIActor;
	Parms.NewActorDef = NewActorDef;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_Spawn
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_Spawn(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_Spawn");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_Spawn Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_ThrowAtActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_ThrowAtActor(class AActor* AIActor, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_ThrowAtActor");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_ThrowAtActor Parms{};

	Parms.AIActor = AIActor;
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_ThrowAtCrosshair
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_ThrowAtCrosshair(class AActor* AIActor, const struct FTrajectoryOptions& TrajectoryOptions, float TraceDistance, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_ThrowAtCrosshair");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_ThrowAtCrosshair Parms{};

	Parms.AIActor = AIActor;
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.TraceDistance = TraceDistance;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_ThrowAtTarget
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_ThrowAtTarget(class AActor* AIActor, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_ThrowAtTarget");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_ThrowAtTarget Parms{};

	Parms.AIActor = AIActor;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIHeldShield_ThrowHeldActorAtLocation
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ThrowAtLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnIfDoesNotExist                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIHeldShield_ThrowHeldActorAtLocation(class AActor* AIActor, const struct FVector& ThrowAtLocation, const struct FTrajectoryOptions& TrajectoryOptions, bool bRequestNewHeldActor, bool bSpawnIfDoesNotExist, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIHeldShield_ThrowHeldActorAtLocation");

	Params::GbxGameHeldActorFunctionLibrary_AIHeldShield_ThrowHeldActorAtLocation Parms{};

	Parms.AIActor = AIActor;
	Parms.ThrowAtLocation = std::move(ThrowAtLocation);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.bSpawnIfDoesNotExist = bSpawnIfDoesNotExist;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIProjectile_CallOnDrop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class Aprojectile*                      HeldProjectile                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIProjectile_CallOnDrop(class Aprojectile* HeldProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIProjectile_CallOnDrop");

	Params::GbxGameHeldActorFunctionLibrary_AIProjectile_CallOnDrop Parms{};

	Parms.HeldProjectile = HeldProjectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameHeldActorFunctionLibrary.AIProjectile_CallOnThrown
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class Aprojectile*                      HeldProjectile                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameHeldActorFunctionLibrary::AIProjectile_CallOnThrown(class Aprojectile* HeldProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameHeldActorFunctionLibrary", "AIProjectile_CallOnThrown");

	Params::GbxGameHeldActorFunctionLibrary_AIProjectile_CallOnThrown Parms{};

	Parms.HeldProjectile = HeldProjectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleConduit_Timer.OnRep_Timers
// (Final, Native, Private)

void UGbxGameModeModuleConduit_Timer::OnRep_Timers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleConduit_Timer", "OnRep_Timers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost_Basic.OnPlayerDeathBP
// (RequiredAPI, Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxCharacter*                    player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterDeathType                     DeathType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxCharacter*                    Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost_Basic::OnPlayerDeathBP(class AGbxCharacter* player, ECharacterDeathType DeathType, class AGbxCharacter* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Basic", "OnPlayerDeathBP");

	Params::GbxGameModeModuleHost_Basic_OnPlayerDeathBP Parms{};

	Parms.player = player;
	Parms.DeathType = DeathType;
	Parms.Killer = Killer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameModeModuleHost_Basic.OnPlayerRespawnBP
// (RequiredAPI, Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerController*             player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost_Basic::OnPlayerRespawnBP(class AGbxPlayerController* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Basic", "OnPlayerRespawnBP");

	Params::GbxGameModeModuleHost_Basic_OnPlayerRespawnBP Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameModeModuleHost_Timer.OnTimerCompletedBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost_Timer::OnTimerCompletedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "OnTimerCompletedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost_Timer.OnTimerEventCompletedBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FName&                      EventName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost_Timer::OnTimerEventCompletedBP(const class FName& EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "OnTimerEventCompletedBP");

	Params::GbxGameModeModuleHost_Timer_OnTimerEventCompletedBP Parms{};

	Parms.EventName = EventName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameModeModuleHost_Timer.OnTimerPausedBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost_Timer::OnTimerPausedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "OnTimerPausedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost_Timer.OnTimerStartedBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost_Timer::OnTimerStartedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "OnTimerStartedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost_Timer.OnTimerUnpausedBP
// (Event, Protected, BlueprintEvent)

void UGbxGameModeModuleHost_Timer::OnTimerUnpausedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "OnTimerUnpausedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxGameModeModuleHost_Timer.PauseTimer
// (Final, Native, Public, BlueprintCallable)

void UGbxGameModeModuleHost_Timer::PauseTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "PauseTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost_Timer.RestartTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewTimeLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeModuleHost_Timer::RestartTimer(int32 NewTimeLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "RestartTimer");

	Params::GbxGameModeModuleHost_Timer_RestartTimer Parms{};

	Parms.NewTimeLimit = NewTimeLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeModuleHost_Timer.UnpauseTimer
// (Final, Native, Public, BlueprintCallable)

void UGbxGameModeModuleHost_Timer::UnpauseTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameModeModuleHost_Timer", "UnpauseTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.ChangePlayerTeam
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     TeamDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::ChangePlayerTeam(class UObject* WorldContext, class APlayerController* PlayerController, FGbxDefPtrProperty_ TeamDef, int32 TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "ChangePlayerTeam");

	Params::GbxGameModeStatics_ChangePlayerTeam Parms{};

	Parms.WorldContext = WorldContext;
	Parms.PlayerController = PlayerController;
	Parms.TeamDef = TeamDef;
	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.EnableModulesWithTags
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxGameModeModuleTags&    tags                                                   (Parm, NativeAccessSpecifierPublic)
// ENexusBitSetOperator                    Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyEnableFirstModule                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::EnableModulesWithTags(class UObject* WorldContext, const struct FGbxGameModeModuleTags& tags, ENexusBitSetOperator Op, bool bEnable, bool bOnlyEnableFirstModule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "EnableModulesWithTags");

	Params::GbxGameModeStatics_EnableModulesWithTags Parms{};

	Parms.WorldContext = WorldContext;
	Parms.tags = std::move(tags);
	Parms.Op = Op;
	Parms.bEnable = bEnable;
	Parms.bOnlyEnableFirstModule = bOnlyEnableFirstModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.EnableModulesWithType
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGbxGameModeModuleHost>type                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyEnableFirstModule                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::EnableModulesWithType(class UObject* WorldContext, TSubclassOf<class UGbxGameModeModuleHost> type, bool bEnable, bool bOnlyEnableFirstModule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "EnableModulesWithType");

	Params::GbxGameModeStatics_EnableModulesWithType Parms{};

	Parms.WorldContext = WorldContext;
	Parms.type = type;
	Parms.bEnable = bEnable;
	Parms.bOnlyEnableFirstModule = bOnlyEnableFirstModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.EnableModuleWithName
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ModuleName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::EnableModuleWithName(class UObject* WorldContext, class FName ModuleName, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "EnableModuleWithName");

	Params::GbxGameModeStatics_EnableModuleWithName Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ModuleName = ModuleName;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.GetGameModeModuleParameter
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxParam                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxParam UGbxGameModeStatics::GetGameModeModuleParameter(class UObject* WorldContext, class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "GetGameModeModuleParameter");

	Params::GbxGameModeStatics_GetGameModeModuleParameter Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeStatics.GetGameModePhase
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGbxDefPtrProperty_ UGbxGameModeStatics::GetGameModePhase(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "GetGameModePhase");

	Params::GbxGameModeStatics_GetGameModePhase Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeStatics.HasGameModeTag
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxGameModeTags&          tags                                                   (Parm, NativeAccessSpecifierPublic)
// ENexusBitSetOperator                    Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxGameModeStatics::HasGameModeTag(class UObject* WorldContext, const struct FGbxGameModeTags& tags, ENexusBitSetOperator Op)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "HasGameModeTag");

	Params::GbxGameModeStatics_HasGameModeTag Parms{};

	Parms.WorldContext = WorldContext;
	Parms.tags = std::move(tags);
	Parms.Op = Op;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameModeStatics.SendEventToModules
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxGameModeModuleEventParams&params                                                 (Parm, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::SendEventToModules(class UObject* WorldContext, FGbxDefPtrProperty_ EventDef, const struct FGbxGameModeModuleEventParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "SendEventToModules");

	Params::GbxGameModeStatics_SendEventToModules Parms{};

	Parms.WorldContext = WorldContext;
	Parms.EventDef = EventDef;
	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.SendEventToModulesWithTags
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxGameModeModuleEventParams&params                                                 (Parm, NativeAccessSpecifierPublic)
// const struct FGbxGameModeModuleTags&    tags                                                   (Parm, NativeAccessSpecifierPublic)
// ENexusBitSetOperator                    Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::SendEventToModulesWithTags(class UObject* WorldContext, FGbxDefPtrProperty_ EventDef, const struct FGbxGameModeModuleEventParams& params, const struct FGbxGameModeModuleTags& tags, ENexusBitSetOperator Op)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "SendEventToModulesWithTags");

	Params::GbxGameModeStatics_SendEventToModulesWithTags Parms{};

	Parms.WorldContext = WorldContext;
	Parms.EventDef = EventDef;
	Parms.params = std::move(params);
	Parms.tags = std::move(tags);
	Parms.Op = Op;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.SendEventToModulesWithType
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxGameModeModuleEventParams&params                                                 (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGbxGameModeModuleHost>type                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::SendEventToModulesWithType(class UObject* WorldContext, FGbxDefPtrProperty_ EventDef, const struct FGbxGameModeModuleEventParams& params, TSubclassOf<class UGbxGameModeModuleHost> type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "SendEventToModulesWithType");

	Params::GbxGameModeStatics_SendEventToModulesWithType Parms{};

	Parms.WorldContext = WorldContext;
	Parms.EventDef = EventDef;
	Parms.params = std::move(params);
	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.SendEventToModuleWithName
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxGameModeModuleEventParams&params                                                 (Parm, NativeAccessSpecifierPublic)
// class FName                             ModuleName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::SendEventToModuleWithName(class UObject* WorldContext, FGbxDefPtrProperty_ EventDef, const struct FGbxGameModeModuleEventParams& params, class FName ModuleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "SendEventToModuleWithName");

	Params::GbxGameModeStatics_SendEventToModuleWithName Parms{};

	Parms.WorldContext = WorldContext;
	Parms.EventDef = EventDef;
	Parms.params = std::move(params);
	Parms.ModuleName = ModuleName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameModeStatics.SetGameModePhase
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     GameModePhase                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGameModeStatics::SetGameModePhase(class UObject* WorldContext, FGbxDefPtrProperty_ GameModePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGameModeStatics", "SetGameModePhase");

	Params::GbxGameModeStatics_SetGameModePhase Parms{};

	Parms.WorldContext = WorldContext;
	Parms.GameModePhase = GameModePhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameplayDirector.OnActiveMissionsChanged
// (Native, Protected, HasDefaults)
// Parameters:
// const struct FSToken&                   mission                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::OnActiveMissionsChanged(const struct FSToken& mission, bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "OnActiveMissionsChanged");

	Params::GbxGameplayDirector_OnActiveMissionsChanged Parms{};

	Parms.mission = std::move(mission);
	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameplayDirector.ReceiveMissionStatusChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMissionStatus                          status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMissionInstanceHandle&    MissionHandle                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::ReceiveMissionStatusChanged(EMissionStatus status, const struct FMissionInstanceHandle& MissionHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "ReceiveMissionStatusChanged");

	Params::GbxGameplayDirector_ReceiveMissionStatusChanged Parms{};

	Parms.status = status;
	Parms.MissionHandle = std::move(MissionHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameplayDirector.ReceivePlayerGroupAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroupState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::ReceivePlayerGroupAdded(class AGbxPlayerGroupState* PlayerGroupState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "ReceivePlayerGroupAdded");

	Params::GbxGameplayDirector_ReceivePlayerGroupAdded Parms{};

	Parms.PlayerGroupState = PlayerGroupState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameplayDirector.ReceivePlayerGroupPlayerAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroupState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::ReceivePlayerGroupPlayerAdded(class AGbxPlayerGroupState* PlayerGroupState, class AGbxPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "ReceivePlayerGroupPlayerAdded");

	Params::GbxGameplayDirector_ReceivePlayerGroupPlayerAdded Parms{};

	Parms.PlayerGroupState = PlayerGroupState;
	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameplayDirector.ReceivePlayerGroupPlayerRemoved
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroupState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::ReceivePlayerGroupPlayerRemoved(class AGbxPlayerGroupState* PlayerGroupState, class AGbxPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "ReceivePlayerGroupPlayerRemoved");

	Params::GbxGameplayDirector_ReceivePlayerGroupPlayerRemoved Parms{};

	Parms.PlayerGroupState = PlayerGroupState;
	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameplayDirector.ReceivePlayerGroupRemoved
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             PlayerGroupState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::ReceivePlayerGroupRemoved(class AGbxPlayerGroupState* PlayerGroupState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "ReceivePlayerGroupRemoved");

	Params::GbxGameplayDirector_ReceivePlayerGroupRemoved Parms{};

	Parms.PlayerGroupState = PlayerGroupState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameplayDirector.ReceivePlayerLogout
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AController*                      Exiting                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::ReceivePlayerLogout(class AController* Exiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "ReceivePlayerLogout");

	Params::GbxGameplayDirector_ReceivePlayerLogout Parms{};

	Parms.Exiting = Exiting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameplayDirector.ReceivePlayerPostLogin
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxGameplayDirector::ReceivePlayerPostLogin(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "ReceivePlayerPostLogin");

	Params::GbxGameplayDirector_ReceivePlayerPostLogin Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGameplayDirector.InstantiateGeneratedMissionForGroup
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, Const)
// Parameters:
// FGameDataHandleProperty_                MissionDef                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionInstanceHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMissionInstanceHandle AGbxGameplayDirector::InstantiateGeneratedMissionForGroup(FGameDataHandleProperty_ MissionDef, const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "InstantiateGeneratedMissionForGroup");

	Params::GbxGameplayDirector_InstantiateGeneratedMissionForGroup Parms{};

	Parms.MissionDef = MissionDef;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameplayDirector.InstantiateGeneratedMissionForPlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, Const)
// Parameters:
// FGameDataHandleProperty_                MissionDef                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionInstanceHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMissionInstanceHandle AGbxGameplayDirector::InstantiateGeneratedMissionForPlayer(FGameDataHandleProperty_ MissionDef, const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameplayDirector", "InstantiateGeneratedMissionForPlayer");

	Params::GbxGameplayDirector_InstantiateGeneratedMissionForPlayer Parms{};

	Parms.MissionDef = MissionDef;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxGameSpawnPoint.OnHasUsers
// (Final, Native, Private)

void AGbxGameSpawnPoint::OnHasUsers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameSpawnPoint", "OnHasUsers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGameSpawnPoint.OnNoUsers
// (Final, Native, Private)

void AGbxGameSpawnPoint::OnNoUsers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGameSpawnPoint", "OnNoUsers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGeometryCollectionScript.OnApplyCollision
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class UGbxGeometryCollectionScriptedComponent*Destructible                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   CollisionSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGeometryCollectionScript::OnApplyCollision(class UGbxGeometryCollectionScriptedComponent* Destructible, const struct FHitResult& HitResult, float CollisionSpeed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGeometryCollectionScript", "OnApplyCollision");

	Params::GbxGeometryCollectionScript_OnApplyCollision Parms{};

	Parms.Destructible = Destructible;
	Parms.HitResult = std::move(HitResult);
	Parms.CollisionSpeed = CollisionSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGeometryCollectionScript.OnApplyHit
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class UGbxGeometryCollectionScriptedComponent*Destructible                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDestructionHitProperties& Properties                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxGeometryCollectionScript::OnApplyHit(class UGbxGeometryCollectionScriptedComponent* Destructible, const struct FDestructionHitProperties& Properties) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGeometryCollectionScript", "OnApplyHit");

	Params::GbxGeometryCollectionScript_OnApplyHit Parms{};

	Parms.Destructible = Destructible;
	Parms.Properties = std::move(Properties);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxGeometryCollectionScriptedComponent.InitNavLink
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxGeometryCollectionComponent*  GeometryCollection                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxNavLinkComponent*             NavLink                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxGeometryCollectionScriptedComponent::InitNavLink(class UGbxGeometryCollectionComponent* GeometryCollection, class UGbxNavLinkComponent* NavLink)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxGeometryCollectionScriptedComponent", "InitNavLink");

	Params::GbxGeometryCollectionScriptedComponent_InitNavLink Parms{};

	Parms.GeometryCollection = GeometryCollection;
	Parms.NavLink = NavLink;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxGeometryCollectionScriptedComponent.OnCollision
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FChaosPhysicsCollisionInfo&CollisionInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxGeometryCollectionScriptedComponent::OnCollision(const struct FChaosPhysicsCollisionInfo& CollisionInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxGeometryCollectionScriptedComponent", "OnCollision");

	Params::GbxGeometryCollectionScriptedComponent_OnCollision Parms{};

	Parms.CollisionInfo = std::move(CollisionInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxInventoryAugmentScript.OnInventoryAugmentCausedDamageConditionMet
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCausedDamageDetails&      Details                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxInventoryAugmentScript::OnInventoryAugmentCausedDamageConditionMet(class AActor* DamagedActor, const struct FCausedDamageDetails& Details)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxInventoryAugmentScript", "OnInventoryAugmentCausedDamageConditionMet");

	Params::GbxInventoryAugmentScript_OnInventoryAugmentCausedDamageConditionMet Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Details = std::move(Details);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxInventoryAugmentScript.OnInventoryAugmentConditionMet
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           EnemyActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxInventoryAugmentScript::OnInventoryAugmentConditionMet(class AActor* EnemyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxInventoryAugmentScript", "OnInventoryAugmentConditionMet");

	Params::GbxInventoryAugmentScript_OnInventoryAugmentConditionMet Parms{};

	Parms.EnemyActor = EnemyActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxInventoryAugmentScript.OnInventoryAugmentEquipped
// (Event, Public, BlueprintEvent)

void UGbxInventoryAugmentScript::OnInventoryAugmentEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxInventoryAugmentScript", "OnInventoryAugmentEquipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxInventoryAugmentScript.OnInventoryAugmentReceivedDamageConditionMet
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FReceivedDamageDetails&    Details                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxInventoryAugmentScript::OnInventoryAugmentReceivedDamageConditionMet(const struct FReceivedDamageDetails& Details)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxInventoryAugmentScript", "OnInventoryAugmentReceivedDamageConditionMet");

	Params::GbxInventoryAugmentScript_OnInventoryAugmentReceivedDamageConditionMet Parms{};

	Parms.Details = std::move(Details);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxInventoryAugmentScript.OnInventoryAugmentRemovalConditionMet
// (Event, Public, BlueprintEvent)

void UGbxInventoryAugmentScript::OnInventoryAugmentRemovalConditionMet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxInventoryAugmentScript", "OnInventoryAugmentRemovalConditionMet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxInventoryAugmentScript.OnInventoryAugmentUnequipped
// (Event, Public, BlueprintEvent)

void UGbxInventoryAugmentScript::OnInventoryAugmentUnequipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxInventoryAugmentScript", "OnInventoryAugmentUnequipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxLevelSequenceActor.OnRep_ReplicatedSettings
// (Final, Native, Protected)

void AGbxLevelSequenceActor::OnRep_ReplicatedSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLevelSequenceActor", "OnRep_ReplicatedSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxLevelSequenceActor.OnRep_ReplicatedTransientBindings
// (Final, Native, Protected)

void AGbxLevelSequenceActor::OnRep_ReplicatedTransientBindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxLevelSequenceActor", "OnRep_ReplicatedTransientBindings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMaterialParamInterpStatics.BreakGbxParamInterpOptions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxMaterialParamInterpOptions&InterpData                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName*                            ParamName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  InterpTime                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            MaterialSlot                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlphaBlendOption*                      CurveOption                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat**                     CustomCurve                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMaterialParamInterpStatics::BreakGbxParamInterpOptions(const struct FGbxMaterialParamInterpOptions& InterpData, class FName* ParamName, float* InterpTime, class FName* MaterialSlot, EAlphaBlendOption* CurveOption, class UCurveFloat** CustomCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMaterialParamInterpStatics", "BreakGbxParamInterpOptions");

	Params::GbxMaterialParamInterpStatics_BreakGbxParamInterpOptions Parms{};

	Parms.InterpData = std::move(InterpData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ParamName != nullptr)
		*ParamName = Parms.ParamName;

	if (InterpTime != nullptr)
		*InterpTime = Parms.InterpTime;

	if (MaterialSlot != nullptr)
		*MaterialSlot = Parms.MaterialSlot;

	if (CurveOption != nullptr)
		*CurveOption = Parms.CurveOption;

	if (CustomCurve != nullptr)
		*CustomCurve = Parms.CustomCurve;
}


// Function GbxGame.GbxMaterialParamInterpStatics.InterpScalar
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxMaterialParamInterpOptions&options                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxMaterialParamInterpStatics::InterpScalar(class UObject* Context, float NewValue, const struct FGbxMaterialParamInterpOptions& options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMaterialParamInterpStatics", "InterpScalar");

	Params::GbxMaterialParamInterpStatics_InterpScalar Parms{};

	Parms.Context = Context;
	Parms.NewValue = NewValue;
	Parms.options = std::move(options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMaterialParamInterpStatics.InterpVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxMaterialParamInterpOptions&options                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxMaterialParamInterpStatics::InterpVector(class UObject* Context, const struct FLinearColor& NewValue, const struct FGbxMaterialParamInterpOptions& options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMaterialParamInterpStatics", "InterpVector");

	Params::GbxMaterialParamInterpStatics_InterpVector Parms{};

	Parms.Context = Context;
	Parms.NewValue = std::move(NewValue);
	Parms.options = std::move(options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMaterialParamInterpStatics.MakeGbxParamInterpOptions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MaterialSlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlphaBlendOption                       CurveOption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      CustomCurve                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxMaterialParamInterpOptions   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGbxMaterialParamInterpOptions UGbxMaterialParamInterpStatics::MakeGbxParamInterpOptions(class FName ParamName, float InterpTime, class FName MaterialSlot, EAlphaBlendOption CurveOption, class UCurveFloat* CustomCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMaterialParamInterpStatics", "MakeGbxParamInterpOptions");

	Params::GbxMaterialParamInterpStatics_MakeGbxParamInterpOptions Parms{};

	Parms.ParamName = ParamName;
	Parms.InterpTime = InterpTime;
	Parms.MaterialSlot = MaterialSlot;
	Parms.CurveOption = CurveOption;
	Parms.CustomCurve = CustomCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxMomentData.GetDialogScriptIdents
// (Final, Native, Public, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UGbxMomentData::GetDialogScriptIdents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMomentData", "GetDialogScriptIdents");

	Params::GbxMomentData_GetDialogScriptIdents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxMomentFunctionLibrary.EndMoment
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxMomentData*                   Moment                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMomentFunctionLibrary::EndMoment(class UObject* WorldContext, class UGbxMomentData* Moment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMomentFunctionLibrary", "EndMoment");

	Params::GbxMomentFunctionLibrary_EndMoment Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Moment = Moment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMomentFunctionLibrary.LoadMoment
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxMomentData*                   Moment                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMomentFunctionLibrary::LoadMoment(class UObject* WorldContext, class UGbxMomentData* Moment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMomentFunctionLibrary", "LoadMoment");

	Params::GbxMomentFunctionLibrary_LoadMoment Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Moment = Moment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMomentFunctionLibrary.RunMoment
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxMomentData*                   Moment                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxGraphParam>&    Parameters                                             (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxMomentFunctionLibrary::RunMoment(class UObject* WorldContext, class UGbxMomentData* Moment, const TArray<struct FGbxGraphParam>& Parameters, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMomentFunctionLibrary", "RunMoment");

	Params::GbxMomentFunctionLibrary_RunMoment Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Moment = Moment;
	Parms.Parameters = std::move(Parameters);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformControllerActor.OnRep_ControlledActor
// (Final, Native, Protected)

void AGbxMovingPlatformControllerActor::OnRep_ControlledActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformControllerActor", "OnRep_ControlledActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformControllerActor.OnRep_SplineTrackActor
// (Final, Native, Protected)

void AGbxMovingPlatformControllerActor::OnRep_SplineTrackActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformControllerActor", "OnRep_SplineTrackActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformControllerActor_DestinationReplication.OnRep_MoveState
// (Final, Native, Protected)

void AGbxMovingPlatformControllerActor_DestinationReplication::OnRep_MoveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformControllerActor_DestinationReplication", "OnRep_MoveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformControllerActor_FullReplicating.OnRep_MoveState
// (Final, Native, Protected)

void AGbxMovingPlatformControllerActor_FullReplicating::OnRep_MoveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxMovingPlatformControllerActor_FullReplicating", "OnRep_MoveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformLibrary.MovePlatformAlongSpline
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           MovingPlatformActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SplineActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMovingPlatformLibrary::MovePlatformAlongSpline(class AActor* MovingPlatformActor, class AActor* SplineActor, float SpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMovingPlatformLibrary", "MovePlatformAlongSpline");

	Params::GbxMovingPlatformLibrary_MovePlatformAlongSpline Parms{};

	Parms.MovingPlatformActor = MovingPlatformActor;
	Parms.SplineActor = SplineActor;
	Parms.SpeedMultiplier = SpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformLibrary.MovePlatformToDestination
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           MovingPlatformActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DestinationIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMovingPlatformLibrary::MovePlatformToDestination(class AActor* MovingPlatformActor, int32 DestinationIndex, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMovingPlatformLibrary", "MovePlatformToDestination");

	Params::GbxMovingPlatformLibrary_MovePlatformToDestination Parms{};

	Parms.MovingPlatformActor = MovingPlatformActor;
	Parms.DestinationIndex = DestinationIndex;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformLibrary.SetMovingPlatformConfig
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           MovingPlatformActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxMovingPlatformConfig&  InConfig                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxMovingPlatformLibrary::SetMovingPlatformConfig(class AActor* MovingPlatformActor, const struct FGbxMovingPlatformConfig& InConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMovingPlatformLibrary", "SetMovingPlatformConfig");

	Params::GbxMovingPlatformLibrary_SetMovingPlatformConfig Parms{};

	Parms.MovingPlatformActor = MovingPlatformActor;
	Parms.InConfig = std::move(InConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformLibrary.SetMovingPlatformDestinationTransform
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           MovingPlatformActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DestinationIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                RelativeTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMovingPlatformLibrary::SetMovingPlatformDestinationTransform(class AActor* MovingPlatformActor, int32 DestinationIndex, const struct FTransform& RelativeTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMovingPlatformLibrary", "SetMovingPlatformDestinationTransform");

	Params::GbxMovingPlatformLibrary_SetMovingPlatformDestinationTransform Parms{};

	Parms.MovingPlatformActor = MovingPlatformActor;
	Parms.DestinationIndex = DestinationIndex;
	Parms.RelativeTransform = std::move(RelativeTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformLibrary.SetMovingPlatformMoveCompleteCallback
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           MovingPlatformActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMovingPlatformLibrary::SetMovingPlatformMoveCompleteCallback(class AActor* MovingPlatformActor, const TDelegate<void()>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMovingPlatformLibrary", "SetMovingPlatformMoveCompleteCallback");

	Params::GbxMovingPlatformLibrary_SetMovingPlatformMoveCompleteCallback Parms{};

	Parms.MovingPlatformActor = MovingPlatformActor;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxMovingPlatformLibrary.SetMovingPlatformMoveSpeed
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGbxMovingPlatformConfig&        Config                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InMoveSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMovingPlatformLibrary::SetMovingPlatformMoveSpeed(struct FGbxMovingPlatformConfig& Config, float InMoveSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMovingPlatformLibrary", "SetMovingPlatformMoveSpeed");

	Params::GbxMovingPlatformLibrary_SetMovingPlatformMoveSpeed Parms{};

	Parms.Config = std::move(Config);
	Parms.InMoveSpeed = InMoveSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Config = std::move(Parms.Config);
}


// Function GbxGame.GbxMovingPlatformLibrary.SetMovingPlatformMoveTime
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGbxMovingPlatformConfig&        Config                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InMoveTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxMovingPlatformLibrary::SetMovingPlatformMoveTime(struct FGbxMovingPlatformConfig& Config, float InMoveTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxMovingPlatformLibrary", "SetMovingPlatformMoveTime");

	Params::GbxMovingPlatformLibrary_SetMovingPlatformMoveTime Parms{};

	Parms.Config = std::move(Config);
	Parms.InMoveTime = InMoveTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Config = std::move(Parms.Config);
}


// Function GbxGame.GbxPlayerBotBlueprintLibrary.IsPlayerBot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxPlayerBotBlueprintLibrary::IsPlayerBot(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxPlayerBotBlueprintLibrary", "IsPlayerBot");

	Params::GbxPlayerBotBlueprintLibrary_IsPlayerBot Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerBotBlueprintLibrary.RemovePlayerBot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxPlayerBotBlueprintLibrary::RemovePlayerBot(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxPlayerBotBlueprintLibrary", "RemovePlayerBot");

	Params::GbxPlayerBotBlueprintLibrary_RemovePlayerBot Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerBotBlueprintLibrary.RemovePlayerBots
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxPlayerBotBlueprintLibrary::RemovePlayerBots(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxPlayerBotBlueprintLibrary", "RemovePlayerBots");

	Params::GbxPlayerBotBlueprintLibrary_RemovePlayerBots Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerBotBlueprintLibrary.SpawnPlayerBot
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnAt                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                CharacterDef                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableSplitscreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGbxCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGbxCharacter* UGbxPlayerBotBlueprintLibrary::SpawnPlayerBot(class UObject* WorldContext, class AActor* SpawnAt, FGameDataHandleProperty_ CharacterDef, const struct FTransform& Transform, bool bEnableSplitscreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxPlayerBotBlueprintLibrary", "SpawnPlayerBot");

	Params::GbxPlayerBotBlueprintLibrary_SpawnPlayerBot Parms{};

	Parms.WorldContext = WorldContext;
	Parms.SpawnAt = SpawnAt;
	Parms.CharacterDef = CharacterDef;
	Parms.Transform = std::move(Transform);
	Parms.bEnableSplitscreen = bEnableSplitscreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerCustomization.ApplyPlayerCustomization
// (Native, Public, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     NewCustomization                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGbxPlayerCustomization::ApplyPlayerCustomization(FGbxDefPtrProperty_ NewCustomization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxPlayerCustomization", "ApplyPlayerCustomization");

	Params::GbxPlayerCustomization_ApplyPlayerCustomization Parms{};

	Parms.NewCustomization = NewCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerCustomization.PrintCustomizationString
// (Native, Public, BlueprintCallable)

void IGbxPlayerCustomization::PrintCustomizationString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxPlayerCustomization", "PrintCustomizationString");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerGroup.GetPlayerStateArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AGbxPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AGbxPlayerState*> AGbxPlayerGroup::GetPlayerStateArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerGroup", "GetPlayerStateArray");

	Params::GbxPlayerGroup_GetPlayerStateArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerGroupState.OnGroupAdded
// (Event, Public, BlueprintEvent)

void AGbxPlayerGroupState::OnGroupAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerGroupState", "OnGroupAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxPlayerGroupState.OnGroupRemoved
// (Event, Public, BlueprintEvent)

void AGbxPlayerGroupState::OnGroupRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerGroupState", "OnGroupRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxPlayerGroupState.OnPlayerAdded
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGbxPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerGroupState::OnPlayerAdded(class AGbxPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerGroupState", "OnPlayerAdded");

	Params::GbxPlayerGroupState_OnPlayerAdded Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxPlayerGroupState.OnPlayerRemoved
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGbxPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerGroupState::OnPlayerRemoved(class AGbxPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerGroupState", "OnPlayerRemoved");

	Params::GbxPlayerGroupState_OnPlayerRemoved Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxPlayerGroupState.OnRep_StableIndex
// (Final, Native, Private)

void AGbxPlayerGroupState::OnRep_StableIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerGroupState", "OnRep_StableIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerGroupState.GetPlayerStateArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AGbxPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AGbxPlayerState*> AGbxPlayerGroupState::GetPlayerStateArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerGroupState", "GetPlayerStateArray");

	Params::GbxPlayerGroupState_GetPlayerStateArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerState.ClientLockUnlockable
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// const struct FSName&                    LedgerIdent                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSName&                    EntryIdent                                             (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::ClientLockUnlockable(const struct FSName& LedgerIdent, const struct FSName& EntryIdent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "ClientLockUnlockable");

	Params::GbxPlayerState_ClientLockUnlockable Parms{};

	Parms.LedgerIdent = std::move(LedgerIdent);
	Parms.EntryIdent = std::move(EntryIdent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.ClientSendProfileDataToVault
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// int32                                   InProfileIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::ClientSendProfileDataToVault(int32 InProfileIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "ClientSendProfileDataToVault");

	Params::GbxPlayerState_ClientSendProfileDataToVault Parms{};

	Parms.InProfileIndex = InProfileIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.ClientUnlockUnlockable
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// const struct FSName&                    LedgerIdent                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSName&                    EntryIdent                                             (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::ClientUnlockUnlockable(const struct FSName& LedgerIdent, const struct FSName& EntryIdent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "ClientUnlockUnlockable");

	Params::GbxPlayerState_ClientUnlockUnlockable Parms{};

	Parms.LedgerIdent = std::move(LedgerIdent);
	Parms.EntryIdent = std::move(EntryIdent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.OnGroupAssigned
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             InPlayerGroupState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::OnGroupAssigned(class AGbxPlayerGroupState* InPlayerGroupState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "OnGroupAssigned");

	Params::GbxPlayerState_OnGroupAssigned Parms{};

	Parms.InPlayerGroupState = InPlayerGroupState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxPlayerState.OnGroupRemoved
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGbxPlayerGroupState*             InPlayerGroupState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::OnGroupRemoved(class AGbxPlayerGroupState* InPlayerGroupState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "OnGroupRemoved");

	Params::GbxPlayerState_OnGroupRemoved Parms{};

	Parms.InPlayerGroupState = InPlayerGroupState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxPlayerState.OnRep_CharacterDef
// (Final, Native, Private)

void AGbxPlayerState::OnRep_CharacterDef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "OnRep_CharacterDef");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.OnRep_PlatformUniqueId
// (Final, Native, Public)

void AGbxPlayerState::OnRep_PlatformUniqueId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "OnRep_PlatformUniqueId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.OnRep_PlayerGroupState
// (Final, Native, Private)

void AGbxPlayerState::OnRep_PlayerGroupState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "OnRep_PlayerGroupState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.OnRep_SeamlessTravelTransferKey
// (Final, Native, Private)

void AGbxPlayerState::OnRep_SeamlessTravelTransferKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "OnRep_SeamlessTravelTransferKey");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.OnRep_StableIndex
// (Final, Native, Private)

void AGbxPlayerState::OnRep_StableIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "OnRep_StableIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.ServerSetDiscoveryRegion
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// const struct FSName&                    InRegionName                                           (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::ServerSetDiscoveryRegion(const struct FSName& InRegionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "ServerSetDiscoveryRegion");

	Params::GbxPlayerState_ServerSetDiscoveryRegion Parms{};

	Parms.InRegionName = std::move(InRegionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.ServerSetPlatformUniqueId
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FUniqueNetIdRepl&          InPlatformUniqueId                                     (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::ServerSetPlatformUniqueId(const struct FUniqueNetIdRepl& InPlatformUniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "ServerSetPlatformUniqueId");

	Params::GbxPlayerState_ServerSetPlatformUniqueId Parms{};

	Parms.InPlatformUniqueId = std::move(InPlatformUniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerState.ServerSetRealtimeGameplayStatus
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bIsInRTGP                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxPlayerState::ServerSetRealtimeGameplayStatus(bool bIsInRTGP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxPlayerState", "ServerSetRealtimeGameplayStatus");

	Params::GbxPlayerState_ServerSetRealtimeGameplayStatus Parms{};

	Parms.bIsInRTGP = bIsInRTGP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxPlayerUtilsBlueprintLibrary.GetPlayerController
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UGbxPlayerUtilsBlueprintLibrary::GetPlayerController(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxPlayerUtilsBlueprintLibrary", "GetPlayerController");

	Params::GbxPlayerUtilsBlueprintLibrary_GetPlayerController Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerUtilsBlueprintLibrary.GetPlayerState
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* UGbxPlayerUtilsBlueprintLibrary::GetPlayerState(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxPlayerUtilsBlueprintLibrary", "GetPlayerState");

	Params::GbxPlayerUtilsBlueprintLibrary_GetPlayerState Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxPlayerUtilsBlueprintLibrary.IsPlayerControlled
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxPlayerUtilsBlueprintLibrary::IsPlayerControlled(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxPlayerUtilsBlueprintLibrary", "IsPlayerControlled");

	Params::GbxPlayerUtilsBlueprintLibrary_IsPlayerControlled Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgressGraph.Server_ActivateNodeInGroup
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   InGroupIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNodeIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InActivate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActivationLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxProgressGraph::Server_ActivateNodeInGroup(int32 InGroupIndex, int32 InNodeIndex, bool InActivate, int32 ActivationLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProgressGraph", "Server_ActivateNodeInGroup");

	Params::GbxProgressGraph_Server_ActivateNodeInGroup Parms{};

	Parms.InGroupIndex = InGroupIndex;
	Parms.InNodeIndex = InNodeIndex;
	Parms.InActivate = InActivate;
	Parms.ActivationLevel = ActivationLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgressGraph.Server_AddBonusPoints
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   InNodeIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPointsToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxProgressGraph::Server_AddBonusPoints(int32 InNodeIndex, int32 InPointsToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProgressGraph", "Server_AddBonusPoints");

	Params::GbxProgressGraph_Server_AddBonusPoints Parms{};

	Parms.InNodeIndex = InNodeIndex;
	Parms.InPointsToAdd = InPointsToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgressGraph.Server_ResetActivations
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UGbxProgressGraph::Server_ResetActivations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProgressGraph", "Server_ResetActivations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgressGraph.Server_ResetActivationsInGroup
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   InGroupIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxProgressGraph::Server_ResetActivationsInGroup(int32 InGroupIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProgressGraph", "Server_ResetActivationsInGroup");

	Params::GbxProgressGraph_Server_ResetActivationsInGroup Parms{};

	Parms.InGroupIndex = InGroupIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgressGraph.Server_ResetSpentPoints
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UGbxProgressGraph::Server_ResetSpentPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProgressGraph", "Server_ResetSpentPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgressGraph.Server_SpendProgressPoints
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   InNodeIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPoints                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxProgressGraph::Server_SpendProgressPoints(int32 InNodeIndex, int32 InPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProgressGraph", "Server_SpendProgressPoints");

	Params::GbxProgressGraph_Server_SpendProgressPoints Parms{};

	Parms.InNodeIndex = InNodeIndex;
	Parms.InPoints = InPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgressionDataManager.ServerResetProgressState
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxProgressionDataManager::ServerResetProgressState(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxProgressionDataManager", "ServerResetProgressState");

	Params::GbxProgressionDataManager_ServerResetProgressState Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.AreProgressGraphGroupMaxNodesActivated
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxUnlockableGroupRef&    GraphGroup                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::AreProgressGraphGroupMaxNodesActivated(const struct FGbxUnlockableGroupRef& GraphGroup, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "AreProgressGraphGroupMaxNodesActivated");

	Params::GbxProgression_BlueprintFunctions_AreProgressGraphGroupMaxNodesActivated Parms{};

	Parms.GraphGroup = std::move(GraphGroup);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.AreProgressGraphGroupMaxNodesActivatedPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableGroupRef&    GraphGroup                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::AreProgressGraphGroupMaxNodesActivatedPure(const struct FGbxUnlockableGroupRef& GraphGroup, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "AreProgressGraphGroupMaxNodesActivatedPure");

	Params::GbxProgression_BlueprintFunctions_AreProgressGraphGroupMaxNodesActivatedPure Parms{};

	Parms.GraphGroup = std::move(GraphGroup);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.GetProgressGraphGroupTotalPoints
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxUnlockableGroupRef&    GraphGroup                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxProgression_BlueprintFunctions::GetProgressGraphGroupTotalPoints(const struct FGbxUnlockableGroupRef& GraphGroup, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "GetProgressGraphGroupTotalPoints");

	Params::GbxProgression_BlueprintFunctions_GetProgressGraphGroupTotalPoints Parms{};

	Parms.GraphGroup = std::move(GraphGroup);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.GetProgressGraphGroupTotalPointsPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableGroupRef&    GraphGroup                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxProgression_BlueprintFunctions::GetProgressGraphGroupTotalPointsPure(const struct FGbxUnlockableGroupRef& GraphGroup, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "GetProgressGraphGroupTotalPointsPure");

	Params::GbxProgression_BlueprintFunctions_GetProgressGraphGroupTotalPointsPure Parms{};

	Parms.GraphGroup = std::move(GraphGroup);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.GetProgressGraphNodeActivationLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxProgression_BlueprintFunctions::GetProgressGraphNodeActivationLevel(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "GetProgressGraphNodeActivationLevel");

	Params::GbxProgression_BlueprintFunctions_GetProgressGraphNodeActivationLevel Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.GetProgressGraphNodeActivationLevelPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxProgression_BlueprintFunctions::GetProgressGraphNodeActivationLevelPure(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "GetProgressGraphNodeActivationLevelPure");

	Params::GbxProgression_BlueprintFunctions_GetProgressGraphNodeActivationLevelPure Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.GetProgressGraphNodeTotalPoints
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxProgression_BlueprintFunctions::GetProgressGraphNodeTotalPoints(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "GetProgressGraphNodeTotalPoints");

	Params::GbxProgression_BlueprintFunctions_GetProgressGraphNodeTotalPoints Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.GetProgressGraphNodeTotalPointsPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxProgression_BlueprintFunctions::GetProgressGraphNodeTotalPointsPure(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "GetProgressGraphNodeTotalPointsPure");

	Params::GbxProgression_BlueprintFunctions_GetProgressGraphNodeTotalPointsPure Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.IsProgressGraphGroupUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxUnlockableGroupRef&    GraphGroup                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::IsProgressGraphGroupUnlocked(const struct FGbxUnlockableGroupRef& GraphGroup, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "IsProgressGraphGroupUnlocked");

	Params::GbxProgression_BlueprintFunctions_IsProgressGraphGroupUnlocked Parms{};

	Parms.GraphGroup = std::move(GraphGroup);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.IsProgressGraphGroupUnlockedPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableGroupRef&    GraphGroup                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::IsProgressGraphGroupUnlockedPure(const struct FGbxUnlockableGroupRef& GraphGroup, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "IsProgressGraphGroupUnlockedPure");

	Params::GbxProgression_BlueprintFunctions_IsProgressGraphGroupUnlockedPure Parms{};

	Parms.GraphGroup = std::move(GraphGroup);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.IsProgressGraphNodeActivated
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::IsProgressGraphNodeActivated(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "IsProgressGraphNodeActivated");

	Params::GbxProgression_BlueprintFunctions_IsProgressGraphNodeActivated Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.IsProgressGraphNodeActivatedPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::IsProgressGraphNodeActivatedPure(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "IsProgressGraphNodeActivatedPure");

	Params::GbxProgression_BlueprintFunctions_IsProgressGraphNodeActivatedPure Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.IsProgressGraphNodeUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::IsProgressGraphNodeUnlocked(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "IsProgressGraphNodeUnlocked");

	Params::GbxProgression_BlueprintFunctions_IsProgressGraphNodeUnlocked Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.IsProgressGraphNodeUnlockedPure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxProgression_BlueprintFunctions::IsProgressGraphNodeUnlockedPure(const struct FGbxUnlockableNodeRef& GraphNode, class UObject* OwnerContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "IsProgressGraphNodeUnlockedPure");

	Params::GbxProgression_BlueprintFunctions_IsProgressGraphNodeUnlockedPure Parms{};

	Parms.GraphNode = std::move(GraphNode);
	Parms.OwnerContext = OwnerContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.MakeGbxProgressGraphGroupNodeRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableGroupNodeRef&GraphGroupNode                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxUnlockableGroupNodeRef       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGbxUnlockableGroupNodeRef UGbxProgression_BlueprintFunctions::MakeGbxProgressGraphGroupNodeRef(const struct FGbxUnlockableGroupNodeRef& GraphGroupNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "MakeGbxProgressGraphGroupNodeRef");

	Params::GbxProgression_BlueprintFunctions_MakeGbxProgressGraphGroupNodeRef Parms{};

	Parms.GraphGroupNode = std::move(GraphGroupNode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.MakeGbxProgressGraphGroupRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableGroupRef&    GraphGroup                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxUnlockableGroupRef           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGbxUnlockableGroupRef UGbxProgression_BlueprintFunctions::MakeGbxProgressGraphGroupRef(const struct FGbxUnlockableGroupRef& GraphGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "MakeGbxProgressGraphGroupRef");

	Params::GbxProgression_BlueprintFunctions_MakeGbxProgressGraphGroupRef Parms{};

	Parms.GraphGroup = std::move(GraphGroup);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.MakeGbxProgressGraphNodeRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxUnlockableNodeRef&     GraphNode                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxUnlockableNodeRef            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGbxUnlockableNodeRef UGbxProgression_BlueprintFunctions::MakeGbxProgressGraphNodeRef(const struct FGbxUnlockableNodeRef& GraphNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "MakeGbxProgressGraphNodeRef");

	Params::GbxProgression_BlueprintFunctions_MakeGbxProgressGraphNodeRef Parms{};

	Parms.GraphNode = std::move(GraphNode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxProgression_BlueprintFunctions.MakeGbxProgressPointsAmount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxProgressPointsAmount&  Amount                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGbxProgressPointsAmount         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGbxProgressPointsAmount UGbxProgression_BlueprintFunctions::MakeGbxProgressPointsAmount(const struct FGbxProgressPointsAmount& Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxProgression_BlueprintFunctions", "MakeGbxProgressPointsAmount");

	Params::GbxProgression_BlueprintFunctions_MakeGbxProgressPointsAmount Parms{};

	Parms.Amount = std::move(Amount);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSequenceBlueprintLibrary.IsPlayingGbxSequence
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSequence*                     GbxSequence                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSequenceBlueprintLibrary::IsPlayingGbxSequence(class AActor* Actor, class UGbxSequence* GbxSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSequenceBlueprintLibrary", "IsPlayingGbxSequence");

	Params::GbxSequenceBlueprintLibrary_IsPlayingGbxSequence Parms{};

	Parms.Actor = Actor;
	Parms.GbxSequence = GbxSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSequenceBlueprintLibrary.PlayGbxSequence
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSequence*                     GbxSequence                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxSequencePlaybackSettings&PlaybackSettings                                       (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void UGbxSequenceBlueprintLibrary::PlayGbxSequence(class AActor* Actor, class UGbxSequence* GbxSequence, const struct FGbxSequencePlaybackSettings& PlaybackSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSequenceBlueprintLibrary", "PlayGbxSequence");

	Params::GbxSequenceBlueprintLibrary_PlayGbxSequence Parms{};

	Parms.Actor = Actor;
	Parms.GbxSequence = GbxSequence;
	Parms.PlaybackSettings = std::move(PlaybackSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSequenceBlueprintLibrary.StopGbxSequence
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSequenceBlueprintLibrary::StopGbxSequence(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSequenceBlueprintLibrary", "StopGbxSequence");

	Params::GbxSequenceBlueprintLibrary_StopGbxSequence Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkill.GetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxSkill::GetActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkill", "GetActor");

	Params::GbxSkill_GetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillActionExceptionHandler.BreakActionException
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGbxSkillActionException&  InActionException                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EGbxSkillActionExecType*                ExecType                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxSkillActionExceptionType*           ExceptionType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExceptionHandler::BreakActionException(const struct FGbxSkillActionException& InActionException, EGbxSkillActionExecType* ExecType, EGbxSkillActionExceptionType* ExceptionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillActionExceptionHandler", "BreakActionException");

	Params::GbxSkillActionExceptionHandler_BreakActionException Parms{};

	Parms.InActionException = std::move(InActionException);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ExecType != nullptr)
		*ExecType = Parms.ExecType;

	if (ExceptionType != nullptr)
		*ExceptionType = Parms.ExceptionType;
}


// Function GbxGame.GbxSkillActionExceptionHandler.HandleException
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FGbxSkillActionException&  Exception                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxSkillActionExceptionHandler::HandleException(const struct FGbxSkillActionException& Exception) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExceptionHandler", "HandleException");

	Params::GbxSkillActionExceptionHandler_HandleException Parms{};

	Parms.Exception = std::move(Exception);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxSkillActionExceptionHandler.IsSkillConditionEnabled
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGbxSkillActionException&  Exception                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     ConditionDef                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillActionExceptionHandler::IsSkillConditionEnabled(const struct FGbxSkillActionException& Exception, FGbxDefPtrProperty_ ConditionDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExceptionHandler", "IsSkillConditionEnabled");

	Params::GbxSkillActionExceptionHandler_IsSkillConditionEnabled Parms{};

	Parms.Exception = std::move(Exception);
	Parms.ConditionDef = ConditionDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillActionExceptionHandler.IsSkillStateEnabled
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGbxSkillActionException&  Exception                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     StateDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillActionExceptionHandler::IsSkillStateEnabled(const struct FGbxSkillActionException& Exception, FGbxDefPtrProperty_ StateDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExceptionHandler", "IsSkillStateEnabled");

	Params::GbxSkillActionExceptionHandler_IsSkillStateEnabled Parms{};

	Parms.Exception = std::move(Exception);
	Parms.StateDef = StateDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillActionExceptionHandler.K2_SkillConditionBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const struct FGbxSkillActionException&  Exception                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     ConditionDef                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExceptionHandler::K2_SkillConditionBranch(const struct FGbxSkillActionException& Exception, FGbxDefPtrProperty_ ConditionDef, ESkillStateScriptExec* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExceptionHandler", "K2_SkillConditionBranch");

	Params::GbxSkillActionExceptionHandler_K2_SkillConditionBranch Parms{};

	Parms.Exception = std::move(Exception);
	Parms.ConditionDef = ConditionDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillActionExceptionHandler.K2_SkillStateBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const struct FGbxSkillActionException&  Exception                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     StateDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExceptionHandler::K2_SkillStateBranch(const struct FGbxSkillActionException& Exception, FGbxDefPtrProperty_ StateDef, ESkillStateScriptExec* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExceptionHandler", "K2_SkillStateBranch");

	Params::GbxSkillActionExceptionHandler_K2_SkillStateBranch Parms{};

	Parms.Exception = std::move(Exception);
	Parms.StateDef = StateDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillActionExceptionHandler.PlayActionGroup
// (Final, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const struct FGbxSkillActionException&  InActionException                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillActionExceptionHandler::PlayActionGroup(const struct FGbxSkillActionException& InActionException, class FName GroupName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillActionExceptionHandler", "PlayActionGroup");

	Params::GbxSkillActionExceptionHandler_PlayActionGroup Parms{};

	Parms.InActionException = std::move(InActionException);
	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillActionExecHandlerWriter_ControlledMove.WriteParams_ControlledMove
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillActionExecHandler*       Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxSkillActionItem_ControlledMove_Params&params                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxSkillActionExecHandlerWriter_ControlledMove::WriteParams_ControlledMove(class UGbxSkillActionExecHandler* Context, const struct FGbxSkillActionItem_ControlledMove_Params& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillActionExecHandlerWriter_ControlledMove", "WriteParams_ControlledMove");

	Params::GbxSkillActionExecHandlerWriter_ControlledMove_WriteParams_ControlledMove Parms{};

	Parms.Context = Context;
	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_AOE_Gps.SetQueryOwner
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           QueryOwner                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_AOE_Gps::SetQueryOwner(const struct FGbxSkillComponentReference& ComponentReference, class AActor* QueryOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillComponentFunctions_AOE_Gps", "SetQueryOwner");

	Params::GbxSkillComponentFunctions_AOE_Gps_SetQueryOwner Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.QueryOwner = QueryOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_Library.GetEntryValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             EntryName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxParam                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxParam UGbxSkillComponentFunctions_Library::GetEntryValue(const struct FGbxSkillComponentReference& ComponentReference, class FName EntryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_Library", "GetEntryValue");

	Params::GbxSkillComponentFunctions_Library_GetEntryValue Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.EntryName = EntryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillLibraryStatics.GetLibraryEntryValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     ComponentIdentifier                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EntryName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxParam                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGbxParam UGbxSkillLibraryStatics::GetLibraryEntryValue(class UObject* Context, FGbxDefPtrProperty_ SkillDef, FGbxDefPtrProperty_ ComponentIdentifier, class FName EntryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillLibraryStatics", "GetLibraryEntryValue");

	Params::GbxSkillLibraryStatics_GetLibraryEntryValue Parms{};

	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.ComponentIdentifier = ComponentIdentifier;
	Parms.EntryName = EntryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillComponentFunctions_ResourcePool.DrainPercentage
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ResourcePool                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinPercentage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_ResourcePool::DrainPercentage(const struct FGbxSkillComponentReference& ComponentReference, FGameDataHandleProperty_ ResourcePool, float Percentage, float MinPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_ResourcePool", "DrainPercentage");

	Params::GbxSkillComponentFunctions_ResourcePool_DrainPercentage Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.ResourcePool = ResourcePool;
	Parms.Percentage = Percentage;
	Parms.MinPercentage = MinPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_ResourcePool.GetCurrentPercentage
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ResourcePool                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxSkillComponentFunctions_ResourcePool::GetCurrentPercentage(const struct FGbxSkillComponentReference& ComponentReference, FGameDataHandleProperty_ ResourcePool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_ResourcePool", "GetCurrentPercentage");

	Params::GbxSkillComponentFunctions_ResourcePool_GetCurrentPercentage Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.ResourcePool = ResourcePool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillComponentFunctions_ResourcePool.GetCurrentValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ResourcePool                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxSkillComponentFunctions_ResourcePool::GetCurrentValue(const struct FGbxSkillComponentReference& ComponentReference, FGameDataHandleProperty_ ResourcePool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_ResourcePool", "GetCurrentValue");

	Params::GbxSkillComponentFunctions_ResourcePool_GetCurrentValue Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.ResourcePool = ResourcePool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillComponentFunctions_ResourcePool.GetMaxValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ResourcePool                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxSkillComponentFunctions_ResourcePool::GetMaxValue(const struct FGbxSkillComponentReference& ComponentReference, FGameDataHandleProperty_ ResourcePool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_ResourcePool", "GetMaxValue");

	Params::GbxSkillComponentFunctions_ResourcePool_GetMaxValue Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.ResourcePool = ResourcePool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillComponentFunctions_ResourcePool.RefillPercentage
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ResourcePool                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPercentage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_ResourcePool::RefillPercentage(const struct FGbxSkillComponentReference& ComponentReference, FGameDataHandleProperty_ ResourcePool, float Percentage, float MaxPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_ResourcePool", "RefillPercentage");

	Params::GbxSkillComponentFunctions_ResourcePool_RefillPercentage Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.ResourcePool = ResourcePool;
	Parms.Percentage = Percentage;
	Parms.MaxPercentage = MaxPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_ResourcePool.SetCurrentPercentage
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ResourcePool                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_ResourcePool::SetCurrentPercentage(const struct FGbxSkillComponentReference& ComponentReference, FGameDataHandleProperty_ ResourcePool, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_ResourcePool", "SetCurrentPercentage");

	Params::GbxSkillComponentFunctions_ResourcePool_SetCurrentPercentage Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.ResourcePool = ResourcePool;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_ResourcePool.SetCurrentValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ResourcePool                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_ResourcePool::SetCurrentValue(const struct FGbxSkillComponentReference& ComponentReference, FGameDataHandleProperty_ ResourcePool, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_ResourcePool", "SetCurrentValue");

	Params::GbxSkillComponentFunctions_ResourcePool_SetCurrentValue Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.ResourcePool = ResourcePool;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_TimerEx.AdjustTimer
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGuid&                     TimerID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Adjustment                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_TimerEx::AdjustTimer(const struct FGbxSkillComponentReference& ComponentReference, const struct FGuid& TimerID, float Adjustment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_TimerEx", "AdjustTimer");

	Params::GbxSkillComponentFunctions_TimerEx_AdjustTimer Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.TimerID = std::move(TimerID);
	Parms.Adjustment = Adjustment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_TimerEx.DoTimerAction
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EGbxSkillComponentTimerAction           TimerAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     TimerID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillComponentFunctions_TimerEx::DoTimerAction(const struct FGbxSkillComponentReference& ComponentReference, EGbxSkillComponentTimerAction TimerAction, const struct FGuid& TimerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_TimerEx", "DoTimerAction");

	Params::GbxSkillComponentFunctions_TimerEx_DoTimerAction Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.TimerAction = TimerAction;
	Parms.TimerID = std::move(TimerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillComponentFunctions_TimerEx.GetTimerStats
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGbxSkillComponentReference&ComponentReference                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGuid&                     TimerID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxSkillComponentTimerStats     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGbxSkillComponentTimerStats UGbxSkillComponentFunctions_TimerEx::GetTimerStats(const struct FGbxSkillComponentReference& ComponentReference, const struct FGuid& TimerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillComponentFunctions_TimerEx", "GetTimerStats");

	Params::GbxSkillComponentFunctions_TimerEx_GetTimerStats Parms{};

	Parms.ComponentReference = std::move(ComponentReference);
	Parms.TimerID = std::move(TimerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.ClearSkillEffects
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Effect                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeRoot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::ClearSkillEffects(class UGbxSkillScript* Context, FGbxDefPtrProperty_ Effect, bool bIncludeRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillScript", "ClearSkillEffects");

	Params::GbxSkillScript_ClearSkillEffects Parms{};

	Parms.Context = Context;
	Parms.Effect = Effect;
	Parms.bIncludeRoot = bIncludeRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.SetSkillEffect
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Effect                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::SetSkillEffect(class UGbxSkillScript* Context, FGbxDefPtrProperty_ Effect, class FName reason, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillScript", "SetSkillEffect");

	Params::GbxSkillScript_SetSkillEffect Parms{};

	Parms.Context = Context;
	Parms.Effect = Effect;
	Parms.reason = reason;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.SetSkillState
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGbxSkillScript*                  Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecursive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::SetSkillState(class UGbxSkillScript* Context, FGameDataHandleProperty_ State, bool bEnabled, bool bRecursive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillScript", "SetSkillState");

	Params::GbxSkillScript_SetSkillState Parms{};

	Parms.Context = Context;
	Parms.State = State;
	Parms.bEnabled = bEnabled;
	Parms.bRecursive = bRecursive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.FireSkillEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::FireSkillEvent(FGbxDefPtrProperty_ EventDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "FireSkillEvent");

	Params::GbxSkillScript_FireSkillEvent Parms{};

	Parms.EventDef = EventDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_ClearRegister
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     Register                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_ClearRegister(FGbxDefPtrProperty_ Register)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_ClearRegister");

	Params::GbxSkillScript_K2_ClearRegister Parms{};

	Parms.Register = Register;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_FireResourceGroupEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     GroupDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_FireResourceGroupEvent(FGbxDefPtrProperty_ GroupDef, class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_FireResourceGroupEvent");

	Params::GbxSkillScript_K2_FireResourceGroupEvent Parms{};

	Parms.GroupDef = GroupDef;
	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_IsAuthorityBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EGbxSkillGeneralYesNo*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_IsAuthorityBranch(EGbxSkillGeneralYesNo* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_IsAuthorityBranch");

	Params::GbxSkillScript_K2_IsAuthorityBranch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillScript.K2_LatentGuard
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                StateDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_LatentGuard(FGameDataHandleProperty_ StateDef, ESkillStateScriptExec* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_LatentGuard");

	Params::GbxSkillScript_K2_LatentGuard Parms{};

	Parms.StateDef = StateDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillScript.K2_LocallyControlledBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EGbxSkillGeneralYesNo*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_LocallyControlledBranch(EGbxSkillGeneralYesNo* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_LocallyControlledBranch");

	Params::GbxSkillScript_K2_LocallyControlledBranch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillScript.K2_OnBegin
// (Event, Protected, BlueprintEvent)

void UGbxSkillScript::K2_OnBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_OnBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxSkillScript.K2_OnEnd
// (Event, Protected, BlueprintEvent)

void UGbxSkillScript::K2_OnEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_OnEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxSkillScript.K2_PopStateMachineRegister
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     Register                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_PopStateMachineRegister(FGbxDefPtrProperty_ Register)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_PopStateMachineRegister");

	Params::GbxSkillScript_K2_PopStateMachineRegister Parms{};

	Parms.Register = Register;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_PushStateMachineRegister
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     Register                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_PushStateMachineRegister(FGbxDefPtrProperty_ Register)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_PushStateMachineRegister");

	Params::GbxSkillScript_K2_PushStateMachineRegister Parms{};

	Parms.Register = Register;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_ResetRegisters
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)

void UGbxSkillScript::K2_ResetRegisters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_ResetRegisters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_ResetSkillActionSequence
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SequenceID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_ResetSkillActionSequence(int32 SequenceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_ResetSkillActionSequence");

	Params::GbxSkillScript_K2_ResetSkillActionSequence Parms{};

	Parms.SequenceID = SequenceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_SkillConditionBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     ConditionDef                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_SkillConditionBranch(FGbxDefPtrProperty_ ConditionDef, ESkillStateScriptExec* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_SkillConditionBranch");

	Params::GbxSkillScript_K2_SkillConditionBranch Parms{};

	Parms.ConditionDef = ConditionDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillScript.K2_SkillMachineRegisterBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// FGbxDefPtrProperty_                     RegisterDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_SkillMachineRegisterBranch(FGbxDefPtrProperty_ RegisterDef, ESkillStateScriptExec* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_SkillMachineRegisterBranch");

	Params::GbxSkillScript_K2_SkillMachineRegisterBranch Parms{};

	Parms.RegisterDef = RegisterDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillScript.K2_SkillStateBranch
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                StateDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillStateScriptExec*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_SkillStateBranch(FGameDataHandleProperty_ StateDef, ESkillStateScriptExec* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_SkillStateBranch");

	Params::GbxSkillScript_K2_SkillStateBranch Parms{};

	Parms.StateDef = StateDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillScript.K2_StartSkillAction
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ActionID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Exec                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_StartSkillAction(int32 ActionID, class FName Exec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_StartSkillAction");

	Params::GbxSkillScript_K2_StartSkillAction Parms{};

	Parms.ActionID = ActionID;
	Parms.Exec = Exec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_StartSkillActionSequence
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SequenceID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Exec                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_StartSkillActionSequence(int32 SequenceID, class FName Exec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_StartSkillActionSequence");

	Params::GbxSkillScript_K2_StartSkillActionSequence Parms{};

	Parms.SequenceID = SequenceID;
	Parms.Exec = Exec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.K2_StopSkillActions
// (Final, BlueprintAuthorityOnly, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxSkillStopActionSpec&   InSpec                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxSkillScript::K2_StopSkillActions(const struct FGbxSkillStopActionSpec& InSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_StopSkillActions");

	Params::GbxSkillScript_K2_StopSkillActions Parms{};

	Parms.InSpec = std::move(InSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillScript.GetMachineRegisterStackCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGbxDefPtrProperty_                     RegisterDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxSkillScript::GetMachineRegisterStackCount(FGbxDefPtrProperty_ RegisterDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "GetMachineRegisterStackCount");

	Params::GbxSkillScript_GetMachineRegisterStackCount Parms{};

	Parms.RegisterDef = RegisterDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.GetMachineRegisterStackCountPercent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGbxDefPtrProperty_                     RegisterDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MAX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInvert                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxSkillScript::GetMachineRegisterStackCountPercent(FGbxDefPtrProperty_ RegisterDef, int32 MAX, bool bInvert) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "GetMachineRegisterStackCountPercent");

	Params::GbxSkillScript_GetMachineRegisterStackCountPercent Parms{};

	Parms.RegisterDef = RegisterDef;
	Parms.MAX = MAX;
	Parms.bInvert = bInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxSkillScript::GetOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "GetOwner");

	Params::GbxSkillScript_GetOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.IsRegisterSet
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGbxDefPtrProperty_                     RegisterDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillScript::IsRegisterSet(FGbxDefPtrProperty_ RegisterDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "IsRegisterSet");

	Params::GbxSkillScript_IsRegisterSet Parms{};

	Parms.RegisterDef = RegisterDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.IsSkillConditionEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGbxDefPtrProperty_                     ConditionDef                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillScript::IsSkillConditionEnabled(FGbxDefPtrProperty_ ConditionDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "IsSkillConditionEnabled");

	Params::GbxSkillScript_IsSkillConditionEnabled Parms{};

	Parms.ConditionDef = ConditionDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.IsSkillStateEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGameDataHandleProperty_                StateDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillScript::IsSkillStateEnabled(FGameDataHandleProperty_ StateDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "IsSkillStateEnabled");

	Params::GbxSkillScript_IsSkillStateEnabled Parms{};

	Parms.StateDef = StateDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.K2_HasAuthority
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillScript::K2_HasAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_HasAuthority");

	Params::GbxSkillScript_K2_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.K2_HasManagedResources
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGbxDefPtrProperty_                     GroupDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillScript::K2_HasManagedResources(FGbxDefPtrProperty_ GroupDef) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_HasManagedResources");

	Params::GbxSkillScript_K2_HasManagedResources Parms{};

	Parms.GroupDef = GroupDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillScript.K2_IsLocallyControlled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillScript::K2_IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillScript", "K2_IsLocallyControlled");

	Params::GbxSkillScript_K2_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillSocketResolverStrategy.Resolve
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UGbxSkillSocketResolverStrategy::Resolve(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSkillSocketResolverStrategy", "Resolve");

	Params::GbxSkillSocketResolverStrategy_Resolve Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillStatics.AddSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSkill*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxSkill* UGbxSkillStatics::AddSkill(class UObject* target, FGameDataHandleProperty_ SkillDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "AddSkill");

	Params::GbxSkillStatics_AddSkill Parms{};

	Parms.target = target;
	Parms.SkillDef = SkillDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillStatics.ClearSkillEffects
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     RootDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeRoot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::ClearSkillEffects(class UObject* owner, FGbxDefPtrProperty_ SkillDef, FGbxDefPtrProperty_ RootDef, bool bIncludeRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "ClearSkillEffects");

	Params::GbxSkillStatics_ClearSkillEffects Parms{};

	Parms.owner = owner;
	Parms.SkillDef = SkillDef;
	Parms.RootDef = RootDef;
	Parms.bIncludeRoot = bIncludeRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.FireSkillEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::FireSkillEvent(class UObject* Context, FGbxDefPtrProperty_ EventDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "FireSkillEvent");

	Params::GbxSkillStatics_FireSkillEvent Parms{};

	Parms.Context = Context;
	Parms.EventDef = EventDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.HasManagedResources
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGbxSkill*                        Skill                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     GroupDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillStatics::HasManagedResources(class UGbxSkill* Skill, FGbxDefPtrProperty_ GroupDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "HasManagedResources");

	Params::GbxSkillStatics_HasManagedResources Parms{};

	Parms.Skill = Skill;
	Parms.GroupDef = GroupDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillStatics.IsLocallyControlled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillStatics::IsLocallyControlled(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "IsLocallyControlled");

	Params::GbxSkillStatics_IsLocallyControlled Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillStatics.PlayGbxTrickOwnerLocal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::PlayGbxTrickOwnerLocal(class AActor* target, class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "PlayGbxTrickOwnerLocal");

	Params::GbxSkillStatics_PlayGbxTrickOwnerLocal Parms{};

	Parms.target = target;
	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.PlayTrickAndWait
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxSkillGeneralStartEndOp*             Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxSkillGeneralStartEndResult*         Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxSkillStatics::PlayTrickAndWait(class UObject* WorldContextObject, class AActor* target, class UGbxTrick* Trick, EGbxSkillGeneralStartEndOp* Exec, EGbxSkillGeneralStartEndResult* Result, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "PlayTrickAndWait");

	Params::GbxSkillStatics_PlayTrickAndWait Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.target = target;
	Parms.Trick = Trick;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxGame.GbxSkillStatics.PushStateMachineRegister
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     Register                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::PushStateMachineRegister(class UObject* Context, FGbxDefPtrProperty_ SkillDef, FGbxDefPtrProperty_ Register)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "PushStateMachineRegister");

	Params::GbxSkillStatics_PushStateMachineRegister Parms{};

	Parms.Context = Context;
	Parms.SkillDef = SkillDef;
	Parms.Register = Register;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.RemoveSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::RemoveSkill(class UObject* target, FGameDataHandleProperty_ SkillDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "RemoveSkill");

	Params::GbxSkillStatics_RemoveSkill Parms{};

	Parms.target = target;
	Parms.SkillDef = SkillDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.SetSkillEffectEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EffectDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::SetSkillEffectEnabled(class UObject* owner, FGbxDefPtrProperty_ SkillDef, FGbxDefPtrProperty_ EffectDef, class FName reason, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "SetSkillEffectEnabled");

	Params::GbxSkillStatics_SetSkillEffectEnabled Parms{};

	Parms.owner = owner;
	Parms.SkillDef = SkillDef;
	Parms.EffectDef = EffectDef;
	Parms.reason = reason;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.SetSkillStateEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     SkillDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EffectDef                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::SetSkillStateEnabled(class UObject* owner, FGbxDefPtrProperty_ SkillDef, FGbxDefPtrProperty_ EffectDef, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "SetSkillStateEnabled");

	Params::GbxSkillStatics_SetSkillStateEnabled Parms{};

	Parms.owner = owner;
	Parms.SkillDef = SkillDef;
	Parms.EffectDef = EffectDef;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.UnwatchSkillEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::UnwatchSkillEvent(class UObject* owner, class UObject* Context, FGbxDefPtrProperty_ EventDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "UnwatchSkillEvent");

	Params::GbxSkillStatics_UnwatchSkillEvent Parms{};

	Parms.owner = owner;
	Parms.Context = Context;
	Parms.EventDef = EventDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillStatics.WatchSkillEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     EventDef                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillStatics::WatchSkillEvent(class UObject* Context, FGbxDefPtrProperty_ EventDef, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillStatics", "WatchSkillEvent");

	Params::GbxSkillStatics_WatchSkillEvent Parms{};

	Parms.Context = Context;
	Parms.EventDef = EventDef;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillTargetListRegistryStatics.AddEntry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ListDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillTargetListRegistryStatics::AddEntry(class UObject* Context, FGameDataHandleProperty_ ListDef, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetListRegistryStatics", "AddEntry");

	Params::GbxSkillTargetListRegistryStatics_AddEntry Parms{};

	Parms.Context = Context;
	Parms.ListDef = ListDef;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillTargetListRegistryStatics.ClearList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ListDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillTargetListRegistryStatics::ClearList(class UObject* Context, FGameDataHandleProperty_ ListDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetListRegistryStatics", "ClearList");

	Params::GbxSkillTargetListRegistryStatics_ClearList Parms{};

	Parms.Context = Context;
	Parms.ListDef = ListDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillTargetListRegistryStatics.ContainsTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     TargetList                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillTargetListRegistryStatics::ContainsTarget(class UObject* Context, FGbxDefPtrProperty_ TargetList, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetListRegistryStatics", "ContainsTarget");

	Params::GbxSkillTargetListRegistryStatics_ContainsTarget Parms{};

	Parms.Context = Context;
	Parms.TargetList = TargetList;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillTargetListRegistryStatics.ForEachTargetable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     TargetList                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* target)>   RegistryFunc                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillTargetListRegistryStatics::ForEachTargetable(class UObject* Context, FGbxDefPtrProperty_ TargetList, TDelegate<void(class AActor* target)> RegistryFunc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetListRegistryStatics", "ForEachTargetable");

	Params::GbxSkillTargetListRegistryStatics_ForEachTargetable Parms{};

	Parms.Context = Context;
	Parms.TargetList = TargetList;
	Parms.RegistryFunc = RegistryFunc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillTargetListRegistryStatics.GetCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ListDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxSkillTargetListRegistryStatics::GetCount(class UObject* Context, FGameDataHandleProperty_ ListDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetListRegistryStatics", "GetCount");

	Params::GbxSkillTargetListRegistryStatics_GetCount Parms{};

	Parms.Context = Context;
	Parms.ListDef = ListDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillTargetListRegistryStatics.RemoveEntry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ListDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSkillTargetListRegistryStatics::RemoveEntry(class UObject* Context, FGameDataHandleProperty_ ListDef, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetListRegistryStatics", "RemoveEntry");

	Params::GbxSkillTargetListRegistryStatics_RemoveEntry Parms{};

	Parms.Context = Context;
	Parms.ListDef = ListDef;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSkillTargetResolutionStatics.ForEachInStrategy
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     StrategyDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* target)>   Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSkillTargetResolutionStatics::ForEachInStrategy(class UObject* Context, FGbxDefPtrProperty_ StrategyDef, TDelegate<void(class AActor* target)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetResolutionStatics", "ForEachInStrategy");

	Params::GbxSkillTargetResolutionStatics_ForEachInStrategy Parms{};

	Parms.Context = Context;
	Parms.StrategyDef = StrategyDef;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxSkillTargetResolutionStatics.GetTargetStrategyCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     StrategyDef                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxSkillTargetResolutionStatics::GetTargetStrategyCount(class UObject* Context, FGbxDefPtrProperty_ StrategyDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSkillTargetResolutionStatics", "GetTargetStrategyCount");

	Params::GbxSkillTargetResolutionStatics_GetTargetStrategyCount Parms{};

	Parms.Context = Context;
	Parms.StrategyDef = StrategyDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSplineActor.GetClosestLocationOnSpline
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AGbxSplineActor::GetClosestLocationOnSpline(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineActor", "GetClosestLocationOnSpline");

	Params::GbxSplineActor_GetClosestLocationOnSpline Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSplineActor.GetClosestRotationOnSpline
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AGbxSplineActor::GetClosestRotationOnSpline(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineActor", "GetClosestRotationOnSpline");

	Params::GbxSplineActor_GetClosestRotationOnSpline Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSplineActor.GetTotalLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGbxSplineActor::GetTotalLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineActor", "GetTotalLength");

	Params::GbxSplineActor_GetTotalLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSplineActor.GetTransformAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWorldCoordinate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform AGbxSplineActor::GetTransformAtDistanceAlongSpline(float Distance, bool bWorldCoordinate, bool bUseScale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineActor", "GetTransformAtDistanceAlongSpline");

	Params::GbxSplineActor_GetTransformAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.bWorldCoordinate = bWorldCoordinate;
	Parms.bUseScale = bUseScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSplineVolume.GenerateRandomPointsWithinVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   NumPoints                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDistributedUniformly                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> AGbxSplineVolume::GenerateRandomPointsWithinVolume(int32 NumPoints, bool bDistributedUniformly) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineVolume", "GenerateRandomPointsWithinVolume");

	Params::GbxSplineVolume_GenerateRandomPointsWithinVolume Parms{};

	Parms.NumPoints = NumPoints;
	Parms.bDistributedUniformly = bDistributedUniformly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSplineVolume.IsInsideConvexHull
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   PositionToTest                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxSplineVolume::IsInsideConvexHull(const struct FVector& PositionToTest) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineVolume", "IsInsideConvexHull");

	Params::GbxSplineVolume_IsInsideConvexHull Parms{};

	Parms.PositionToTest = std::move(PositionToTest);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxSplineVolume.IsInsideVolume
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   PositionToTest                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGbxSplineVolume::IsInsideVolume(const struct FVector& PositionToTest) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineVolume", "IsInsideVolume");

	Params::GbxSplineVolume_IsInsideVolume Parms{};

	Parms.PositionToTest = std::move(PositionToTest);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStandInStatics.ClearStandIn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              StandInId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxStandInStatics::ClearStandIn(class UObject* owner, const struct FGameplayTag& StandInId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStandInStatics", "ClearStandIn");

	Params::GbxStandInStatics_ClearStandIn Parms{};

	Parms.owner = owner;
	Parms.StandInId = std::move(StandInId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStandInStatics.PlayStandInTrick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              StandInId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              TrickId                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxStandInStatics::PlayStandInTrick(class UObject* owner, const struct FGameplayTag& StandInId, const struct FGameplayTag& TrickId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStandInStatics", "PlayStandInTrick");

	Params::GbxStandInStatics_PlayStandInTrick Parms{};

	Parms.owner = owner;
	Parms.StandInId = std::move(StandInId);
	Parms.TrickId = std::move(TrickId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStandInStatics.RequestStandIn
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              StandInId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     StandInSettings                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     LinkedActorDef                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AGbxStandIn* StandIn)>OnStandInInitialized                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxStandInStatics::RequestStandIn(class UObject* owner, const struct FGameplayTag& StandInId, FGbxDefPtrProperty_ StandInSettings, const struct FTransform& SpawnTransform, FGbxDefPtrProperty_ LinkedActorDef, TDelegate<void(class AGbxStandIn* StandIn)> OnStandInInitialized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStandInStatics", "RequestStandIn");

	Params::GbxStandInStatics_RequestStandIn Parms{};

	Parms.owner = owner;
	Parms.StandInId = std::move(StandInId);
	Parms.StandInSettings = StandInSettings;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.LinkedActorDef = LinkedActorDef;
	Parms.OnStandInInitialized = OnStandInInitialized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStandInStatics.ResetStandInBodySwitchesToDefaultState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              StandInId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxStandInStatics::ResetStandInBodySwitchesToDefaultState(class UObject* owner, const struct FGameplayTag& StandInId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStandInStatics", "ResetStandInBodySwitchesToDefaultState");

	Params::GbxStandInStatics_ResetStandInBodySwitchesToDefaultState Parms{};

	Parms.owner = owner;
	Parms.StandInId = std::move(StandInId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStatusEffectScript_Const.OnBegin
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FGbxStatusEffectScript_ExecContext&execContext                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxStatusEffectScript_Const::OnBegin(const struct FGbxStatusEffectScript_ExecContext& execContext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStatusEffectScript_Const", "OnBegin");

	Params::GbxStatusEffectScript_Const_OnBegin Parms{};

	Parms.execContext = std::move(execContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxStatusEffectScript_Const.OnEnd
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FGbxStatusEffectScript_ExecContext&execContext                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxStatusEffectScript_Const::OnEnd(const struct FGbxStatusEffectScript_ExecContext& execContext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStatusEffectScript_Const", "OnEnd");

	Params::GbxStatusEffectScript_Const_OnEnd Parms{};

	Parms.execContext = std::move(execContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxStatusEffectScript_Const.OnPushEvent
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const FGbxDefPtrProperty_&              EventDef                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxStatusEffectScript_ExecContext&execContext                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UObject*                    PushOwner                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxStatusEffectScript_Const::OnPushEvent(const FGbxDefPtrProperty_& EventDef, const struct FGbxStatusEffectScript_ExecContext& execContext, const class UObject* PushOwner, const struct FGameplayTagContainer& tags, const struct FGbxStatusEffectSpec_Params& params) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStatusEffectScript_Const", "OnPushEvent");

	Params::GbxStatusEffectScript_Const_OnPushEvent Parms{};

	Parms.EventDef = EventDef;
	Parms.execContext = std::move(execContext);
	Parms.PushOwner = PushOwner;
	Parms.tags = std::move(tags);
	Parms.params = std::move(params);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxStatusEffectScript_Const.RequestShutdown
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGbxStatusEffectScript_ExecContext&execContext                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGbxStatusEffectScript_Const::RequestShutdown(const struct FGbxStatusEffectScript_ExecContext& execContext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStatusEffectScript_Const", "RequestShutdown");

	Params::GbxStatusEffectScript_Const_RequestShutdown Parms{};

	Parms.execContext = std::move(execContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStatusEffectScript_Instanced.OnBegin
// (Event, Public, BlueprintEvent)

void UGbxStatusEffectScript_Instanced::OnBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStatusEffectScript_Instanced", "OnBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxStatusEffectScript_Instanced.OnEnd
// (Event, Public, BlueprintEvent)

void UGbxStatusEffectScript_Instanced::OnEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStatusEffectScript_Instanced", "OnEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GbxGame.GbxStatusEffectScript_Instanced.RequestShutdown
// (Final, Native, Public, BlueprintCallable)

void UGbxStatusEffectScript_Instanced::RequestShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxStatusEffectScript_Instanced", "RequestShutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStatusEffectSignatureParam_Duration.GetDuration
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxStatusEffectSignatureParam_Duration::GetDuration(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_Duration", "GetDuration");

	Params::GbxStatusEffectSignatureParam_Duration_GetDuration Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam_DmgInstigator.GetDmgInstigator
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UGbxStatusEffectSignatureParam_DmgInstigator::GetDmgInstigator(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_DmgInstigator", "GetDmgInstigator");

	Params::GbxStatusEffectSignatureParam_DmgInstigator_GetDmgInstigator Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam_DmgCauser.GetDmgCauser
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGbxStatusEffectSignatureParam_DmgCauser::GetDmgCauser(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_DmgCauser", "GetDmgCauser");

	Params::GbxStatusEffectSignatureParam_DmgCauser_GetDmgCauser Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam_DPS.GetDPS
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxStatusEffectSignatureParam_DPS::GetDPS(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_DPS", "GetDPS");

	Params::GbxStatusEffectSignatureParam_DPS_GetDPS Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam_Charge.GetCharge
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxStatusEffectSignatureParam_Charge::GetCharge(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_Charge", "GetCharge");

	Params::GbxStatusEffectSignatureParam_Charge_GetCharge Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam_MutationChance.GetMutChance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxStatusEffectSignatureParam_MutationChance::GetMutChance(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_MutationChance", "GetMutChance");

	Params::GbxStatusEffectSignatureParam_MutationChance_GetMutChance Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectSignatureParam_MutationBonus.GetMutBonus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxStatusEffectSpec_Params&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGetStatusEffectParamResultPins*        Outcome                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGbxStatusEffectSignatureParam_MutationBonus::GetMutBonus(const struct FGbxStatusEffectSpec_Params& params, EGetStatusEffectParamResultPins* Outcome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectSignatureParam_MutationBonus", "GetMutBonus");

	Params::GbxStatusEffectSignatureParam_MutationBonus_GetMutBonus Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Outcome != nullptr)
		*Outcome = Parms.Outcome;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.GetQueryResult_Float
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxStatusEffectQueryResult&Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UGbxStatusEffectsStatics::GetQueryResult_Float(const struct FGbxStatusEffectQueryResult& Result, class FName Name_0, class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "GetQueryResult_Float");

	Params::GbxStatusEffectsStatics_GetQueryResult_Float Parms{};

	Parms.Result = std::move(Result);
	Parms.Name_0 = Name_0;
	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.GetQueryResult_Int
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxStatusEffectQueryResult&Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxStatusEffectsStatics::GetQueryResult_Int(const struct FGbxStatusEffectQueryResult& Result, class FName Name_0, class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "GetQueryResult_Int");

	Params::GbxStatusEffectsStatics_GetQueryResult_Int Parms{};

	Parms.Result = std::move(Result);
	Parms.Name_0 = Name_0;
	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.GetStatusEffectInstanceCount
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UGbxStatusEffectData*       StatusEffectData                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFilterByOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InOwner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxStatusEffectsStatics::GetStatusEffectInstanceCount(class UObject* target, const class UGbxStatusEffectData* StatusEffectData, bool bFilterByOwner, class UObject* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "GetStatusEffectInstanceCount");

	Params::GbxStatusEffectsStatics_GetStatusEffectInstanceCount Parms{};

	Parms.target = target;
	Parms.StatusEffectData = StatusEffectData;
	Parms.bFilterByOwner = bFilterByOwner;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.HasStatusEffect
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UGbxStatusEffectData*       StatusEffectData                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxStatusEffectsStatics::HasStatusEffect(class UObject* target, const class UGbxStatusEffectData* StatusEffectData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "HasStatusEffect");

	Params::GbxStatusEffectsStatics_HasStatusEffect Parms{};

	Parms.target = target;
	Parms.StatusEffectData = StatusEffectData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.PopAllFromEffect
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UGbxStatusEffectData*       StatusEffectData                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxStatusEffectsStatics::PopAllFromEffect(class UObject* target, const class UGbxStatusEffectData* StatusEffectData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "PopAllFromEffect");

	Params::GbxStatusEffectsStatics_PopAllFromEffect Parms{};

	Parms.target = target;
	Parms.StatusEffectData = StatusEffectData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.PopAllFromEffectSpec
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxStatusEffectPopAllFromEffectSpec&Spec                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxStatusEffectsStatics::PopAllFromEffectSpec(class UObject* target, const struct FGbxStatusEffectPopAllFromEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "PopAllFromEffectSpec");

	Params::GbxStatusEffectsStatics_PopAllFromEffectSpec Parms{};

	Parms.target = target;
	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.PopAllSpec
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxStatusEffectPopAllSpec&Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxStatusEffectsStatics::PopAllSpec(class UObject* target, const struct FGbxStatusEffectPopAllSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "PopAllSpec");

	Params::GbxStatusEffectsStatics_PopAllSpec Parms{};

	Parms.target = target;
	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.PopSpec
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxStatusEffectPopSpec&   Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGbxStatusEffectsStatics::PopSpec(class UObject* target, const struct FGbxStatusEffectPopSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "PopSpec");

	Params::GbxStatusEffectsStatics_PopSpec Parms{};

	Parms.target = target;
	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.PushSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxStatusEffectPushSpec&  Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxStatusEffectsStatics::PushSpec(class UObject* target, const struct FGbxStatusEffectPushSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "PushSpec");

	Params::GbxStatusEffectsStatics_PushSpec Parms{};

	Parms.target = target;
	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.Query
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxStatusEffectData*             StatusEffect                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxStatusEffectQuerySpec*        Spec                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxStatusEffectQueryResult&     Result                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxStatusEffectsStatics::Query(class UObject* target, class UGbxStatusEffectData* StatusEffect, class UGbxStatusEffectQuerySpec* Spec, struct FGbxStatusEffectQueryResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "Query");

	Params::GbxStatusEffectsStatics_Query Parms{};

	Parms.target = target;
	Parms.StatusEffect = StatusEffect;
	Parms.Spec = Spec;
	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.Query_ByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         TagQuery                                               (Parm, NativeAccessSpecifierPublic)
// class UGbxStatusEffectQuerySpec*        Spec                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxStatusEffectQueryResult&     Result                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxStatusEffectsStatics::Query_ByTag(class UObject* target, const struct FGameplayTagQuery& TagQuery, class UGbxStatusEffectQuerySpec* Spec, struct FGbxStatusEffectQueryResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "Query_ByTag");

	Params::GbxStatusEffectsStatics_Query_ByTag Parms{};

	Parms.target = target;
	Parms.TagQuery = std::move(TagQuery);
	Parms.Spec = Spec;
	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function GbxGame.GbxStatusEffectsStatics.RegisterListener
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxStatusEffectNotifyEvent*      Event                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          EventContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxStatusEffectNotifyEventType         EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxStatusEffectsStatics::RegisterListener(class UObject* Context, class UGbxStatusEffectNotifyEvent* Event, class UObject* EventContext, class FName EventName, EGbxStatusEffectNotifyEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "RegisterListener");

	Params::GbxStatusEffectsStatics_RegisterListener Parms{};

	Parms.Context = Context;
	Parms.Event = Event;
	Parms.EventContext = EventContext;
	Parms.EventName = EventName;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxStatusEffectsStatics.UnRegisterListener
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxStatusEffectNotifyEvent*      Event                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          EventContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxStatusEffectNotifyEventType         EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxStatusEffectsStatics::UnRegisterListener(class UObject* Context, class UGbxStatusEffectNotifyEvent* Event, class UObject* EventContext, class FName EventName, EGbxStatusEffectNotifyEventType EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxStatusEffectsStatics", "UnRegisterListener");

	Params::GbxStatusEffectsStatics_UnRegisterListener Parms{};

	Parms.Context = Context;
	Parms.Event = Event;
	Parms.EventContext = EventContext;
	Parms.EventName = EventName;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTraceTrajectoryComponent.SetTrajectoryEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTraceTrajectoryComponent::SetTrajectoryEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTraceTrajectoryComponent", "SetTrajectoryEnabled");

	Params::GbxTraceTrajectoryComponent_SetTrajectoryEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTraceTrajectoryComponent.SetTrajectoryParticleComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFXSystemComponent*               ParticleComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTraceTrajectoryComponent::SetTrajectoryParticleComponent(class UFXSystemComponent* ParticleComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTraceTrajectoryComponent", "SetTrajectoryParticleComponent");

	Params::GbxTraceTrajectoryComponent_SetTrajectoryParticleComponent Parms{};

	Parms.ParticleComponent = ParticleComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTraceTrajectoryComponent.UpdateCollisionShape
// (Final, Native, Public, BlueprintCallable)

void UGbxTraceTrajectoryComponent::UpdateCollisionShape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTraceTrajectoryComponent", "UpdateCollisionShape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTraceTrajectoryComponent.IsTrajectoryEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTraceTrajectoryComponent::IsTrajectoryEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTraceTrajectoryComponent", "IsTrajectoryEnabled");

	Params::GbxTraceTrajectoryComponent_IsTrajectoryEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickInterface.PlayTrick
// (Native, Public, BlueprintCallable)
// Parameters:
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 IGbxTrickInterface::PlayTrick(class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxTrickInterface", "PlayTrick");

	Params::GbxTrickInterface_PlayTrick Parms{};

	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickInterface.PlayTrickLocal
// (Native, Public, BlueprintCallable)
// Parameters:
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 IGbxTrickInterface::PlayTrickLocal(class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxTrickInterface", "PlayTrickLocal");

	Params::GbxTrickInterface_PlayTrickLocal Parms{};

	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickInterface.StopTrick
// (Native, Public, BlueprintCallable)
// Parameters:
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGbxTrickInterface::StopTrick(class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxTrickInterface", "StopTrick");

	Params::GbxTrickInterface_StopTrick Parms{};

	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickInterface.StopTrickId
// (Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGbxTrickInterface::StopTrickId(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxTrickInterface", "StopTrickId");

	Params::GbxTrickInterface_StopTrickId Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickInterface.StopTrickIdLocal
// (Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGbxTrickInterface::StopTrickIdLocal(uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxTrickInterface", "StopTrickIdLocal");

	Params::GbxTrickInterface_StopTrickIdLocal Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickInterface.StopTrickLocal
// (Native, Public, BlueprintCallable)
// Parameters:
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGbxTrickInterface::StopTrickLocal(class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxTrickInterface", "StopTrickLocal");

	Params::GbxTrickInterface_StopTrickLocal Parms{};

	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.GetGbxTrickMeshes
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxTrickStatics::GetGbxTrickMeshes(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "GetGbxTrickMeshes");

	Params::GbxTrickStatics_GetGbxTrickMeshes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.GbxTrickStatics.GetGbxTrickSlots
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGbxTrickStatics::GetGbxTrickSlots(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "GetGbxTrickSlots");

	Params::GbxTrickStatics_GetGbxTrickSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.GbxTrickStatics.GetTrickAnimPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGbxTrickStatics::GetTrickAnimPath(class AActor* Actor, class FName MeshName, class FName SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "GetTrickAnimPath");

	Params::GbxTrickStatics_GetTrickAnimPath Parms{};

	Parms.Actor = Actor;
	Parms.MeshName = MeshName;
	Parms.SlotName = SlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickStatics.IsPlayingTrick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTrickStatics::IsPlayingTrick(class AActor* Actor, class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "IsPlayingTrick");

	Params::GbxTrickStatics_IsPlayingTrick Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickStatics.IsPlayingTrickId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxTrickStatics::IsPlayingTrickId(class AActor* Actor, uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "IsPlayingTrickId");

	Params::GbxTrickStatics_IsPlayingTrickId Parms{};

	Parms.Actor = Actor;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickStatics.PlayGbxTrick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UGbxTrickStatics::PlayGbxTrick(class AActor* Actor, class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "PlayGbxTrick");

	Params::GbxTrickStatics_PlayGbxTrick Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickStatics.PlayGbxTrick_Latent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxTrickLatentState*                   Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGbxTrickStatics::PlayGbxTrick_Latent(class AActor* Actor, class UGbxTrick* Trick, EGbxTrickLatentState* Exec, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "PlayGbxTrick_Latent");

	Params::GbxTrickStatics_PlayGbxTrick_Latent Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxGame.GbxTrickStatics.PlayGbxTrickLocal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UGbxTrickStatics::PlayGbxTrickLocal(class AActor* Actor, class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "PlayGbxTrickLocal");

	Params::GbxTrickStatics_PlayGbxTrickLocal Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrick(class AActor* Actor, class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrick");

	Params::GbxTrickStatics_StopGbxTrick Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrickId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrickId(class AActor* Actor, uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrickId");

	Params::GbxTrickStatics_StopGbxTrickId Parms{};

	Parms.Actor = Actor;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrickIdLocal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrickIdLocal(class AActor* Actor, uint8 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrickIdLocal");

	Params::GbxTrickStatics_StopGbxTrickIdLocal Parms{};

	Parms.Actor = Actor;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrickLocal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick*                        Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrickLocal(class AActor* Actor, class UGbxTrick* Trick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrickLocal");

	Params::GbxTrickStatics_StopGbxTrickLocal Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrickLoop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick_Loop*                   Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowStartToFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrickLoop(class AActor* Actor, class UGbxTrick_Loop* Trick, bool bAllowStartToFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrickLoop");

	Params::GbxTrickStatics_StopGbxTrickLoop Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;
	Parms.bAllowStartToFinish = bAllowStartToFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrickLoopId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowStartToFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrickLoopId(class AActor* Actor, uint8 ID, bool bAllowStartToFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrickLoopId");

	Params::GbxTrickStatics_StopGbxTrickLoopId Parms{};

	Parms.Actor = Actor;
	Parms.ID = ID;
	Parms.bAllowStartToFinish = bAllowStartToFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrickPerch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxTrick_Perch*                  Trick                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitForLoop                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrickPerch(class AActor* Actor, class UGbxTrick_Perch* Trick, bool bWaitForLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrickPerch");

	Params::GbxTrickStatics_StopGbxTrickPerch Parms{};

	Parms.Actor = Actor;
	Parms.Trick = Trick;
	Parms.bWaitForLoop = bWaitForLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTrickStatics.StopGbxTrickPerchId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitForLoop                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTrickStatics::StopGbxTrickPerchId(class AActor* Actor, uint8 ID, bool bWaitForLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxTrickStatics", "StopGbxTrickPerchId");

	Params::GbxTrickStatics_StopGbxTrickPerchId Parms{};

	Parms.Actor = Actor;
	Parms.ID = ID;
	Parms.bWaitForLoop = bWaitForLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTriggerComponent.NotifyActorComponentEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTriggerComponent::NotifyActorComponentEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTriggerComponent", "NotifyActorComponentEndOverlap");

	Params::GbxTriggerComponent_NotifyActorComponentEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTriggerComponent.NotifyActorComponentStartOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGbxTriggerComponent::NotifyActorComponentStartOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTriggerComponent", "NotifyActorComponentStartOverlap");

	Params::GbxTriggerComponent_NotifyActorComponentStartOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTriggerComponent.SetTriggerEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxTriggerComponent::SetTriggerEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTriggerComponent", "SetTriggerEnabled");

	Params::GbxTriggerComponent_SetTriggerEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxTriggerVolume.BindAndCallOnTouchedTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(class AActor* InActor, bool bIsPlayer)>InEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallThisEventOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxTriggerVolume::BindAndCallOnTouchedTrigger(TDelegate<void(class AActor* InActor, bool bIsPlayer)> InEvent, bool bCallThisEventOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxTriggerVolume", "BindAndCallOnTouchedTrigger");

	Params::GbxTriggerVolume_BindAndCallOnTouchedTrigger Parms{};

	Parms.InEvent = InEvent;
	Parms.bCallThisEventOnly = bCallThisEventOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GbxUseTrigger.K2_OnHoldUsedTrigger
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxUseTrigger::K2_OnHoldUsedTrigger(class AActor* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxUseTrigger", "K2_OnHoldUsedTrigger");

	Params::GbxUseTrigger_K2_OnHoldUsedTrigger Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxUseTrigger.K2_OnSecondaryHoldUsedTrigger
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxUseTrigger::K2_OnSecondaryHoldUsedTrigger(class AActor* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxUseTrigger", "K2_OnSecondaryHoldUsedTrigger");

	Params::GbxUseTrigger_K2_OnSecondaryHoldUsedTrigger Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxUseTrigger.K2_OnSecondaryUsedTrigger
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxUseTrigger::K2_OnSecondaryUsedTrigger(class AActor* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxUseTrigger", "K2_OnSecondaryUsedTrigger");

	Params::GbxUseTrigger_K2_OnSecondaryUsedTrigger Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxUseTrigger.K2_OnUsedTrigger
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGbxUseTrigger::K2_OnUsedTrigger(class AActor* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxUseTrigger", "K2_OnUsedTrigger");

	Params::GbxUseTrigger_K2_OnUsedTrigger Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.GbxUseTrigger.OnRep_UsableActorState
// (Final, Native, Private)

void AGbxUseTrigger::OnRep_UsableActorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxUseTrigger", "OnRep_UsableActorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.RegisterOxygenConsumption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxCharacter*                    TargetCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConsumptionRate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::RegisterOxygenConsumption(class AGbxCharacter* TargetCharacter, class FName reason, float ConsumptionRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "RegisterOxygenConsumption");

	Params::OxygenConsumptionStatics_RegisterOxygenConsumption Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.reason = reason;
	Parms.ConsumptionRate = ConsumptionRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.RegisterOxygenConsumptionForAllPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ContextActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConsumptionRate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::RegisterOxygenConsumptionForAllPlayers(class AActor* ContextActor, class FName reason, float ConsumptionRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "RegisterOxygenConsumptionForAllPlayers");

	Params::OxygenConsumptionStatics_RegisterOxygenConsumptionForAllPlayers Parms{};

	Parms.ContextActor = ContextActor;
	Parms.reason = reason;
	Parms.ConsumptionRate = ConsumptionRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.RegisterOxygenRegeneration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxCharacter*                    TargetCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RegenerationRate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::RegisterOxygenRegeneration(class AGbxCharacter* TargetCharacter, class FName reason, float RegenerationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "RegisterOxygenRegeneration");

	Params::OxygenConsumptionStatics_RegisterOxygenRegeneration Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.reason = reason;
	Parms.RegenerationRate = RegenerationRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.SetSkipDefaultOxygenDepletedBehavior
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldSkipDefaultOxygenDepletedBehavior               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::SetSkipDefaultOxygenDepletedBehavior(class UObject* OwnerContext, bool bShouldSkipDefaultOxygenDepletedBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "SetSkipDefaultOxygenDepletedBehavior");

	Params::OxygenConsumptionStatics_SetSkipDefaultOxygenDepletedBehavior Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.bShouldSkipDefaultOxygenDepletedBehavior = bShouldSkipDefaultOxygenDepletedBehavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.SubscribeToOxygenDepletedEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* OxygenConsumer)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideDefaultBehavior                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::SubscribeToOxygenDepletedEvent(class UObject* OwnerContext, TDelegate<void(class AActor* OxygenConsumer)> Delegate, bool bOverrideDefaultBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "SubscribeToOxygenDepletedEvent");

	Params::OxygenConsumptionStatics_SubscribeToOxygenDepletedEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;
	Parms.bOverrideDefaultBehavior = bOverrideDefaultBehavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.SubscribeToOxygenNotDepletedEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* OxygenConsumer)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::SubscribeToOxygenNotDepletedEvent(class UObject* OwnerContext, TDelegate<void(class AActor* OxygenConsumer)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "SubscribeToOxygenNotDepletedEvent");

	Params::OxygenConsumptionStatics_SubscribeToOxygenNotDepletedEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.UnregisterOxygenConsumption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxCharacter*                    TargetCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::UnregisterOxygenConsumption(class AGbxCharacter* TargetCharacter, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "UnregisterOxygenConsumption");

	Params::OxygenConsumptionStatics_UnregisterOxygenConsumption Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.UnregisterOxygenConsumptionForAllPlayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ContextActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::UnregisterOxygenConsumptionForAllPlayers(class AActor* ContextActor, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "UnregisterOxygenConsumptionForAllPlayers");

	Params::OxygenConsumptionStatics_UnregisterOxygenConsumptionForAllPlayers Parms{};

	Parms.ContextActor = ContextActor;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.UnregisterOxygenRegeneration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGbxCharacter*                    TargetCharacter                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::UnregisterOxygenRegeneration(class AGbxCharacter* TargetCharacter, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "UnregisterOxygenRegeneration");

	Params::OxygenConsumptionStatics_UnregisterOxygenRegeneration Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.UnsubscribeFromOxygenDepletedEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* OxygenConsumer)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveDefaultBehaviorOverride                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::UnsubscribeFromOxygenDepletedEvent(class UObject* OwnerContext, TDelegate<void(class AActor* OxygenConsumer)> Delegate, bool bRemoveDefaultBehaviorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "UnsubscribeFromOxygenDepletedEvent");

	Params::OxygenConsumptionStatics_UnsubscribeFromOxygenDepletedEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;
	Parms.bRemoveDefaultBehaviorOverride = bRemoveDefaultBehaviorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.OxygenConsumptionStatics.UnsubscribeFromOxygenNotDepletedEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* OxygenConsumer)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOxygenConsumptionStatics::UnsubscribeFromOxygenNotDepletedEvent(class UObject* OwnerContext, TDelegate<void(class AActor* OxygenConsumer)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OxygenConsumptionStatics", "UnsubscribeFromOxygenNotDepletedEvent");

	Params::OxygenConsumptionStatics_UnsubscribeFromOxygenNotDepletedEvent Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.GoreLimb.OnHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AGoreLimb::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GoreLimb", "OnHit");

	Params::GoreLimb_OnHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionComponent.BeginInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                NewState                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SourceDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewInstigator                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHazardInteractionComponent::BeginInteraction(FGameDataHandleProperty_ NewState, bool bIsSource, float SourceDuration, class AActor* NewInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HazardInteractionComponent", "BeginInteraction");

	Params::HazardInteractionComponent_BeginInteraction Parms{};

	Parms.NewState = NewState;
	Parms.bIsSource = bIsSource;
	Parms.SourceDuration = SourceDuration;
	Parms.NewInstigator = NewInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionComponent.OnRep_InteractionState
// (Final, Native, Protected)

void UHazardInteractionComponent::OnRep_InteractionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HazardInteractionComponent", "OnRep_InteractionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionComponent.SetDamageInstigator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewInstigator                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHazardInteractionComponent::SetDamageInstigator(class AActor* NewInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HazardInteractionComponent", "SetDamageInstigator");

	Params::HazardInteractionComponent_SetDamageInstigator Parms{};

	Parms.NewInstigator = NewInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHazardInteractionComponent::SetEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HazardInteractionComponent", "SetEnabled");

	Params::HazardInteractionComponent_SetEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionComponent.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHazardInteractionComponent::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HazardInteractionComponent", "IsEnabled");

	Params::HazardInteractionComponent_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.HazardInteractionInterface.OnBeginHazardDamageOverlap
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IHazardInteractionInterface::OnBeginHazardDamageOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("HazardInteractionInterface", "OnBeginHazardDamageOverlap");

	Params::HazardInteractionInterface_OnBeginHazardDamageOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionInterface.OnBeginHazardInteractionOverlap
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IHazardInteractionInterface::OnBeginHazardInteractionOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("HazardInteractionInterface", "OnBeginHazardInteractionOverlap");

	Params::HazardInteractionInterface_OnBeginHazardInteractionOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionInterface.OnEndHazardDamageOverlap
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHazardInteractionInterface::OnEndHazardDamageOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("HazardInteractionInterface", "OnEndHazardDamageOverlap");

	Params::HazardInteractionInterface_OnEndHazardDamageOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.HazardInteractionInterface.OnEndHazardInteractionOverlap
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHazardInteractionInterface::OnEndHazardInteractionOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("HazardInteractionInterface", "OnEndHazardInteractionOverlap");

	Params::HazardInteractionInterface_OnEndHazardInteractionOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBase.GetIdentity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FInventoryIdentity         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInventoryIdentity AInventoryBase::GetIdentity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryBase", "GetIdentity");

	Params::InventoryBase_GetIdentity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.InventoryBodyAnimInstance.BlueprintSwitchedMode
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryBodyAnimInstance::BlueprintSwitchedMode(int32 NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryBodyAnimInstance", "BlueprintSwitchedMode");

	Params::InventoryBodyAnimInstance_BlueprintSwitchedMode Parms{};

	Parms.NewMode = NewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.InventoryBodyOwner.BlendMaterialColorParameter
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              FromParamValue                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              ToParamValue                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyVisibilityType            Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::BlendMaterialColorParameter(class FName ParamName, const struct FLinearColor& FromParamValue, const struct FLinearColor& ToParamValue, float BlendTime, EInventoryBodyVisibilityType Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "BlendMaterialColorParameter");

	Params::InventoryBodyOwner_BlendMaterialColorParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.FromParamValue = std::move(FromParamValue);
	Parms.ToParamValue = std::move(ToParamValue);
	Parms.BlendTime = BlendTime;
	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.BlendMaterialFloatParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FromParamValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ToParamValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyVisibilityType            Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::BlendMaterialFloatParameter(class FName ParamName, float FromParamValue, float ToParamValue, float BlendTime, EInventoryBodyVisibilityType Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "BlendMaterialFloatParameter");

	Params::InventoryBodyOwner_BlendMaterialFloatParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.FromParamValue = FromParamValue;
	Parms.ToParamValue = ToParamValue;
	Parms.BlendTime = BlendTime;
	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.BlendMaterialVectorParameter
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   FromParamValue                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ToParamValue                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyVisibilityType            Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::BlendMaterialVectorParameter(class FName ParamName, const struct FVector& FromParamValue, const struct FVector& ToParamValue, float BlendTime, EInventoryBodyVisibilityType Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "BlendMaterialVectorParameter");

	Params::InventoryBodyOwner_BlendMaterialVectorParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.FromParamValue = std::move(FromParamValue);
	Parms.ToParamValue = std::move(ToParamValue);
	Parms.BlendTime = BlendTime;
	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.NotifyBodyControl
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EffectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EffectID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ControlName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyControlEvent              Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EventValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::NotifyBodyControl(class FName EffectType, int32 EffectID, class FName ControlName, EInventoryBodyControlEvent Event, float EventValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "NotifyBodyControl");

	Params::InventoryBodyOwner_NotifyBodyControl Parms{};

	Parms.EffectType = EffectType;
	Parms.EffectID = EffectID;
	Parms.ControlName = ControlName;
	Parms.Event = Event;
	Parms.EventValue = EventValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetBoneVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyVisibilityType            BodyType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetBoneVisibility(class FName BoneName, bool bVisible, EInventoryBodyVisibilityType BodyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetBoneVisibility");

	Params::InventoryBodyOwner_SetBoneVisibility Parms{};

	Parms.BoneName = BoneName;
	Parms.bVisible = bVisible;
	Parms.BodyType = BodyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetEffectColorParameter
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              ParamValue                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryEffectQueryData& QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetEffectColorParameter(class FName ParamName, const struct FLinearColor& ParamValue, const struct FInventoryEffectQueryData& QueryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetEffectColorParameter");

	Params::InventoryBodyOwner_SetEffectColorParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = std::move(ParamValue);
	Parms.QueryData = std::move(QueryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetEffectEmitterState
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EmitterName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryEffectQueryData& QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetEffectEmitterState(class FName EmitterName, bool bEnabled, const struct FInventoryEffectQueryData& QueryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetEffectEmitterState");

	Params::InventoryBodyOwner_SetEffectEmitterState Parms{};

	Parms.EmitterName = EmitterName;
	Parms.bEnabled = bEnabled;
	Parms.QueryData = std::move(QueryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetEffectFloatParameter
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParamValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryEffectQueryData& QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetEffectFloatParameter(class FName ParamName, float ParamValue, const struct FInventoryEffectQueryData& QueryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetEffectFloatParameter");

	Params::InventoryBodyOwner_SetEffectFloatParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;
	Parms.QueryData = std::move(QueryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetEffectMaterialParameter
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ParamValue                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryEffectQueryData& QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetEffectMaterialParameter(class FName ParamName, class UMaterialInterface* ParamValue, const struct FInventoryEffectQueryData& QueryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetEffectMaterialParameter");

	Params::InventoryBodyOwner_SetEffectMaterialParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;
	Parms.QueryData = std::move(QueryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetEffectVectorParameter
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ParamValue                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryEffectQueryData& QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetEffectVectorParameter(class FName ParamName, const struct FVector& ParamValue, const struct FInventoryEffectQueryData& QueryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetEffectVectorParameter");

	Params::InventoryBodyOwner_SetEffectVectorParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = std::move(ParamValue);
	Parms.QueryData = std::move(QueryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetMaterialColorParameter
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              ParamValue                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyVisibilityType            Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetMaterialColorParameter(class FName ParamName, const struct FLinearColor& ParamValue, EInventoryBodyVisibilityType Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetMaterialColorParameter");

	Params::InventoryBodyOwner_SetMaterialColorParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = std::move(ParamValue);
	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetMaterialFloatParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParamValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyVisibilityType            Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetMaterialFloatParameter(class FName ParamName, float ParamValue, EInventoryBodyVisibilityType Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetMaterialFloatParameter");

	Params::InventoryBodyOwner_SetMaterialFloatParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;
	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryBodyOwner.SetMaterialVectorParameter
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ParamValue                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryBodyVisibilityType            Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInventoryBodyOwner::SetMaterialVectorParameter(class FName ParamName, const struct FVector& ParamValue, EInventoryBodyVisibilityType Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InventoryBodyOwner", "SetMaterialVectorParameter");

	Params::InventoryBodyOwner_SetMaterialVectorParameter Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = std::move(ParamValue);
	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryMaterialParamsDataAsset.GetInventoryMaterialEditorGearManufacturerTypes
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    ManufacturerName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    BaseTypeName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UInventoryMaterialParamsDataAsset::GetInventoryMaterialEditorGearManufacturerTypes(const class FString& ManufacturerName, const class FString& BaseTypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryMaterialParamsDataAsset", "GetInventoryMaterialEditorGearManufacturerTypes");

	Params::InventoryMaterialParamsDataAsset_GetInventoryMaterialEditorGearManufacturerTypes Parms{};

	Parms.ManufacturerName = std::move(ManufacturerName);
	Parms.BaseTypeName = std::move(BaseTypeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.InventoryMaterialParamsDataAsset.GetInventoryMaterialEditorGearTypes
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UInventoryMaterialParamsDataAsset::GetInventoryMaterialEditorGearTypes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryMaterialParamsDataAsset", "GetInventoryMaterialEditorGearTypes");

	Params::InventoryMaterialParamsDataAsset_GetInventoryMaterialEditorGearTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.InventoryMaterialParamsDataAsset.GetInventoryMaterialEditorParamsDataAsset
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventoryMaterialParamsDataAsset*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryMaterialParamsDataAsset* UInventoryMaterialParamsDataAsset::GetInventoryMaterialEditorParamsDataAsset(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryMaterialParamsDataAsset", "GetInventoryMaterialEditorParamsDataAsset");

	Params::InventoryMaterialParamsDataAsset_GetInventoryMaterialEditorParamsDataAsset Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.InventoryMaterialParamsDataAsset.ApplyParameters
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryMaterialParamsDataAsset::ApplyParameters(class UPrimitiveComponent* Component) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryMaterialParamsDataAsset", "ApplyParameters");

	Params::InventoryMaterialParamsDataAsset_ApplyParameters Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryMaterialParamsDataAsset.GetScalarParamNames
// (Final, Native, Protected, HasOutParams, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInventoryMaterialParamsDataAsset::GetScalarParamNames(int32 Index_0, TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryMaterialParamsDataAsset", "GetScalarParamNames");

	Params::InventoryMaterialParamsDataAsset_GetScalarParamNames Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.InventoryMaterialParamsDataAsset.GetTextureParamNames
// (Final, Native, Protected, HasOutParams, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInventoryMaterialParamsDataAsset::GetTextureParamNames(int32 Index_0, TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryMaterialParamsDataAsset", "GetTextureParamNames");

	Params::InventoryMaterialParamsDataAsset_GetTextureParamNames Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.InventoryMaterialParamsDataAsset.GetVectorParamNames
// (Final, Native, Protected, HasOutParams, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInventoryMaterialParamsDataAsset::GetVectorParamNames(int32 Index_0, TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryMaterialParamsDataAsset", "GetVectorParamNames");

	Params::InventoryMaterialParamsDataAsset_GetVectorParamNames Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.InventoryMaterialsDataAsset.GetInventoryMaterialEditorDataAsset
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventoryMaterialsDataAsset*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryMaterialsDataAsset* UInventoryMaterialsDataAsset::GetInventoryMaterialEditorDataAsset(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryMaterialsDataAsset", "GetInventoryMaterialEditorDataAsset");

	Params::InventoryMaterialsDataAsset_GetInventoryMaterialEditorDataAsset Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.InventoryMaterialsDataAsset.GetInventoryMaterialEditorGearRarities
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    TypeName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UInventoryMaterialsDataAsset::GetInventoryMaterialEditorGearRarities(const class FString& TypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryMaterialsDataAsset", "GetInventoryMaterialEditorGearRarities");

	Params::InventoryMaterialsDataAsset_GetInventoryMaterialEditorGearRarities Parms{};

	Parms.TypeName = std::move(TypeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.InventoryPickup.OnActorOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventoryPickup::OnActorOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickup", "OnActorOverlap");

	Params::InventoryPickup_OnActorOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryPickup.OnHit
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AInventoryPickup::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickup", "OnHit");

	Params::InventoryPickup_OnHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryPickup.OnPhysicsSleep
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventoryPickup::OnPhysicsSleep(class UPrimitiveComponent* Component, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickup", "OnPhysicsSleep");

	Params::InventoryPickup_OnPhysicsSleep Parms{};

	Parms.Component = Component;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryPickup.OnPhysicsWake
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventoryPickup::OnPhysicsWake(class UPrimitiveComponent* Component, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickup", "OnPhysicsWake");

	Params::InventoryPickup_OnPhysicsWake Parms{};

	Parms.Component = Component;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.InventoryPickup.OnPickupHit_CheckImpactEffect
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AInventoryPickup::OnPickupHit_CheckImpactEffect(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickup", "OnPickupHit_CheckImpactEffect");

	Params::InventoryPickup_OnPickupHit_CheckImpactEffect Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ItemPoolFunctionLibrary.SpawnItemsFromItemPool_Attach
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                itempool                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunkId>*                 OutJunkIds                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UItemPoolFunctionLibrary::SpawnItemsFromItemPool_Attach(class AActor* SourceActor, FGameDataHandleProperty_ itempool, class FName SocketName, TArray<struct FJunkId>* OutJunkIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemPoolFunctionLibrary", "SpawnItemsFromItemPool_Attach");

	Params::ItemPoolFunctionLibrary_SpawnItemsFromItemPool_Attach Parms{};

	Parms.SourceActor = SourceActor;
	Parms.itempool = itempool;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutJunkIds != nullptr)
		*OutJunkIds = std::move(Parms.OutJunkIds);
}


// Function GbxGame.ItemPoolFunctionLibrary.SpawnItemsFromItemPoolUsingActor_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                itempool                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                SpawnPattern                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunkId>*                 OutJunkIds                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UItemPoolFunctionLibrary::SpawnItemsFromItemPoolUsingActor_Drop(class AActor* SourceActor, FGameDataHandleProperty_ itempool, FGameDataHandleProperty_ SpawnPattern, class FName SocketName, TArray<struct FJunkId>* OutJunkIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemPoolFunctionLibrary", "SpawnItemsFromItemPoolUsingActor_Drop");

	Params::ItemPoolFunctionLibrary_SpawnItemsFromItemPoolUsingActor_Drop Parms{};

	Parms.SourceActor = SourceActor;
	Parms.itempool = itempool;
	Parms.SpawnPattern = SpawnPattern;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutJunkIds != nullptr)
		*OutJunkIds = std::move(Parms.OutJunkIds);
}


// Function GbxGame.ItemPoolFunctionLibrary.SpawnItemsFromItemPoolUsingTransform_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ContextActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SourceTransform                                        (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                itempool                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                SpawnPattern                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunkId>*                 OutJunkIds                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UItemPoolFunctionLibrary::SpawnItemsFromItemPoolUsingTransform_Drop(class AActor* ContextActor, const struct FTransform& SourceTransform, FGameDataHandleProperty_ itempool, FGameDataHandleProperty_ SpawnPattern, class FName SocketName, TArray<struct FJunkId>* OutJunkIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemPoolFunctionLibrary", "SpawnItemsFromItemPoolUsingTransform_Drop");

	Params::ItemPoolFunctionLibrary_SpawnItemsFromItemPoolUsingTransform_Drop Parms{};

	Parms.ContextActor = ContextActor;
	Parms.SourceTransform = std::move(SourceTransform);
	Parms.itempool = itempool;
	Parms.SpawnPattern = SpawnPattern;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutJunkIds != nullptr)
		*OutJunkIds = std::move(Parms.OutJunkIds);
}


// Function GbxGame.ItemsFunctionLibrary.GetRecipeName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const FGameDataHandleProperty_&         RecipeDef                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText*                            Name_0                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemsFunctionLibrary::GetRecipeName(class UObject* WorldContextObject, const FGameDataHandleProperty_& RecipeDef, class FText* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemsFunctionLibrary", "GetRecipeName");

	Params::ItemsFunctionLibrary_GetRecipeName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RecipeDef = RecipeDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function GbxGame.ItemsFunctionLibrary.GetRecipesFromTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      Tag                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<FGameDataHandleProperty_>*       OutRecipesDef                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UItemsFunctionLibrary::GetRecipesFromTag(class UObject* WorldContextObject, const class FName& Tag, TArray<FGameDataHandleProperty_>* OutRecipesDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemsFunctionLibrary", "GetRecipesFromTag");

	Params::ItemsFunctionLibrary_GetRecipesFromTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRecipesDef != nullptr)
		*OutRecipesDef = std::move(Parms.OutRecipesDef);
}


// Function GbxGame.LightBeamManager.OnParticleSystemFinished
// (Final, Native, Private)
// Parameters:
// class UFXSystemComponent*               FinishedComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALightBeamManager::OnParticleSystemFinished(class UFXSystemComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeamManager", "OnParticleSystemFinished");

	Params::LightBeamManager_OnParticleSystemFinished Parms{};

	Parms.FinishedComponent = FinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.LockOntoTarget
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightBeamAttachment&      target                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightBeam::LockOntoTarget(const struct FLightBeamAttachment& target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "LockOntoTarget");

	Params::LightBeam_LockOntoTarget Parms{};

	Parms.target = std::move(target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.Multicast_SetBoolParamOnFXComponent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::Multicast_SetBoolParamOnFXComponent(class FName ParameterName, bool Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "Multicast_SetBoolParamOnFXComponent");

	Params::LightBeam_Multicast_SetBoolParamOnFXComponent Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.Multicast_SetFloatParamOnFXComponent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::Multicast_SetFloatParamOnFXComponent(class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "Multicast_SetFloatParamOnFXComponent");

	Params::LightBeam_Multicast_SetFloatParamOnFXComponent Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.Multicast_SetIntParamOnFXComponent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::Multicast_SetIntParamOnFXComponent(class FName ParameterName, int32 Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "Multicast_SetIntParamOnFXComponent");

	Params::LightBeam_Multicast_SetIntParamOnFXComponent Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.OnModifierParticleSystemFinished
// (Final, Native, Protected)
// Parameters:
// class UFXSystemComponent*               FinishedComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::OnModifierParticleSystemFinished(class UFXSystemComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "OnModifierParticleSystemFinished");

	Params::LightBeam_OnModifierParticleSystemFinished Parms{};

	Parms.FinishedComponent = FinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.OnRep_ClientState
// (Final, Native, Protected)

void ULightBeam::OnRep_ClientState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "OnRep_ClientState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.OnTrackedImpactParticleSystemFinished
// (Final, Native, Protected)
// Parameters:
// class UFXSystemComponent*               FXComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::OnTrackedImpactParticleSystemFinished(class UFXSystemComponent* FXComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "OnTrackedImpactParticleSystemFinished");

	Params::LightBeam_OnTrackedImpactParticleSystemFinished Parms{};

	Parms.FXComponent = FXComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.SetDamageState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::SetDamageState(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "SetDamageState");

	Params::LightBeam_SetDamageState Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.SetTargetOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::SetTargetOffset(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "SetTargetOffset");

	Params::LightBeam_SetTargetOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.SetTargetSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::SetTargetSocket(class FName socket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "SetTargetSocket");

	Params::LightBeam_SetTargetSocket Parms{};

	Parms.socket = socket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.StartGrowing
// (Final, Native, Public, BlueprintCallable)

void ULightBeam::StartGrowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "StartGrowing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.StartShrinking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDestroyOnEnd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeam::StartShrinking(bool bDestroyOnEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "StartShrinking");

	Params::LightBeam_StartShrinking Parms{};

	Parms.bDestroyOnEnd = bDestroyOnEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.StopGrowing
// (Final, Native, Public, BlueprintCallable)

void ULightBeam::StopGrowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "StopGrowing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.StopShrinking
// (Final, Native, Public, BlueprintCallable)

void ULightBeam::StopShrinking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "StopShrinking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeam.GetAssociatedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELightBeamQueryActorType                ActorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightBeam::GetAssociatedActor(ELightBeamQueryActorType ActorType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetAssociatedActor");

	Params::LightBeam_GetAssociatedActor Parms{};

	Parms.ActorType = ActorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULightBeam::GetDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetDamage");

	Params::LightBeam_GetDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetDamageCauser
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightBeam::GetDamageCauser() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetDamageCauser");

	Params::LightBeam_GetDamageCauser Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetDamageTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDamageTags                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDamageTags ULightBeam::GetDamageTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetDamageTags");

	Params::LightBeam_GetDamageTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetImpactForce
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULightBeam::GetImpactForce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetImpactForce");

	Params::LightBeam_GetImpactForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightBeam::GetInstigator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetInstigator");

	Params::LightBeam_GetInstigator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetNumChildBeams
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULightBeam::GetNumChildBeams() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetNumChildBeams");

	Params::LightBeam_GetNumChildBeams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetParentBeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULightBeam*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightBeam* ULightBeam::GetParentBeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetParentBeam");

	Params::LightBeam_GetParentBeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetRootParentBeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULightBeam*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightBeam* ULightBeam::GetRootParentBeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetRootParentBeam");

	Params::LightBeam_GetRootParentBeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLightBeamAttachment       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FLightBeamAttachment ULightBeam::GetSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetSource");

	Params::LightBeam_GetSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetSourceActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightBeam::GetSourceActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetSourceActor");

	Params::LightBeam_GetSourceActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLightBeamAttachment       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FLightBeamAttachment ULightBeam::GetTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetTarget");

	Params::LightBeam_GetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetTargetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightBeam::GetTargetActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetTargetActor");

	Params::LightBeam_GetTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.GetTimeDilation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULightBeam::GetTimeDilation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "GetTimeDilation");

	Params::LightBeam_GetTimeDilation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.HasDamageModifierFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDamageModifierFlag                     Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightBeam::HasDamageModifierFlag(EDamageModifierFlag Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "HasDamageModifierFlag");

	Params::LightBeam_HasDamageModifierFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeam.InitChildData
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLightBeamSpawnData*             data                                                   (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightBeam::InitChildData(struct FLightBeamSpawnData* data) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "InitChildData");

	Params::LightBeam_InitChildData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (data != nullptr)
		*data = std::move(Parms.data);
}


// Function GbxGame.LightBeam.K2_GetDamageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ ULightBeam::K2_GetDamageType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeam", "K2_GetDamageType");

	Params::LightBeam_K2_GetDamageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeamCollisionHandler.StartBeamImpact
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class ULightBeam*                 Beam                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELightBeamCollisionHandlerResult        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELightBeamCollisionHandlerResult ULightBeamCollisionHandler::StartBeamImpact(const class ULightBeam* Beam, const struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeamCollisionHandler", "StartBeamImpact");

	Params::LightBeamCollisionHandler_StartBeamImpact Parms{};

	Parms.Beam = Beam;
	Parms.Impact = std::move(Impact);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeamCollisionHandler.StopBeamImpact
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class ULightBeam*                 Beam                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                LastImpact                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightBeamCollisionHandler::StopBeamImpact(const class ULightBeam* Beam, const struct FHitResult& LastImpact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeamCollisionHandler", "StopBeamImpact");

	Params::LightBeamCollisionHandler_StopBeamImpact Parms{};

	Parms.Beam = Beam;
	Parms.LastImpact = std::move(LastImpact);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightBeamCollisionHandler.UpdateBeamImpact
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class ULightBeam*                 Beam                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightBeamCollisionHandler::UpdateBeamImpact(const class ULightBeam* Beam, const struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeamCollisionHandler", "UpdateBeamImpact");

	Params::LightBeamCollisionHandler_UpdateBeamImpact Parms{};

	Parms.Beam = Beam;
	Parms.Impact = std::move(Impact);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightBeamScript.OnBegin
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightBeam*                       Beam                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamScript::OnBegin(class ULightBeam* Beam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeamScript", "OnBegin");

	Params::LightBeamScript_OnBegin Parms{};

	Parms.Beam = Beam;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightBeamScript.OnShutdown
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightBeam*                       Beam                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamScript::OnShutdown(class ULightBeam* Beam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightBeamScript", "OnShutdown");

	Params::LightBeamScript_OnShutdown Parms{};

	Parms.Beam = Beam;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightBeamStatics.ClearBeamFlag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLightBeamSpawnData&             data                                                   (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELightBeamFlag                          Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamStatics::ClearBeamFlag(struct FLightBeamSpawnData& data, ELightBeamFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "ClearBeamFlag");

	Params::LightBeamStatics_ClearBeamFlag Parms{};

	Parms.data = std::move(data);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	data = std::move(Parms.data);
}


// Function GbxGame.LightBeamStatics.DoesLightBeamExist
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightBeamQueryData&       Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightBeamStatics::DoesLightBeamExist(const struct FLightBeamQueryData& Query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "DoesLightBeamExist");

	Params::LightBeamStatics_DoesLightBeamExist Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeamStatics.ForEachLightBeam
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightBeamQueryData&       Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TDelegate<void(class ULightBeam* Beam)>&Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamStatics::ForEachLightBeam(const struct FLightBeamQueryData& Query, const TDelegate<void(class ULightBeam* Beam)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "ForEachLightBeam");

	Params::LightBeamStatics_ForEachLightBeam Parms{};

	Parms.Query = std::move(Query);
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeamStatics.IsBeamFlagSet
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FLightBeamSpawnData&       data                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELightBeamFlag                          Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightBeamStatics::IsBeamFlagSet(const struct FLightBeamSpawnData& data, ELightBeamFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "IsBeamFlagSet");

	Params::LightBeamStatics_IsBeamFlagSet Parms{};

	Parms.data = std::move(data);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightBeamStatics.RemoveLightBeamsByActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightBeamQueryData&       Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULightBeamStatics::RemoveLightBeamsByActor(const struct FLightBeamQueryData& Query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "RemoveLightBeamsByActor");

	Params::LightBeamStatics_RemoveLightBeamsByActor Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeamStatics.RemoveLightBeamsBySource
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamStatics::RemoveLightBeamsBySource(class AActor* Source, class FName NameID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "RemoveLightBeamsBySource");

	Params::LightBeamStatics_RemoveLightBeamsBySource Parms{};

	Parms.Source = Source;
	Parms.NameID = NameID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeamStatics.SetBeamFlag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLightBeamSpawnData&             data                                                   (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELightBeamFlag                          Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamStatics::SetBeamFlag(struct FLightBeamSpawnData& data, ELightBeamFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "SetBeamFlag");

	Params::LightBeamStatics_SetBeamFlag Parms{};

	Parms.data = std::move(data);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	data = std::move(Parms.data);
}


// Function GbxGame.LightBeamStatics.SetLightBeamBoolParamBySource
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamStatics::SetLightBeamBoolParamBySource(class AActor* Source, class FName NameID, class FName ParameterName, bool Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "SetLightBeamBoolParamBySource");

	Params::LightBeamStatics_SetLightBeamBoolParamBySource Parms{};

	Parms.Source = Source;
	Parms.NameID = NameID;
	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeamStatics.SetLightBeamFloatParamBySource
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NameID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamStatics::SetLightBeamFloatParamBySource(class AActor* Source, class FName NameID, class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "SetLightBeamFloatParamBySource");

	Params::LightBeamStatics_SetLightBeamFloatParamBySource Parms{};

	Parms.Source = Source;
	Parms.NameID = NameID;
	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeamStatics.SpawnLightBeam
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightBeamSpawnData&       data                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightBeamStatics::SpawnLightBeam(const struct FLightBeamSpawnData& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "SpawnLightBeam");

	Params::LightBeamStatics_SpawnLightBeam Parms{};

	Parms.data = std::move(data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightBeamStatics.SpawnLightBeamAsync
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightBeamSpawnData&       data                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULightBeam**                      LightBeam                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELatentSpawnButton*                     Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ForceSpawnTimer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightBeamStatics::SpawnLightBeamAsync(const struct FLightBeamSpawnData& data, class ULightBeam** LightBeam, ELatentSpawnButton* Exec, const struct FLatentActionInfo& LatentInfo, float ForceSpawnTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightBeamStatics", "SpawnLightBeamAsync");

	Params::LightBeamStatics_SpawnLightBeamAsync Parms{};

	Parms.data = std::move(data);
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.ForceSpawnTimer = ForceSpawnTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LightBeam != nullptr)
		*LightBeam = Parms.LightBeam;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxGame.LightProjectile.ApplyAreaDamage
// (Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreHitActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::ApplyAreaDamage(const struct FVector& Origin, class AActor* HitActor, const struct FHitResult& Hit, bool bIgnoreHitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "ApplyAreaDamage");

	Params::LightProjectile_ApplyAreaDamage Parms{};

	Parms.Origin = std::move(Origin);
	Parms.HitActor = HitActor;
	Parms.Hit = std::move(Hit);
	Parms.bIgnoreHitActor = bIgnoreHitActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.Destroy
// (Final, Native, Public, BlueprintCallable)

void ULightProjectile::Destroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "Destroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.Explode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestroyProjectile                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::Explode(float delay, bool bDestroyProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "Explode");

	Params::LightProjectile_Explode Parms{};

	Parms.delay = delay;
	Parms.bDestroyProjectile = bDestroyProjectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.K2_ApplyImpactDamage
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ImpactDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPenetrated                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanReflect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::K2_ApplyImpactDamage(const struct FHitResult& Hit, float ImpactDamage, bool bPenetrated, bool bCanReflect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "K2_ApplyImpactDamage");

	Params::LightProjectile_K2_ApplyImpactDamage Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ImpactDamage = ImpactDamage;
	Parms.bPenetrated = bPenetrated;
	Parms.bCanReflect = bCanReflect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnAttachedActorDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::OnAttachedActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnAttachedActorDestroyed");

	Params::LightProjectile_OnAttachedActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnAttachedActorFractured
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   HitPoint                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::OnAttachedActorFractured(const struct FVector& HitPoint, const struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnAttachedActorFractured");

	Params::LightProjectile_OnAttachedActorFractured Parms{};

	Parms.HitPoint = std::move(HitPoint);
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnAttachedComponentCollisionChanged
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              ChangedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::OnAttachedComponentCollisionChanged(class UPrimitiveComponent* ChangedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnAttachedComponentCollisionChanged");

	Params::LightProjectile_OnAttachedComponentCollisionChanged Parms{};

	Parms.ChangedComponent = ChangedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnAttachedComponentUnregistered
// (Final, Native, Protected)
// Parameters:
// class UActorComponent*                  UnregisteredComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::OnAttachedComponentUnregistered(class UActorComponent* UnregisteredComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnAttachedComponentUnregistered");

	Params::LightProjectile_OnAttachedComponentUnregistered Parms{};

	Parms.UnregisteredComponent = UnregisteredComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnAttachedDestructibleFractured
// (Final, Native, Protected)
// Parameters:
// bool                                    bMeshSwap                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::OnAttachedDestructibleFractured(bool bMeshSwap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnAttachedDestructibleFractured");

	Params::LightProjectile_OnAttachedDestructibleFractured Parms{};

	Parms.bMeshSwap = bMeshSwap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnHomingTargetDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::OnHomingTargetDestroyed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnHomingTargetDestroyed");

	Params::LightProjectile_OnHomingTargetDestroyed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnParticleSystemFinished
// (Final, Native, Protected)
// Parameters:
// class UFXSystemComponent*               FinishedComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::OnParticleSystemFinished(class UFXSystemComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnParticleSystemFinished");

	Params::LightProjectile_OnParticleSystemFinished Parms{};

	Parms.FinishedComponent = FinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnRep_Attached
// (Final, Native, Protected)

void ULightProjectile::OnRep_Attached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnRep_Attached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnRep_ClientState
// (Final, Native, Protected)

void ULightProjectile::OnRep_ClientState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnRep_ClientState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnRep_Exploded
// (Final, Native, Protected)

void ULightProjectile::OnRep_Exploded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnRep_Exploded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnRep_Impact
// (Final, Native, Protected)

void ULightProjectile::OnRep_Impact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnRep_Impact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.OnRep_Shutdown
// (Final, Native, Protected)

void ULightProjectile::OnRep_Shutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "OnRep_Shutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.SetDrunkenMovementState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::SetDrunkenMovementState(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "SetDrunkenMovementState");

	Params::LightProjectile_SetDrunkenMovementState Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.SetHoming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHoming                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::SetHoming(bool bHoming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "SetHoming");

	Params::LightProjectile_SetHoming Parms{};

	Parms.bHoming = bHoming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.SetHomingTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::SetHomingTarget(class AActor* Actor, class USceneComponent* Component, class FName socket, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "SetHomingTarget");

	Params::LightProjectile_SetHomingTarget Parms{};

	Parms.Actor = Actor;
	Parms.Component = Component;
	Parms.socket = socket;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.SetHomingTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::SetHomingTargetLocation(const struct FVector& Location_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "SetHomingTargetLocation");

	Params::LightProjectile_SetHomingTargetLocation Parms{};

	Parms.Location_0 = std::move(Location_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.SetLifetime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLifetime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectile::SetLifetime(float NewLifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "SetLifetime");

	Params::LightProjectile_SetLifetime Parms{};

	Parms.NewLifetime = NewLifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectile.GetAssociatedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELightProjectileQueryActorType          ActorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightProjectile::GetAssociatedActor(ELightProjectileQueryActorType ActorType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetAssociatedActor");

	Params::LightProjectile_GetAssociatedActor Parms{};

	Parms.ActorType = ActorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetAttachedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightProjectile::GetAttachedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetAttachedActor");

	Params::LightProjectile_GetAttachedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetAttachedDamageReceiverActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightProjectile::GetAttachedDamageReceiverActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetAttachedDamageReceiverActor");

	Params::LightProjectile_GetAttachedDamageReceiverActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetAttachedImpactNormal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULightProjectile::GetAttachedImpactNormal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetAttachedImpactNormal");

	Params::LightProjectile_GetAttachedImpactNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetAttitudeTowards
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude ULightProjectile::GetAttitudeTowards(class AActor* TargetActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetAttitudeTowards");

	Params::LightProjectile_GetAttitudeTowards Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetDamageCauser
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightProjectile::GetDamageCauser() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetDamageCauser");

	Params::LightProjectile_GetDamageCauser Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetDamageTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDamageTags                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDamageTags ULightProjectile::GetDamageTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetDamageTags");

	Params::LightProjectile_GetDamageTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetFiringPatternID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ULightProjectile::GetFiringPatternID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetFiringPatternID");

	Params::LightProjectile_GetFiringPatternID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetGpsQueryName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULightProjectile::GetGpsQueryName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetGpsQueryName");

	Params::LightProjectile_GetGpsQueryName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightProjectile::GetInstigator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetInstigator");

	Params::LightProjectile_GetInstigator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightProjectile::GetSource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetSource");

	Params::LightProjectile_GetSource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.GetTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULightProjectile::GetTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "GetTarget");

	Params::LightProjectile_GetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.HasDamageModifierFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDamageModifierFlag                     Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightProjectile::HasDamageModifierFlag(EDamageModifierFlag Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "HasDamageModifierFlag");

	Params::LightProjectile_HasDamageModifierFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.InitChildData
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLightProjectileSpawnData*       data                                                   (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightProjectile::InitChildData(struct FLightProjectileSpawnData* data) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "InitChildData");

	Params::LightProjectile_InitChildData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (data != nullptr)
		*data = std::move(Parms.data);
}


// Function GbxGame.LightProjectile.IsAuthority
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightProjectile::IsAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "IsAuthority");

	Params::LightProjectile_IsAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.IsHoming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightProjectile::IsHoming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "IsHoming");

	Params::LightProjectile_IsHoming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectile.K2_GetDamageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ ULightProjectile::K2_GetDamageType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectile", "K2_GetDamageType");

	Params::LightProjectile_K2_GetDamageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectileScript.OnAttached
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AttachedActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnAttached(class ULightProjectile* projectile, class AActor* AttachedActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnAttached");

	Params::LightProjectileScript_OnAttached Parms{};

	Parms.projectile = projectile;
	Parms.AttachedActor = AttachedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnBegin
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnBegin(class ULightProjectile* projectile) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnBegin");

	Params::LightProjectileScript_OnBegin Parms{};

	Parms.projectile = projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnBounce
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   ImpactVelocity                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnBounce(class ULightProjectile* projectile, const struct FHitResult& Hit, const struct FVector& ImpactVelocity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnBounce");

	Params::LightProjectileScript_OnBounce Parms{};

	Parms.projectile = projectile;
	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnDetached
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnDetached(class ULightProjectile* projectile) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnDetached");

	Params::LightProjectileScript_OnDetached Parms{};

	Parms.projectile = projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnDirectDamage
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bCritical                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnDirectDamage(class ULightProjectile* projectile, const struct FHitResult& Hit, bool bCritical) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnDirectDamage");

	Params::LightProjectileScript_OnDirectDamage Parms{};

	Parms.projectile = projectile;
	Parms.Hit = std::move(Hit);
	Parms.bCritical = bCritical;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnExplode
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnExplode(class ULightProjectile* projectile) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnExplode");

	Params::LightProjectileScript_OnExplode Parms{};

	Parms.projectile = projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnGameplayBounce
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   ImpactVelocity                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnGameplayBounce(class ULightProjectile* projectile, const struct FHitResult& Hit, const struct FVector& ImpactVelocity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnGameplayBounce");

	Params::LightProjectileScript_OnGameplayBounce Parms{};

	Parms.projectile = projectile;
	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnHomingTargetLost
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHomingTargetLostReason                 reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnHomingTargetLost(class ULightProjectile* projectile, EHomingTargetLostReason reason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnHomingTargetLost");

	Params::LightProjectileScript_OnHomingTargetLost Parms{};

	Parms.projectile = projectile;
	Parms.reason = reason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnHomingTargetReached
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnHomingTargetReached(class ULightProjectile* projectile) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnHomingTargetReached");

	Params::LightProjectileScript_OnHomingTargetReached Parms{};

	Parms.projectile = projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnImpact
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnImpact(class ULightProjectile* projectile, const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnImpact");

	Params::LightProjectileScript_OnImpact Parms{};

	Parms.projectile = projectile;
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnLastGameplayBounce
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnLastGameplayBounce(class ULightProjectile* projectile, const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnLastGameplayBounce");

	Params::LightProjectileScript_OnLastGameplayBounce Parms{};

	Parms.projectile = projectile;
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnLifetimeExpired
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnLifetimeExpired(class ULightProjectile* projectile) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnLifetimeExpired");

	Params::LightProjectileScript_OnLifetimeExpired Parms{};

	Parms.projectile = projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnNonGameplayBounce
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   ImpactVelocity                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnNonGameplayBounce(class ULightProjectile* projectile, const struct FHitResult& Hit, const struct FVector& ImpactVelocity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnNonGameplayBounce");

	Params::LightProjectileScript_OnNonGameplayBounce Parms{};

	Parms.projectile = projectile;
	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnProxyImpact
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnProxyImpact(class ULightProjectile* projectile, const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnProxyImpact");

	Params::LightProjectileScript_OnProxyImpact Parms{};

	Parms.projectile = projectile;
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileScript.OnStopHomingDistanceReached
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ULightProjectile*                 projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileScript::OnStopHomingDistanceReached(class ULightProjectile* projectile) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightProjectileScript", "OnStopHomingDistanceReached");

	Params::LightProjectileScript_OnStopHomingDistanceReached Parms{};

	Parms.projectile = projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxGame.LightProjectileStatics.BindDelegateOnLightProjectileHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           ProjectileSource                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(const struct FHitResult& HitResult)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::BindDelegateOnLightProjectileHit(class AActor* ProjectileSource, const TDelegate<void(const struct FHitResult& HitResult)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "BindDelegateOnLightProjectileHit");

	Params::LightProjectileStatics_BindDelegateOnLightProjectileHit Parms{};

	Parms.ProjectileSource = ProjectileSource;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.ClearProjectileFlag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLightProjectileSpawnData&       data                                                   (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELightProjectileFlag                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::ClearProjectileFlag(struct FLightProjectileSpawnData& data, ELightProjectileFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "ClearProjectileFlag");

	Params::LightProjectileStatics_ClearProjectileFlag Parms{};

	Parms.data = std::move(data);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	data = std::move(Parms.data);
}


// Function GbxGame.LightProjectileStatics.DetonateLightProjectiles
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileQueryData& Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   StackingEnemyBonusDamage                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDetonationDelay                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDetonationDelay                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequireProjectileBeAttached                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::DetonateLightProjectiles(const struct FLightProjectileQueryData& Query, float StackingEnemyBonusDamage, float MinDetonationDelay, float MaxDetonationDelay, bool bRequireProjectileBeAttached)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "DetonateLightProjectiles");

	Params::LightProjectileStatics_DetonateLightProjectiles Parms{};

	Parms.Query = std::move(Query);
	Parms.StackingEnemyBonusDamage = StackingEnemyBonusDamage;
	Parms.MinDetonationDelay = MinDetonationDelay;
	Parms.MaxDetonationDelay = MaxDetonationDelay;
	Parms.bRequireProjectileBeAttached = bRequireProjectileBeAttached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.ForEachLightProjectile
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileQueryData& Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TDelegate<void(class ULightProjectile* projectile)>&Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::ForEachLightProjectile(const struct FLightProjectileQueryData& Query, const TDelegate<void(class ULightProjectile* projectile)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "ForEachLightProjectile");

	Params::LightProjectileStatics_ForEachLightProjectile Parms{};

	Parms.Query = std::move(Query);
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.IsProjectileFlagSet
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FLightProjectileSpawnData& data                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELightProjectileFlag                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightProjectileStatics::IsProjectileFlagSet(const struct FLightProjectileSpawnData& data, ELightProjectileFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "IsProjectileFlagSet");

	Params::LightProjectileStatics_IsProjectileFlagSet Parms{};

	Parms.data = std::move(data);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.LightProjectileStatics.RemoveLightProjectilesByActor
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileQueryData& Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULightProjectileStatics::RemoveLightProjectilesByActor(const struct FLightProjectileQueryData& Query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "RemoveLightProjectilesByActor");

	Params::LightProjectileStatics_RemoveLightProjectilesByActor Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SetHomingState
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileQueryData& Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsHoming                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SetHomingState(const struct FLightProjectileQueryData& Query, bool bIsHoming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SetHomingState");

	Params::LightProjectileStatics_SetHomingState Parms{};

	Parms.Query = std::move(Query);
	Parms.bIsHoming = bIsHoming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SetProjectileFlag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLightProjectileSpawnData&       data                                                   (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELightProjectileFlag                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SetProjectileFlag(struct FLightProjectileSpawnData& data, ELightProjectileFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SetProjectileFlag");

	Params::LightProjectileStatics_SetProjectileFlag Parms{};

	Parms.data = std::move(data);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	data = std::move(Parms.data);
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectile
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileSpawnData& data                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectile(const struct FLightProjectileSpawnData& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectile");

	Params::LightProjectileStatics_SpawnLightProjectile Parms{};

	Parms.data = std::move(data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectile_Source
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FLightProjectileSpawnData& ProjectileData                                         (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectile_Source(const struct FLightProjectileSpawnData& ProjectileData, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectile_Source");

	Params::LightProjectileStatics_SpawnLightProjectile_Source Parms{};

	Parms.ProjectileData = std::move(ProjectileData);
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectile_ThrowAtActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileSpawnData& ProjectileData                                         (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSourceIsInstigator                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectile_ThrowAtActor(const struct FLightProjectileSpawnData& ProjectileData, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, bool bSourceIsInstigator, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectile_ThrowAtActor");

	Params::LightProjectileStatics_SpawnLightProjectile_ThrowAtActor Parms{};

	Parms.ProjectileData = std::move(ProjectileData);
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bSourceIsInstigator = bSourceIsInstigator;
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectile_ThrowAtCrosshair
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileSpawnData& ProjectileData                                         (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSourceIsInstigator                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectile_ThrowAtCrosshair(const struct FLightProjectileSpawnData& ProjectileData, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FTrajectoryOptions& TrajectoryOptions, float TraceDistance, bool bSourceIsInstigator, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectile_ThrowAtCrosshair");

	Params::LightProjectileStatics_SpawnLightProjectile_ThrowAtCrosshair Parms{};

	Parms.ProjectileData = std::move(ProjectileData);
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.TraceDistance = TraceDistance;
	Parms.bSourceIsInstigator = bSourceIsInstigator;
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectile_ThrowAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLightProjectileSpawnData& ProjectileData                                         (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSourceIsInstigator                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectile_ThrowAtLocation(const struct FLightProjectileSpawnData& ProjectileData, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FVector& Location, const struct FTrajectoryOptions& TrajectoryOptions, bool bSourceIsInstigator, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectile_ThrowAtLocation");

	Params::LightProjectileStatics_SpawnLightProjectile_ThrowAtLocation Parms{};

	Parms.ProjectileData = std::move(ProjectileData);
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.Location = std::move(Location);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.bSourceIsInstigator = bSourceIsInstigator;
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectileAsync
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileSpawnData& data                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ForceSpawnTimer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectileAsync(const struct FLightProjectileSpawnData& data, float ForceSpawnTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectileAsync");

	Params::LightProjectileStatics_SpawnLightProjectileAsync Parms{};

	Parms.data = std::move(data);
	Parms.ForceSpawnTimer = ForceSpawnTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectiles_Query
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnProjectileExec*                   Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLightProjectileSpawnData& ProjectileData                                         (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      Rotation                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectiles_Query(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, ESpawnProjectileExec* Exec, const struct FLightProjectileSpawnData& ProjectileData, class AActor* owner, const struct FGpsQueryRunData& QueryData, const struct FGbxRelativeRotation& Rotation, int32 MaxResults, float delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectiles_Query");

	Params::LightProjectileStatics_SpawnLightProjectiles_Query Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.ProjectileData = std::move(ProjectileData);
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.Rotation = std::move(Rotation);
	Parms.MaxResults = MaxResults;
	Parms.delay = delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;
}


// Function GbxGame.LightProjectileStatics.SpawnLightProjectiles_Query_Const
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLightProjectileSpawnData& ProjectileData                                         (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      Rotation                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::SpawnLightProjectiles_Query_Const(const struct FLightProjectileSpawnData& ProjectileData, class AActor* owner, const struct FGpsQueryRunData& QueryData, const struct FGbxRelativeRotation& Rotation, int32 MaxResults, float delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "SpawnLightProjectiles_Query_Const");

	Params::LightProjectileStatics_SpawnLightProjectiles_Query_Const Parms{};

	Parms.ProjectileData = std::move(ProjectileData);
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.Rotation = std::move(Rotation);
	Parms.MaxResults = MaxResults;
	Parms.delay = delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LightProjectileStatics.UnbindDelegateOnLightProjectileHit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ProjectileSource                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightProjectileStatics::UnbindDelegateOnLightProjectileHit(class AActor* ProjectileSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightProjectileStatics", "UnbindDelegateOnLightProjectileHit");

	Params::LightProjectileStatics_UnbindDelegateOnLightProjectileHit Parms{};

	Parms.ProjectileSource = ProjectileSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LootFunctionLibrary.OutputGearStatsToCSV
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FInventoryItemSelectionData&item                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   NumberToGenerate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   gamestage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    OutputFileName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutputDefaultStats                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FCSVStatColumn>&    Columns                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   usemodebitmask                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECSVIdentityFormat                      OutputIdentityFormat                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULootFunctionLibrary::OutputGearStatsToCSV(class UObject* ContextObject, const struct FLatentActionInfo& LatentInfo, const struct FInventoryItemSelectionData& item, int32 NumberToGenerate, int32 gamestage, const class FString& OutputFileName, bool bOutputDefaultStats, const TArray<struct FCSVStatColumn>& Columns, int32 usemodebitmask, ECSVIdentityFormat OutputIdentityFormat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LootFunctionLibrary", "OutputGearStatsToCSV");

	Params::LootFunctionLibrary_OutputGearStatsToCSV Parms{};

	Parms.ContextObject = ContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.item = std::move(item);
	Parms.NumberToGenerate = NumberToGenerate;
	Parms.gamestage = gamestage;
	Parms.OutputFileName = std::move(OutputFileName);
	Parms.bOutputDefaultStats = bOutputDefaultStats;
	Parms.Columns = std::move(Columns);
	Parms.usemodebitmask = usemodebitmask;
	Parms.OutputIdentityFormat = OutputIdentityFormat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LootFunctionLibrary.SpawnLootFromConfig_Attach
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                LootConfig                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELootInstancingPolicy                   InstancingPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstancedFor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULootFunctionLibrary::SpawnLootFromConfig_Attach(class AActor* SourceActor, FGameDataHandleProperty_ LootConfig, ELootInstancingPolicy InstancingPolicy, class AActor* InstancedFor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LootFunctionLibrary", "SpawnLootFromConfig_Attach");

	Params::LootFunctionLibrary_SpawnLootFromConfig_Attach Parms{};

	Parms.SourceActor = SourceActor;
	Parms.LootConfig = LootConfig;
	Parms.InstancingPolicy = InstancingPolicy;
	Parms.InstancedFor = InstancedFor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LootFunctionLibrary.SpawnLootFromData_Attach
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryItemSelectionData&item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ELootInstancingPolicy                   InstancingPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstancedFor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULootFunctionLibrary::SpawnLootFromData_Attach(class AActor* SourceActor, const struct FInventoryItemSelectionData& item, ELootInstancingPolicy InstancingPolicy, class AActor* InstancedFor, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LootFunctionLibrary", "SpawnLootFromData_Attach");

	Params::LootFunctionLibrary_SpawnLootFromData_Attach Parms{};

	Parms.SourceActor = SourceActor;
	Parms.item = std::move(item);
	Parms.InstancingPolicy = InstancingPolicy;
	Parms.InstancedFor = InstancedFor;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LootFunctionLibrary.SpawnLootFromData_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ContextActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryItemSelectionData&item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ELootInstancingPolicy                   InstancingPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstancedFor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                SpawnPattern                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SourceTransform                                        (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULootFunctionLibrary::SpawnLootFromData_Drop(class AActor* ContextActor, const struct FInventoryItemSelectionData& item, ELootInstancingPolicy InstancingPolicy, class AActor* InstancedFor, FGameDataHandleProperty_ SpawnPattern, class FName SocketName, const struct FTransform& SourceTransform, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LootFunctionLibrary", "SpawnLootFromData_Drop");

	Params::LootFunctionLibrary_SpawnLootFromData_Drop Parms{};

	Parms.ContextActor = ContextActor;
	Parms.item = std::move(item);
	Parms.InstancingPolicy = InstancingPolicy;
	Parms.InstancedFor = InstancedFor;
	Parms.SpawnPattern = SpawnPattern;
	Parms.SocketName = SocketName;
	Parms.SourceTransform = std::move(SourceTransform);
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LootFunctionLibrary.SpawnLootFromDef_Attach
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                item                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELootInstancingPolicy                   InstancingPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstancedFor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULootFunctionLibrary::SpawnLootFromDef_Attach(class AActor* SourceActor, FGameDataHandleProperty_ item, ELootInstancingPolicy InstancingPolicy, class AActor* InstancedFor, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LootFunctionLibrary", "SpawnLootFromDef_Attach");

	Params::LootFunctionLibrary_SpawnLootFromDef_Attach Parms{};

	Parms.SourceActor = SourceActor;
	Parms.item = item;
	Parms.InstancingPolicy = InstancingPolicy;
	Parms.InstancedFor = InstancedFor;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.LootFunctionLibrary.SpawnLootFromDef_Drop
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ContextActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                item                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELootInstancingPolicy                   InstancingPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstancedFor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                SpawnPattern                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                SourceTransform                                        (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULootFunctionLibrary::SpawnLootFromDef_Drop(class AActor* ContextActor, FGameDataHandleProperty_ item, ELootInstancingPolicy InstancingPolicy, class AActor* InstancedFor, FGameDataHandleProperty_ SpawnPattern, class FName SocketName, const struct FTransform& SourceTransform, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LootFunctionLibrary", "SpawnLootFromDef_Drop");

	Params::LootFunctionLibrary_SpawnLootFromDef_Drop Parms{};

	Parms.ContextActor = ContextActor;
	Parms.item = item;
	Parms.InstancingPolicy = InstancingPolicy;
	Parms.InstancedFor = InstancedFor;
	Parms.SpawnPattern = SpawnPattern;
	Parms.SocketName = SocketName;
	Parms.SourceTransform = std::move(SourceTransform);
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.MissionBlueprintLibrary.GetOrCreateMissionInstanceForPlayer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FMissionInstanceHandle&    primarymission                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionInstanceHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMissionInstanceHandle UMissionBlueprintLibrary::GetOrCreateMissionInstanceForPlayer(const struct FMissionInstanceHandle& primarymission, const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "GetOrCreateMissionInstanceForPlayer");

	Params::MissionBlueprintLibrary_GetOrCreateMissionInstanceForPlayer Parms{};

	Parms.primarymission = std::move(primarymission);
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionBlueprintLibrary.GetOrCreateMissionInstanceForPlayerGroup
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FMissionInstanceHandle&    primarymission                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionInstanceHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMissionInstanceHandle UMissionBlueprintLibrary::GetOrCreateMissionInstanceForPlayerGroup(const struct FMissionInstanceHandle& primarymission, const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "GetOrCreateMissionInstanceForPlayerGroup");

	Params::MissionBlueprintLibrary_GetOrCreateMissionInstanceForPlayerGroup Parms{};

	Parms.primarymission = std::move(primarymission);
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionBlueprintLibrary.IsActorPartOfActiveMission
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMissionBlueprintLibrary::IsActorPartOfActiveMission(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "IsActorPartOfActiveMission");

	Params::MissionBlueprintLibrary_IsActorPartOfActiveMission Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionBlueprintLibrary.IsPlayerRelevantForMissionInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMissionInstanceHandle&    MissionHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMissionBlueprintLibrary::IsPlayerRelevantForMissionInstance(class UObject* WorldContextObject, const struct FMissionInstanceHandle& MissionHandle, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "IsPlayerRelevantForMissionInstance");

	Params::MissionBlueprintLibrary_IsPlayerRelevantForMissionInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MissionHandle = std::move(MissionHandle);
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionBlueprintLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMissionInstanceHandle&    MissionHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMissionBlueprintLibrary::IsValid(const struct FMissionInstanceHandle& MissionHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "IsValid");

	Params::MissionBlueprintLibrary_IsValid Parms{};

	Parms.MissionHandle = std::move(MissionHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionBlueprintLibrary.QueryPrimaryMissionInstance
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     MissionDef                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionInstanceHandle*          OutMission                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UMissionBlueprintLibrary::QueryPrimaryMissionInstance(class UObject* WorldContextObject, FGbxDefPtrProperty_ MissionDef, struct FMissionInstanceHandle* OutMission)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "QueryPrimaryMissionInstance");

	Params::MissionBlueprintLibrary_QueryPrimaryMissionInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MissionDef = MissionDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMission != nullptr)
		*OutMission = std::move(Parms.OutMission);
}


// Function GbxGame.MissionBlueprintLibrary.QuerySubordinateMissionInstancesForPlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     MissionDef                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMissionInstanceHandle>*  OutMissions                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMissionBlueprintLibrary::QuerySubordinateMissionInstancesForPlayer(class UObject* WorldContextObject, FGbxDefPtrProperty_ MissionDef, class AActor* Actor, TArray<struct FMissionInstanceHandle>* OutMissions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "QuerySubordinateMissionInstancesForPlayer");

	Params::MissionBlueprintLibrary_QuerySubordinateMissionInstancesForPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MissionDef = MissionDef;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMissions != nullptr)
		*OutMissions = std::move(Parms.OutMissions);
}


// Function GbxGame.MissionBlueprintLibrary.SendMissionEvent
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     mission                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Event                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionBlueprintLibrary::SendMissionEvent(class UObject* WorldContextObject, FGbxDefPtrProperty_ mission, class FName Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionBlueprintLibrary", "SendMissionEvent");

	Params::MissionBlueprintLibrary_SendMissionEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.mission = mission;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.MissionBlueprintLibrary.GetMissionIdent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMissionInstanceHandle&    MissionInstanceHandle                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMissionBlueprintLibrary::GetMissionIdent(const struct FMissionInstanceHandle& MissionInstanceHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionBlueprintLibrary", "GetMissionIdent");

	Params::MissionBlueprintLibrary_GetMissionIdent Parms{};

	Parms.MissionInstanceHandle = std::move(MissionInstanceHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionSourceBlueprintLibrary.AddMissionSource
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     MSDef                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSToken*                         OutIndex                                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionSourceBlueprintLibrary::AddMissionSource(class AActor* Origin, FGbxDefPtrProperty_ MSDef, struct FSToken* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "AddMissionSource");

	Params::MissionSourceBlueprintLibrary_AddMissionSource Parms{};

	Parms.Origin = Origin;
	Parms.MSDef = MSDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = std::move(Parms.OutIndex);
}


// Function GbxGame.MissionSourceBlueprintLibrary.GetBestMission
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MSIndex                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMissionInstanceHandle>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FMissionInstanceHandle> UMissionSourceBlueprintLibrary::GetBestMission(class AActor* Origin, const struct FSToken& MSIndex, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "GetBestMission");

	Params::MissionSourceBlueprintLibrary_GetBestMission Parms{};

	Parms.Origin = Origin;
	Parms.MSIndex = std::move(MSIndex);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionSourceBlueprintLibrary.GetMissionSource
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     MSDef                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSToken*                         OutIndex                                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionSourceBlueprintLibrary::GetMissionSource(class AActor* Origin, FGbxDefPtrProperty_ MSDef, struct FSToken* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "GetMissionSource");

	Params::MissionSourceBlueprintLibrary_GetMissionSource Parms{};

	Parms.Origin = Origin;
	Parms.MSDef = MSDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = std::move(Parms.OutIndex);
}


// Function GbxGame.MissionSourceBlueprintLibrary.GetMissionSourceRank
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MSIndex                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutRank                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionSourceBlueprintLibrary::GetMissionSourceRank(class AActor* Origin, const struct FSToken& MSIndex, int32* OutRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "GetMissionSourceRank");

	Params::MissionSourceBlueprintLibrary_GetMissionSourceRank Parms{};

	Parms.Origin = Origin;
	Parms.MSIndex = std::move(MSIndex);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRank != nullptr)
		*OutRank = Parms.OutRank;
}


// Function GbxGame.MissionSourceBlueprintLibrary.GetMissionSourceTimerTimeRemaining
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MSIndex                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   TimerLabel                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutRemainingTime                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionSourceBlueprintLibrary::GetMissionSourceTimerTimeRemaining(class AActor* Origin, const struct FSToken& MSIndex, const struct FSToken& TimerLabel, float* OutRemainingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "GetMissionSourceTimerTimeRemaining");

	Params::MissionSourceBlueprintLibrary_GetMissionSourceTimerTimeRemaining Parms{};

	Parms.Origin = Origin;
	Parms.MSIndex = std::move(MSIndex);
	Parms.TimerLabel = std::move(TimerLabel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRemainingTime != nullptr)
		*OutRemainingTime = Parms.OutRemainingTime;
}


// Function GbxGame.MissionSourceBlueprintLibrary.SetMissionSourceRank
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MSIndex                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFactValue&                Rank                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMissionSourceBlueprintLibrary::SetMissionSourceRank(class AActor* Origin, const struct FSToken& MSIndex, const struct FFactValue& Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "SetMissionSourceRank");

	Params::MissionSourceBlueprintLibrary_SetMissionSourceRank Parms{};

	Parms.Origin = Origin;
	Parms.MSIndex = std::move(MSIndex);
	Parms.Rank = std::move(Rank);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.MissionSourceBlueprintLibrary.StartBestMission
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MSIndex                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionInstanceHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMissionInstanceHandle UMissionSourceBlueprintLibrary::StartBestMission(class AActor* Origin, const struct FSToken& MSIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "StartBestMission");

	Params::MissionSourceBlueprintLibrary_StartBestMission Parms{};

	Parms.Origin = Origin;
	Parms.MSIndex = std::move(MSIndex);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionSourceBlueprintLibrary.StartMissionSourceMission
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MSIndex                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MissionName                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionInstanceHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMissionInstanceHandle UMissionSourceBlueprintLibrary::StartMissionSourceMission(class AActor* Origin, const struct FSToken& MSIndex, const struct FSToken& MissionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "StartMissionSourceMission");

	Params::MissionSourceBlueprintLibrary_StartMissionSourceMission Parms{};

	Parms.Origin = Origin;
	Parms.MSIndex = std::move(MSIndex);
	Parms.MissionName = std::move(MissionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionSourceBlueprintLibrary.StartMissionSourceTimer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Origin                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSToken&                   MSIndex                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TimerName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutRemainingTime                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionSourceBlueprintLibrary::StartMissionSourceTimer(class AActor* Origin, const struct FSToken& MSIndex, class FName TimerName, float* OutRemainingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionSourceBlueprintLibrary", "StartMissionSourceTimer");

	Params::MissionSourceBlueprintLibrary_StartMissionSourceTimer Parms{};

	Parms.Origin = Origin;
	Parms.MSIndex = std::move(MSIndex);
	Parms.TimerName = TimerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRemainingTime != nullptr)
		*OutRemainingTime = Parms.OutRemainingTime;
}


// Function GbxGame.MissionTaskBlueprintLibrary.AssignTaskToGlobal
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     TaskDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    TaskOrigin                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSToken                          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSToken UMissionTaskBlueprintLibrary::AssignTaskToGlobal(class UObject* WorldContext, FGbxDefPtrProperty_ TaskDef, const class FString& TaskOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionTaskBlueprintLibrary", "AssignTaskToGlobal");

	Params::MissionTaskBlueprintLibrary_AssignTaskToGlobal Parms{};

	Parms.WorldContext = WorldContext;
	Parms.TaskDef = TaskDef;
	Parms.TaskOrigin = std::move(TaskOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionTaskBlueprintLibrary.AssignTaskToPlayer
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     PlayerActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     TaskDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    TaskOrigin                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSToken                          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSToken UMissionTaskBlueprintLibrary::AssignTaskToPlayer(const class AActor* PlayerActor, FGbxDefPtrProperty_ TaskDef, const class FString& TaskOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionTaskBlueprintLibrary", "AssignTaskToPlayer");

	Params::MissionTaskBlueprintLibrary_AssignTaskToPlayer Parms{};

	Parms.PlayerActor = PlayerActor;
	Parms.TaskDef = TaskDef;
	Parms.TaskOrigin = std::move(TaskOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionTaskBlueprintLibrary.AssignTaskToPlayerGroup
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     PlayerActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGbxDefPtrProperty_                     TaskDef                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    TaskOrigin                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSToken                          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSToken UMissionTaskBlueprintLibrary::AssignTaskToPlayerGroup(const class AActor* PlayerActor, FGbxDefPtrProperty_ TaskDef, const class FString& TaskOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionTaskBlueprintLibrary", "AssignTaskToPlayerGroup");

	Params::MissionTaskBlueprintLibrary_AssignTaskToPlayerGroup Parms{};

	Parms.PlayerActor = PlayerActor;
	Parms.TaskDef = TaskDef;
	Parms.TaskOrigin = std::move(TaskOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionTaskBlueprintLibrary.MakeMissionTaskTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMissionTaskTags&          tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMissionTaskTags                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMissionTaskTags UMissionTaskBlueprintLibrary::MakeMissionTaskTags(const struct FMissionTaskTags& tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionTaskBlueprintLibrary", "MakeMissionTaskTags");

	Params::MissionTaskBlueprintLibrary_MakeMissionTaskTags Parms{};

	Parms.tags = std::move(tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.MissionTaskBlueprintLibrary.QueryMissionTasks
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMissionTaskTags&          RequiredTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<FGbxDefPtrProperty_>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<FGbxDefPtrProperty_> UMissionTaskBlueprintLibrary::QueryMissionTasks(const struct FMissionTaskTags& RequiredTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MissionTaskBlueprintLibrary", "QueryMissionTasks");

	Params::MissionTaskBlueprintLibrary_QueryMissionTasks Parms{};

	Parms.RequiredTags = std::move(RequiredTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ProjectileStatics.GetProjectileDistanceOverTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UProjectileStatics::GetProjectileDistanceOverTime(FGameDataHandleProperty_ definition, float time, float SpeedOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "GetProjectileDistanceOverTime");

	Params::ProjectileStatics_GetProjectileDistanceOverTime Parms{};

	Parms.definition = definition;
	Parms.time = time;
	Parms.SpeedOverride = SpeedOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ProjectileStatics.GetProjectileTimeOverDistance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UProjectileStatics::GetProjectileTimeOverDistance(FGameDataHandleProperty_ definition, float Distance, float SpeedOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "GetProjectileTimeOverDistance");

	Params::ProjectileStatics_GetProjectileTimeOverDistance Parms{};

	Parms.definition = definition;
	Parms.Distance = Distance;
	Parms.SpeedOverride = SpeedOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ProjectileStatics.GetSafeProjectileThrowTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UProjectileStatics::GetSafeProjectileThrowTransform(class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const TArray<class AActor*>& IgnoreActors, ECollisionChannel TraceChannel, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "GetSafeProjectileThrowTransform");

	Params::ProjectileStatics_GetSafeProjectileThrowTransform Parms{};

	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.TraceChannel = TraceChannel;
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ProjectileStatics.GetSafeProjectileThrowTransformFromLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseAnimatedCameraRotation                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UProjectileStatics::GetSafeProjectileThrowTransformFromLocation(class AActor* Source, const struct FVector& Location, const TArray<class AActor*>& IgnoreActors, ECollisionChannel TraceChannel, bool bUseAnimatedCameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "GetSafeProjectileThrowTransformFromLocation");

	Params::ProjectileStatics_GetSafeProjectileThrowTransformFromLocation Parms{};

	Parms.Source = Source;
	Parms.Location = std::move(Location);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.TraceChannel = TraceChannel;
	Parms.bUseAnimatedCameraRotation = bUseAnimatedCameraRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ProjectileStatics.MakeViewRelativeLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxViewRelativeLocation         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGbxViewRelativeLocation UProjectileStatics::MakeViewRelativeLocation(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "MakeViewRelativeLocation");

	Params::ProjectileStatics_MakeViewRelativeLocation Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class Aprojectile**                     projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOwnerIsInstigator                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GravityScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, class Aprojectile** projectile, FGameDataHandleProperty_ definition, class AActor* owner, bool bOwnerIsInstigator, class APawn* instigator, const struct FVector& Location, const struct FVector& Velocity, float GravityScale, const struct FProjectileDamageOverrideData& DamageOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile");

	Params::ProjectileStatics_SpawnProjectile Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.definition = definition;
	Parms.owner = owner;
	Parms.bOwnerIsInstigator = bOwnerIsInstigator;
	Parms.instigator = instigator;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.GravityScale = GravityScale;
	Parms.DamageOverrides = std::move(DamageOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (projectile != nullptr)
		*projectile = Parms.projectile;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_Const
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOwnerIsInstigator                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GravityScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_Const(FGameDataHandleProperty_ definition, class AActor* owner, bool bOwnerIsInstigator, class APawn* instigator, const struct FVector& Location, const struct FVector& Velocity, float GravityScale, const struct FProjectileDamageOverrideData& DamageOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_Const");

	Params::ProjectileStatics_SpawnProjectile_Const Parms{};

	Parms.definition = definition;
	Parms.owner = owner;
	Parms.bOwnerIsInstigator = bOwnerIsInstigator;
	Parms.instigator = instigator;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.GravityScale = GravityScale;
	Parms.DamageOverrides = std::move(DamageOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_Source
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class Aprojectile**                     projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   SpeedOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GravityScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_Source(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, class Aprojectile** projectile, FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, float SpeedOverride, float GravityScale, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_Source");

	Params::ProjectileStatics_SpawnProjectile_Source Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.SpeedOverride = SpeedOverride;
	Parms.GravityScale = GravityScale;
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (projectile != nullptr)
		*projectile = Parms.projectile;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_Source_Const
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   SpeedOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GravityScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_Source_Const(FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, float SpeedOverride, float GravityScale, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_Source_Const");

	Params::ProjectileStatics_SpawnProjectile_Source_Const Parms{};

	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.SpeedOverride = SpeedOverride;
	Parms.GravityScale = GravityScale;
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_ThrowAtActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class Aprojectile**                     projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_ThrowAtActor(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, class Aprojectile** projectile, FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_ThrowAtActor");

	Params::ProjectileStatics_SpawnProjectile_ThrowAtActor Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (projectile != nullptr)
		*projectile = Parms.projectile;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_ThrowAtActor_Const
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      TargetOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_ThrowAtActor_Const(FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, class AActor* target, const struct FGbxRelativeLocation& TargetOptions, const struct FTrajectoryOptions& TrajectoryOptions, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_ThrowAtActor_Const");

	Params::ProjectileStatics_SpawnProjectile_ThrowAtActor_Const Parms{};

	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.target = target;
	Parms.TargetOptions = std::move(TargetOptions);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_ThrowAtCrosshair
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class Aprojectile**                     projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_ThrowAtCrosshair(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, class Aprojectile** projectile, FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, const struct FTrajectoryOptions& TrajectoryOptions, float TraceDistance, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_ThrowAtCrosshair");

	Params::ProjectileStatics_SpawnProjectile_ThrowAtCrosshair Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.TraceDistance = TraceDistance;
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (projectile != nullptr)
		*projectile = Parms.projectile;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_ThrowAtCrosshair_Const
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_ThrowAtCrosshair_Const(FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, const struct FTrajectoryOptions& TrajectoryOptions, float TraceDistance, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_ThrowAtCrosshair_Const");

	Params::ProjectileStatics_SpawnProjectile_ThrowAtCrosshair_Const Parms{};

	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.TraceDistance = TraceDistance;
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_ThrowAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class Aprojectile**                     projectile                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_ThrowAtLocation(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, class Aprojectile** projectile, FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, const struct FVector& Location, const struct FTrajectoryOptions& TrajectoryOptions, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_ThrowAtLocation");

	Params::ProjectileStatics_SpawnProjectile_ThrowAtLocation Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.Location = std::move(Location);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (projectile != nullptr)
		*projectile = Parms.projectile;
}


// Function GbxGame.ProjectileStatics.SpawnProjectile_ThrowAtLocation_Const
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGbxRelativeLocation&      SourceOptions                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      SourceRotation                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectoryOptions&        TrajectoryOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileOwnerOptions&   OwnerOptions                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxViewRelativeLocation&  SourceViewOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectile_ThrowAtLocation_Const(FGameDataHandleProperty_ definition, class AActor* Source, const struct FGbxRelativeLocation& SourceOptions, const struct FGbxRelativeRotation& SourceRotation, const struct FVector& Location, const struct FTrajectoryOptions& TrajectoryOptions, const struct FProjectileOwnerOptions& OwnerOptions, const struct FProjectileDamageOverrideData& DamageOverrides, const struct FGbxViewRelativeLocation& SourceViewOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectile_ThrowAtLocation_Const");

	Params::ProjectileStatics_SpawnProjectile_ThrowAtLocation_Const Parms{};

	Parms.definition = definition;
	Parms.Source = Source;
	Parms.SourceOptions = std::move(SourceOptions);
	Parms.SourceRotation = std::move(SourceRotation);
	Parms.Location = std::move(Location);
	Parms.TrajectoryOptions = std::move(TrajectoryOptions);
	Parms.OwnerOptions = std::move(OwnerOptions);
	Parms.DamageOverrides = std::move(DamageOverrides);
	Parms.SourceViewOptions = std::move(SourceViewOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ProjectileStatics.SpawnProjectiles_Query
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnProjectileExec*                   Exec                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class Aprojectile*>*             AllProjectiles                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class Aprojectile**                     SpawnedProjectile                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      Rotation                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectiles_Query(class UObject* WorldContext, const struct FLatentActionInfo& LatentInfo, ESpawnProjectileExec* Exec, TArray<class Aprojectile*>* AllProjectiles, class Aprojectile** SpawnedProjectile, FGameDataHandleProperty_ definition, class AActor* owner, const struct FGpsQueryRunData& QueryData, const struct FGbxRelativeRotation& Rotation, int32 MaxResults, float delay, const struct FProjectileDamageOverrideData& DamageOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectiles_Query");

	Params::ProjectileStatics_SpawnProjectiles_Query Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.definition = definition;
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.Rotation = std::move(Rotation);
	Parms.MaxResults = MaxResults;
	Parms.delay = delay;
	Parms.DamageOverrides = std::move(DamageOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exec != nullptr)
		*Exec = Parms.Exec;

	if (AllProjectiles != nullptr)
		*AllProjectiles = std::move(Parms.AllProjectiles);

	if (SpawnedProjectile != nullptr)
		*SpawnedProjectile = Parms.SpawnedProjectile;
}


// Function GbxGame.ProjectileStatics.SpawnProjectiles_Query_Const
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FGameDataHandleProperty_                definition                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGpsQueryRunData&          QueryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGbxRelativeRotation&      Rotation                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FProjectileDamageOverrideData&DamageOverrides                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UProjectileStatics::SpawnProjectiles_Query_Const(FGameDataHandleProperty_ definition, class AActor* owner, const struct FGpsQueryRunData& QueryData, const struct FGbxRelativeRotation& Rotation, int32 MaxResults, float delay, const struct FProjectileDamageOverrideData& DamageOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileStatics", "SpawnProjectiles_Query_Const");

	Params::ProjectileStatics_SpawnProjectiles_Query_Const Parms{};

	Parms.definition = definition;
	Parms.owner = owner;
	Parms.QueryData = std::move(QueryData);
	Parms.Rotation = std::move(Rotation);
	Parms.MaxResults = MaxResults;
	Parms.delay = delay;
	Parms.DamageOverrides = std::move(DamageOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.NexusActorDataLayerHelper.OnDataLayerInstanceRuntimeStateChanged
// (Final, Native, Private)
// Parameters:
// const class UDataLayerInstance*         InDataLayerInstance                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataLayerRuntimeState                  InEffectiveState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNexusActorDataLayerHelper::OnDataLayerInstanceRuntimeStateChanged(const class UDataLayerInstance* InDataLayerInstance, EDataLayerRuntimeState InEffectiveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NexusActorDataLayerHelper", "OnDataLayerInstanceRuntimeStateChanged");

	Params::NexusActorDataLayerHelper_OnDataLayerInstanceRuntimeStateChanged Parms{};

	Parms.InDataLayerInstance = InDataLayerInstance;
	Parms.InEffectiveState = InEffectiveState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.NexusConfigStoreInventory.GetAspectMeshGestaltPartNames
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TSoftObjectPtr<class UObject>           Mesh                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNexusConfigStoreInventory::GetAspectMeshGestaltPartNames(TSoftObjectPtr<class UObject> Mesh, TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreInventory", "GetAspectMeshGestaltPartNames");

	Params::NexusConfigStoreInventory_GetAspectMeshGestaltPartNames Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.NexusConfigStoreInventory.GetCriterionDisplayNames
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNexusConfigStoreInventory::GetCriterionDisplayNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreInventory", "GetCriterionDisplayNames");

	Params::NexusConfigStoreInventory_GetCriterionDisplayNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.NexusConfigStoreInventory.GetCriterionNameFromDisplayName
// (Final, Native, Static, Protected)
// Parameters:
// const class FString&                    DisplayName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNexusConfigStoreInventory::GetCriterionNameFromDisplayName(const class FString& DisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreInventory", "GetCriterionNameFromDisplayName");

	Params::NexusConfigStoreInventory_GetCriterionNameFromDisplayName Parms{};

	Parms.DisplayName = std::move(DisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.NexusConfigStoreInventory.GetCriterionNames
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNexusConfigStoreInventory::GetCriterionNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreInventory", "GetCriterionNames");

	Params::NexusConfigStoreInventory_GetCriterionNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.NexusConfigStoreInventory.GetCriterionTagNames
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNexusConfigStoreInventory::GetCriterionTagNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreInventory", "GetCriterionTagNames");

	Params::NexusConfigStoreInventory_GetCriterionTagNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.NexusConfigStoreInventory.GetStorePartTypeNames
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNexusConfigStoreInventory::GetStorePartTypeNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreInventory", "GetStorePartTypeNames");

	Params::NexusConfigStoreInventory_GetStorePartTypeNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.NexusConfigStoreInventoryStats.GetInventoryStatNames
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNexusConfigStoreInventoryStats::GetInventoryStatNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreInventoryStats", "GetInventoryStatNames");

	Params::NexusConfigStoreInventoryStats_GetInventoryStatNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.NexusConfigStoreItemPool.SpawnInventoryFromItemPool
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   gamestage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemPoolName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNexusConfigStoreItemPool::SpawnInventoryFromItemPool(class UObject* WorldContextObject, const struct FTransform& Transform, int32 gamestage, class FName ItemPoolName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NexusConfigStoreItemPool", "SpawnInventoryFromItemPool");

	Params::NexusConfigStoreItemPool_SpawnInventoryFromItemPool Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Transform = std::move(Transform);
	Parms.gamestage = gamestage;
	Parms.ItemPoolName = ItemPoolName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.Perch.K2_GetPerchComponent
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPerchComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerchComponent* APerch::K2_GetPerchComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perch", "K2_GetPerchComponent");

	Params::Perch_K2_GetPerchComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.ProjectileBounceStatics.GetGameplayBounceSurfaceType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FHitResult&                Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EProjectileGameplayBounceSurfaceType    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProjectileGameplayBounceSurfaceType UProjectileBounceStatics::GetGameplayBounceSurfaceType(const struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileBounceStatics", "GetGameplayBounceSurfaceType");

	Params::ProjectileBounceStatics_GetGameplayBounceSurfaceType Parms{};

	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxGame.PuddleHazardConfigurationData.GetParticleEmitterNames
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UPuddleHazardConfigurationData::GetParticleEmitterNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuddleHazardConfigurationData", "GetParticleEmitterNames");

	Params::PuddleHazardConfigurationData_GetParticleEmitterNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxGame.ScreenParticleManagerComponent.HideScreenParticleForActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowParticleToFinish                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::HideScreenParticleForActor(class AActor* Actor, class UFXSystemAsset* Template, class FName Tag, bool bAllowParticleToFinish, bool bServerAuthority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenParticleManagerComponent", "HideScreenParticleForActor");

	Params::ScreenParticleManagerComponent_HideScreenParticleForActor Parms{};

	Parms.Actor = Actor;
	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.bAllowParticleToFinish = bAllowParticleToFinish;
	Parms.bServerAuthority = bServerAuthority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ShowScreenParticleForActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideWhenFinished                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&ParticleParameters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 ContentDims                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParticleDepth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenParticleScalingMode              ScalingMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyOwnerSee                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowMultipleInstances                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTickEvenWhenPaused                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideDuringInGameMenu                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenParticleVisibility               ThirdPersonVisibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenParticleVisibility               FirstPersonVisibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideDuringCinematic                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ShowScreenParticleForActor(class AActor* Actor, class UFXSystemAsset* Template, bool bHideWhenFinished, const TArray<struct FGbxParticleParameter>& ParticleParameters, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, bool bOnlyOwnerSee, bool bAlwaysVisible, class FName Tag, bool bAllowMultipleInstances, bool bServerAuthority, bool bTickEvenWhenPaused, bool bHideDuringInGameMenu, EScreenParticleVisibility ThirdPersonVisibility, EScreenParticleVisibility FirstPersonVisibility, bool bHideDuringCinematic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScreenParticleManagerComponent", "ShowScreenParticleForActor");

	Params::ScreenParticleManagerComponent_ShowScreenParticleForActor Parms{};

	Parms.Actor = Actor;
	Parms.Template = Template;
	Parms.bHideWhenFinished = bHideWhenFinished;
	Parms.ParticleParameters = std::move(ParticleParameters);
	Parms.ContentDims = std::move(ContentDims);
	Parms.ParticleDepth = ParticleDepth;
	Parms.ScalingMode = ScalingMode;
	Parms.bOnlyOwnerSee = bOnlyOwnerSee;
	Parms.bAlwaysVisible = bAlwaysVisible;
	Parms.Tag = Tag;
	Parms.bAllowMultipleInstances = bAllowMultipleInstances;
	Parms.bServerAuthority = bServerAuthority;
	Parms.bTickEvenWhenPaused = bTickEvenWhenPaused;
	Parms.bHideDuringInGameMenu = bHideDuringInGameMenu;
	Parms.ThirdPersonVisibility = ThirdPersonVisibility;
	Parms.FirstPersonVisibility = FirstPersonVisibility;
	Parms.bHideDuringCinematic = bHideDuringCinematic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientHideScreenParticle
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowParticleToFinish                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientHideScreenParticle(class UFXSystemAsset* Template, class FName Tag, bool bAllowParticleToFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientHideScreenParticle");

	Params::ScreenParticleManagerComponent_ClientHideScreenParticle Parms{};

	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.bAllowParticleToFinish = bAllowParticleToFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientSetScreenParticleActorParameter
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientSetScreenParticleActorParameter(class UFXSystemAsset* Template, class FName Tag, class FName ParameterName, class AActor* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientSetScreenParticleActorParameter");

	Params::ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter Parms{};

	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientSetScreenParticleColorParameter
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientSetScreenParticleColorParameter(class UFXSystemAsset* Template, class FName Tag, class FName ParameterName, const struct FLinearColor& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientSetScreenParticleColorParameter");

	Params::ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter Parms{};

	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientSetScreenParticleFloatParameter
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientSetScreenParticleFloatParameter(class UFXSystemAsset* Template, class FName Tag, class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientSetScreenParticleFloatParameter");

	Params::ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter Parms{};

	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientSetScreenParticleMaterialParameter
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Param                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientSetScreenParticleMaterialParameter(class UFXSystemAsset* Template, class FName Tag, class FName ParameterName, class UMaterialInterface* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientSetScreenParticleMaterialParameter");

	Params::ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter Parms{};

	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientSetScreenParticleVectorParameter
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientSetScreenParticleVectorParameter(class UFXSystemAsset* Template, class FName Tag, class FName ParameterName, const struct FVector& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientSetScreenParticleVectorParameter");

	Params::ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter Parms{};

	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientShowScreenParticle
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideWhenFinished                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&ParticleParameters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 ContentDims                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParticleDepth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenParticleScalingMode              ScalingMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyOwnerSee                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowMultipleInstances                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTickEvenWhenPaused                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideDuringInGameMenu                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDepthPriorityWorld                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenParticleVisibility               ThirdPersonVisibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenParticleVisibility               FirstPersonVisibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideDuringCinematic                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientShowScreenParticle(class UFXSystemAsset* Template, bool bHideWhenFinished, const TArray<struct FGbxParticleParameter>& ParticleParameters, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, bool bOnlyOwnerSee, bool bAlwaysVisible, class FName Tag, bool bAllowMultipleInstances, bool bTickEvenWhenPaused, bool bHideDuringInGameMenu, bool bDepthPriorityWorld, EScreenParticleVisibility ThirdPersonVisibility, EScreenParticleVisibility FirstPersonVisibility, bool bHideDuringCinematic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientShowScreenParticle");

	Params::ScreenParticleManagerComponent_ClientShowScreenParticle Parms{};

	Parms.Template = Template;
	Parms.bHideWhenFinished = bHideWhenFinished;
	Parms.ParticleParameters = std::move(ParticleParameters);
	Parms.ContentDims = std::move(ContentDims);
	Parms.ParticleDepth = ParticleDepth;
	Parms.ScalingMode = ScalingMode;
	Parms.bOnlyOwnerSee = bOnlyOwnerSee;
	Parms.bAlwaysVisible = bAlwaysVisible;
	Parms.Tag = Tag;
	Parms.bAllowMultipleInstances = bAllowMultipleInstances;
	Parms.bTickEvenWhenPaused = bTickEvenWhenPaused;
	Parms.bHideDuringInGameMenu = bHideDuringInGameMenu;
	Parms.bDepthPriorityWorld = bDepthPriorityWorld;
	Parms.ThirdPersonVisibility = ThirdPersonVisibility;
	Parms.FirstPersonVisibility = FirstPersonVisibility;
	Parms.bHideDuringCinematic = bHideDuringCinematic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientShowScreenParticleEx
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  InitFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGbxParticleParameter>&ParticleParameters                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 ContentDims                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParticleDepth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenParticleScalingMode              ScalingMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientShowScreenParticleEx(class UFXSystemAsset* Template, uint16 InitFlags, const TArray<struct FGbxParticleParameter>& ParticleParameters, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientShowScreenParticleEx");

	Params::ScreenParticleManagerComponent_ClientShowScreenParticleEx Parms{};

	Parms.Template = Template;
	Parms.InitFlags = InitFlags;
	Parms.ParticleParameters = std::move(ParticleParameters);
	Parms.ContentDims = std::move(ContentDims);
	Parms.ParticleDepth = ParticleDepth;
	Parms.ScalingMode = ScalingMode;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.ScreenParticleManagerComponent.ClientTrackParticleProperty
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UParticlePropertyTrackingData*    TrackingData                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   Template                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PropertyValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               UsedMaterialProperty                                   (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MaterialPropertyName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenParticleManagerComponent::ClientTrackParticleProperty(class UParticlePropertyTrackingData* TrackingData, class UFXSystemAsset* Template, class FName Tag, class FName PropertyName, float PropertyValue, bool bAddToValue, class UMaterialInterface* UsedMaterialProperty, class FName MaterialPropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenParticleManagerComponent", "ClientTrackParticleProperty");

	Params::ScreenParticleManagerComponent_ClientTrackParticleProperty Parms{};

	Parms.TrackingData = TrackingData;
	Parms.Template = Template;
	Parms.Tag = Tag;
	Parms.PropertyName = PropertyName;
	Parms.PropertyValue = PropertyValue;
	Parms.bAddToValue = bAddToValue;
	Parms.UsedMaterialProperty = UsedMaterialProperty;
	Parms.MaterialPropertyName = MaterialPropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.SpawnEncounterCondition_Volume.OnTouchedTrigger
// (Final, Native, Private)
// Parameters:
// class AActor*                           TouchingActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpawnEncounterCondition_Volume::OnTouchedTrigger(class AActor* TouchingActor, bool bIsPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnEncounterCondition_Volume", "OnTouchedTrigger");

	Params::SpawnEncounterCondition_Volume_OnTouchedTrigger Parms{};

	Parms.TouchingActor = TouchingActor;
	Parms.bIsPlayer = bIsPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.SpawnEncounterCondition_Volume.OnUntouchedTrigger
// (Final, Native, Private)
// Parameters:
// class AActor*                           TouchingActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpawnEncounterCondition_Volume::OnUntouchedTrigger(class AActor* TouchingActor, bool bIsPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnEncounterCondition_Volume", "OnUntouchedTrigger");

	Params::SpawnEncounterCondition_Volume_OnUntouchedTrigger Parms{};

	Parms.TouchingActor = TouchingActor;
	Parms.bIsPlayer = bIsPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxGame.UsableFunctionLibrary.LockUsableInteractability
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUsableFunctionLibrary::LockUsableInteractability(class AActor* Actor, class FName reason, bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UsableFunctionLibrary", "LockUsableInteractability");

	Params::UsableFunctionLibrary_LockUsableInteractability Parms{};

	Parms.Actor = Actor;
	Parms.reason = reason;
	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

