#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxSpline

#include "Basic.hpp"

#include "GbxSpline_classes.hpp"
#include "GbxSpline_parameters.hpp"


namespace SDK
{

// Function GbxSpline.GbxSplineClutterRuleBase.EvaluateRule
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const TScriptInterface<class IGbxSplineSegment>&Segment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGbxSplineClutterEntry*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UGbxSplineClutterEntry*> UGbxSplineClutterRuleBase::EvaluateRule(const TScriptInterface<class IGbxSplineSegment>& Segment) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineClutterRuleBase", "EvaluateRule");

	Params::GbxSplineClutterRuleBase_EvaluateRule Parms{};

	Parms.Segment = Segment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterRuleBase.LandscapeAdjustmentHitFilter
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const class UGbxSplineClutterEntry*     Entry                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSplineClutterRuleBase::LandscapeAdjustmentHitFilter(const class UGbxSplineClutterEntry* Entry, const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineClutterRuleBase", "LandscapeAdjustmentHitFilter");

	Params::GbxSplineClutterRuleBase_LandscapeAdjustmentHitFilter Parms{};

	Parms.Entry = Entry;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterRuleBase.ObjectOverlapFilter
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class UGbxSplineClutterEntry*     Entry                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     OverlappedActor                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPrimitiveComponent*        OverlappedComponent                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSplineClutterRuleBase::ObjectOverlapFilter(const class UGbxSplineClutterEntry* Entry, const class AActor* OverlappedActor, const class UPrimitiveComponent* OverlappedComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineClutterRuleBase", "ObjectOverlapFilter");

	Params::GbxSplineClutterRuleBase_ObjectOverlapFilter Parms{};

	Parms.Entry = Entry;
	Parms.OverlappedActor = OverlappedActor;
	Parms.OverlappedComponent = OverlappedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterRuleBase.SelectClutter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UGbxSplineClutterObject*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxSplineClutterObject* UGbxSplineClutterRuleBase::SelectClutter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineClutterRuleBase", "SelectClutter");

	Params::GbxSplineClutterRuleBase_SelectClutter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.AreParamsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGbxSplineClutterEntryCreationParams&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGbxSplineClutterLibrary::AreParamsValid(const struct FGbxSplineClutterEntryCreationParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "AreParamsValid");

	Params::GbxSplineClutterLibrary_AreParamsValid Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.ComputeClutterBasisPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TScriptInterface<class IGbxSplineSegment>&Segment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxSplineClutterAnchorPoint            AnchorPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxSplineClutterBasisPoints     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGbxSplineClutterBasisPoints UGbxSplineClutterLibrary::ComputeClutterBasisPoints(const TScriptInterface<class IGbxSplineSegment>& Segment, EGbxSplineClutterAnchorPoint AnchorPoint, float LerpValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "ComputeClutterBasisPoints");

	Params::GbxSplineClutterLibrary_ComputeClutterBasisPoints Parms{};

	Parms.Segment = Segment;
	Parms.AnchorPoint = AnchorPoint;
	Parms.LerpValue = LerpValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.CreateActorClutterObject
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IGbxSplineSegment>&Segment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ActorClass                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSplineClutterObject*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxSplineClutterObject* UGbxSplineClutterLibrary::CreateActorClutterObject(const TScriptInterface<class IGbxSplineSegment>& Segment, TSoftClassPtr<class UClass> ActorClass, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "CreateActorClutterObject");

	Params::GbxSplineClutterLibrary_CreateActorClutterObject Parms{};

	Parms.Segment = Segment;
	Parms.ActorClass = ActorClass;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.CreateClutterEntry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGbxSplineClutterEntryCreationParams&params                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UGbxSplineClutterEntry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxSplineClutterEntry* UGbxSplineClutterLibrary::CreateClutterEntry(const struct FGbxSplineClutterEntryCreationParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "CreateClutterEntry");

	Params::GbxSplineClutterLibrary_CreateClutterEntry Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.CreateMeshClutterObject
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IGbxSplineSegment>&Segment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGbxSplineClutterObject*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGbxSplineClutterObject* UGbxSplineClutterLibrary::CreateMeshClutterObject(const TScriptInterface<class IGbxSplineSegment>& Segment, class UStaticMesh* Mesh, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "CreateMeshClutterObject");

	Params::GbxSplineClutterLibrary_CreateMeshClutterObject Parms{};

	Parms.Segment = Segment;
	Parms.Mesh = Mesh;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.InterpolateVarianceTransforms
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform&                min_0                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                MAX                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterpolateScaleUniformly                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UGbxSplineClutterLibrary::InterpolateVarianceTransforms(const struct FTransform& min_0, const struct FTransform& MAX, bool bInterpolateScaleUniformly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "InterpolateVarianceTransforms");

	Params::GbxSplineClutterLibrary_InterpolateVarianceTransforms Parms{};

	Parms.min_0 = std::move(min_0);
	Parms.MAX = std::move(MAX);
	Parms.bInterpolateScaleUniformly = bInterpolateScaleUniformly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.LerpAndOffsetToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const TScriptInterface<class IGbxSplineSegment>&Segment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxSplineClutterAnchorPoint            AnchorPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGbxSplineClutterLibrary::LerpAndOffsetToLocation(const TScriptInterface<class IGbxSplineSegment>& Segment, EGbxSplineClutterAnchorPoint AnchorPoint, float LerpValue, float Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "LerpAndOffsetToLocation");

	Params::GbxSplineClutterLibrary_LerpAndOffsetToLocation Parms{};

	Parms.Segment = Segment;
	Parms.AnchorPoint = AnchorPoint;
	Parms.LerpValue = LerpValue;
	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterLibrary.LocationToLerpAndOffset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const TScriptInterface<class IGbxSplineSegment>&Segment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxSplineClutterAnchorPoint            AnchorPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutLerpValue                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutOffset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxSplineClutterLibrary::LocationToLerpAndOffset(const TScriptInterface<class IGbxSplineSegment>& Segment, EGbxSplineClutterAnchorPoint AnchorPoint, const struct FVector& Location, float* OutLerpValue, float* OutOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "LocationToLerpAndOffset");

	Params::GbxSplineClutterLibrary_LocationToLerpAndOffset Parms{};

	Parms.Segment = Segment;
	Parms.AnchorPoint = AnchorPoint;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLerpValue != nullptr)
		*OutLerpValue = Parms.OutLerpValue;

	if (OutOffset != nullptr)
		*OutOffset = Parms.OutOffset;
}


// Function GbxSpline.GbxSplineClutterLibrary.SelectClutterEntryName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TScriptInterface<class IGbxSplineSegment>&Segment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      RuleName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGbxSplineClutterLibrary::SelectClutterEntryName(const TScriptInterface<class IGbxSplineSegment>& Segment, const class FText& RuleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxSplineClutterLibrary", "SelectClutterEntryName");

	Params::GbxSplineClutterLibrary_SelectClutterEntryName Parms{};

	Parms.Segment = Segment;
	Parms.RuleName = std::move(RuleName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterObject.GetBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds UGbxSplineClutterObject::GetBounds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineClutterObject", "GetBounds");

	Params::GbxSplineClutterObject_GetBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineClutterObject.InterpolateVariance
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UGbxSplineClutterObject::InterpolateVariance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxSplineClutterObject", "InterpolateVariance");

	Params::GbxSplineClutterObject_InterpolateVariance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineControlPoint.GetWidth
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IGbxSplineControlPoint::GetWidth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxSplineControlPoint", "GetWidth");

	Params::GbxSplineControlPoint_GetWidth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineControlPoint.IsIntersection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IGbxSplineControlPoint::IsIntersection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxSplineControlPoint", "IsIntersection");

	Params::GbxSplineControlPoint_IsIntersection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineSegment.GetEndControlPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class IGbxSplineControlPoint>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IGbxSplineControlPoint> IGbxSplineSegment::GetEndControlPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxSplineSegment", "GetEndControlPoint");

	Params::GbxSplineSegment_GetEndControlPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxSpline.GbxSplineSegment.GetStartControlPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class IGbxSplineControlPoint>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IGbxSplineControlPoint> IGbxSplineSegment::GetStartControlPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("GbxSplineSegment", "GetStartControlPoint");

	Params::GbxSplineSegment_GetStartControlPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

