#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxWeapon

#include "Basic.hpp"

#include "GbxWeapon_classes.hpp"
#include "GbxWeapon_parameters.hpp"


namespace SDK
{

// Function GbxWeapon.GbxAIHeldWeaponComponent.SpawnWeaponDelayed
// (Final, Native, Protected)

void UGbxAIHeldWeaponComponent::SpawnWeaponDelayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GbxAIHeldWeaponComponent", "SpawnWeaponDelayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.GbxWeaponHeldActorFunctionLibrary.AIHeldWeapon_Destroy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxWeaponHeldActorFunctionLibrary::AIHeldWeapon_Destroy(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxWeaponHeldActorFunctionLibrary", "AIHeldWeapon_Destroy");

	Params::GbxWeaponHeldActorFunctionLibrary_AIHeldWeapon_Destroy Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.GbxWeaponHeldActorFunctionLibrary.AIHeldWeapon_Drop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestNewHeldActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatorOverride                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGbxWeaponHeldActorFunctionLibrary::AIHeldWeapon_Drop(class AActor* AIActor, bool bRequestNewHeldActor, class FName ID, EGbxAIHeldFilterType FilterType, class AActor* InstigatorOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxWeaponHeldActorFunctionLibrary", "AIHeldWeapon_Drop");

	Params::GbxWeaponHeldActorFunctionLibrary_AIHeldWeapon_Drop Parms{};

	Parms.AIActor = AIActor;
	Parms.bRequestNewHeldActor = bRequestNewHeldActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.InstigatorOverride = InstigatorOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.GbxWeaponHeldActorFunctionLibrary.AIHeldWeapon_GetActors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AWeapon*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AWeapon*> UGbxWeaponHeldActorFunctionLibrary::AIHeldWeapon_GetActors(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxWeaponHeldActorFunctionLibrary", "AIHeldWeapon_GetActors");

	Params::GbxWeaponHeldActorFunctionLibrary_AIHeldWeapon_GetActors Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.GbxWeaponHeldActorFunctionLibrary.AIHeldWeapon_Spawn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AIActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGbxAIHeldFilterType                    FilterType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInventoryItemSelectionData&WeaponOverride                                         (Parm, NativeAccessSpecifierPublic)

void UGbxWeaponHeldActorFunctionLibrary::AIHeldWeapon_Spawn(class AActor* AIActor, class FName ID, EGbxAIHeldFilterType FilterType, const struct FInventoryItemSelectionData& WeaponOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GbxWeaponHeldActorFunctionLibrary", "AIHeldWeapon_Spawn");

	Params::GbxWeaponHeldActorFunctionLibrary_AIHeldWeapon_Spawn Parms{};

	Parms.AIActor = AIActor;
	Parms.ID = ID;
	Parms.FilterType = FilterType;
	Parms.WeaponOverride = std::move(WeaponOverride);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ClientConsumeAmmo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ClientConsumeAmmo(uint8 UseModeIndex, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ClientConsumeAmmo");

	Params::Weapon_ClientConsumeAmmo Parms{};

	Parms.UseModeIndex = UseModeIndex;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ClientLock
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ClientLock(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ClientLock");

	Params::Weapon_ClientLock Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ClientRefillAmmo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ClientRefillAmmo(uint8 UseModeIndex, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ClientRefillAmmo");

	Params::Weapon_ClientRefillAmmo Parms{};

	Parms.UseModeIndex = UseModeIndex;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ClientSetAmmoState
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FReplicatedAmmoState&      NewState                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AWeapon::ClientSetAmmoState(uint8 UseModeIndex, const struct FReplicatedAmmoState& NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ClientSetAmmoState");

	Params::Weapon_ClientSetAmmoState Parms{};

	Parms.UseModeIndex = UseModeIndex;
	Parms.NewState = std::move(NewState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ClientSetLoadedAmmo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewLoadedAmmo                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ClientSetLoadedAmmo(uint8 UseModeIndex, int32 NewLoadedAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ClientSetLoadedAmmo");

	Params::Weapon_ClientSetLoadedAmmo Parms{};

	Parms.UseModeIndex = UseModeIndex;
	Parms.NewLoadedAmmo = NewLoadedAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ClientStopReloading
// (Net, NetReliable, Native, Event, Protected, NetClient)

void AWeapon::ClientStopReloading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ClientStopReloading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ClientUnlock
// (Net, NetReliable, Native, Event, Protected, NetClient)

void AWeapon::ClientUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ClientUnlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnNotifyBodyControlsOfTargetLock
// (Final, Native, Protected)
// Parameters:
// class AWeapon*                          EventWeapon                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockedOn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::OnNotifyBodyControlsOfTargetLock(class AWeapon* EventWeapon, bool bLockedOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnNotifyBodyControlsOfTargetLock");

	Params::Weapon_OnNotifyBodyControlsOfTargetLock Parms{};

	Parms.EventWeapon = EventWeapon;
	Parms.bLockedOn = bLockedOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_AltHeatState
// (Final, Native, Protected)

void AWeapon::OnRep_AltHeatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_AltHeatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_CurrentUseModeIndex
// (Final, Native, Protected)
// Parameters:
// uint8                                   PreviousUseModeIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::OnRep_CurrentUseModeIndex(uint8 PreviousUseModeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_CurrentUseModeIndex");

	Params::Weapon_OnRep_CurrentUseModeIndex Parms{};

	Parms.PreviousUseModeIndex = PreviousUseModeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_PendingAttachState
// (Final, Native, Protected)

void AWeapon::OnRep_PendingAttachState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_PendingAttachState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_PendingUseModeIndex
// (Final, Native, Protected)

void AWeapon::OnRep_PendingUseModeIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_PendingUseModeIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_PrimaryHeatState
// (Final, Native, Protected)

void AWeapon::OnRep_PrimaryHeatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_PrimaryHeatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_RemoteShotSocketState
// (Final, Native, Protected)

void AWeapon::OnRep_RemoteShotSocketState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_RemoteShotSocketState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_RemoteShotState
// (Final, Native, Protected)

void AWeapon::OnRep_RemoteShotState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_RemoteShotState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.OnRep_VisibleAmmoState
// (Final, Native, Protected)

void AWeapon::OnRep_VisibleAmmoState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnRep_VisibleAmmoState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.PlayEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUntilStopped                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::PlayEffects(class FName type, uint8 UseModeIndex, int32 ID, bool bUntilStopped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "PlayEffects");

	Params::Weapon_PlayEffects Parms{};

	Parms.type = type;
	Parms.UseModeIndex = UseModeIndex;
	Parms.ID = ID;
	Parms.bUntilStopped = bUntilStopped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerAmmoGivenToInterruptedReload
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AWeapon::ServerAmmoGivenToInterruptedReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerAmmoGivenToInterruptedReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerEquipInterruptible
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AWeapon::ServerEquipInterruptible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerEquipInterruptible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerInterruptReloadToUse
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   ClientLoadedAmmo                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerInterruptReloadToUse(int32 ClientLoadedAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerInterruptReloadToUse");

	Params::Weapon_ServerInterruptReloadToUse Parms{};

	Parms.ClientLoadedAmmo = ClientLoadedAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerLock
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerLock(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerLock");

	Params::Weapon_ServerLock Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerRestartAutoUse
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AWeapon::ServerRestartAutoUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerRestartAutoUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerSendAmmoState
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerSendAmmoState(uint8 UseModeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerSendAmmoState");

	Params::Weapon_ServerSendAmmoState Parms{};

	Parms.UseModeIndex = UseModeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerSetPatternSeed
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// uint16                                  ClientPatternSeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerSetPatternSeed(uint16 ClientPatternSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerSetPatternSeed");

	Params::Weapon_ServerSetPatternSeed Parms{};

	Parms.ClientPatternSeed = ClientPatternSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerStartReloading
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerStartReloading(uint8 UseModeIndex, uint8 Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerStartReloading");

	Params::Weapon_ServerStartReloading Parms{};

	Parms.UseModeIndex = UseModeIndex;
	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerStartUsing
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// uint8                                   InputChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  ClientPatternSeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerStartUsing(uint8 InputChannel, uint16 ClientPatternSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerStartUsing");

	Params::Weapon_ServerStartUsing Parms{};

	Parms.InputChannel = InputChannel;
	Parms.ClientPatternSeed = ClientPatternSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerStopModeSwitch
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// uint8                                   InputChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientUseModeIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerStopModeSwitch(uint8 InputChannel, uint8 ClientUseModeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerStopModeSwitch");

	Params::Weapon_ServerStopModeSwitch Parms{};

	Parms.InputChannel = InputChannel;
	Parms.ClientUseModeIndex = ClientUseModeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerStopUsing
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// uint8                                   InputChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  SyncData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerStopUsing(uint8 InputChannel, bool bForced, uint16 SyncData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerStopUsing");

	Params::Weapon_ServerStopUsing Parms{};

	Parms.InputChannel = InputChannel;
	Parms.bForced = bForced;
	Parms.SyncData = SyncData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerSwitchMode
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// uint8                                   InputChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NextUseModeIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   SwitchOption                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerSwitchMode(uint8 InputChannel, uint8 NextUseModeIndex, bool bForced, uint8 SwitchOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerSwitchMode");

	Params::Weapon_ServerSwitchMode Parms{};

	Parms.InputChannel = InputChannel;
	Parms.NextUseModeIndex = NextUseModeIndex;
	Parms.bForced = bForced;
	Parms.SwitchOption = SwitchOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerUnlock
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AWeapon::ServerUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerUnlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.ServerUpdateFPUseOffet
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// const struct FVector_NetQuantize100&    Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::ServerUpdateFPUseOffet(const struct FVector_NetQuantize100& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "ServerUpdateFPUseOffet");

	Params::Weapon_ServerUpdateFPUseOffet Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.StopAllEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::StopAllEffects(class FName type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "StopAllEffects");

	Params::Weapon_StopAllEffects Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.StopEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   UseModeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyStopLoopingEffects                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeapon::StopEffects(class FName type, uint8 UseModeIndex, bool bOnlyStopLoopingEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "StopEffects");

	Params::Weapon_StopEffects Parms{};

	Parms.type = type;
	Parms.UseModeIndex = UseModeIndex;
	Parms.bOnlyStopLoopingEffects = bOnlyStopLoopingEffects;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.Weapon.GetTargetLockChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponTargetLockChannel                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponTargetLockChannel AWeapon::GetTargetLockChannel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetTargetLockChannel");

	Params::Weapon_GetTargetLockChannel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.Weapon.IsTargetLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeapon::IsTargetLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsTargetLocked");

	Params::Weapon_IsTargetLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponBehavior_Fire.OnRep_FireRateAccelChanged
// (Final, Native, Protected)

void UWeaponBehavior_Fire::OnRep_FireRateAccelChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBehavior_Fire", "OnRep_FireRateAccelChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponBehavior_Sway.OnAttached
// (Final, Native, Protected)

void UWeaponBehavior_Sway::OnAttached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBehavior_Sway", "OnAttached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponBehavior_Sway.OnZoomed
// (Final, Native, Protected)
// Parameters:
// uint8                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponBehavior_Sway::OnZoomed(uint8 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBehavior_Sway", "OnZoomed");

	Params::WeaponBehavior_Sway_OnZoomed Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponBehavior_VisibleAmmo.OnAttached
// (Final, Native, Protected)

void UWeaponBehavior_VisibleAmmo::OnAttached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBehavior_VisibleAmmo", "OnAttached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponBehavior_VisibleAmmo.OnDetached
// (Final, Native, Protected)

void UWeaponBehavior_VisibleAmmo::OnDetached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBehavior_VisibleAmmo", "OnDetached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponBehavior_VisibleAmmo.OnSwitchedMode
// (Final, Native, Protected)

void UWeaponBehavior_VisibleAmmo::OnSwitchedMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBehavior_VisibleAmmo", "OnSwitchedMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponBehavior_VisibleAmmo.OnSwitchModeStarted
// (Final, Native, Protected)

void UWeaponBehavior_VisibleAmmo::OnSwitchModeStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBehavior_VisibleAmmo", "OnSwitchModeStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.ConsumeAmmo
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::ConsumeAmmo(class AWeapon* Weapon, int32 Amount, bool bAsPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "ConsumeAmmo");

	Params::WeaponStatics_ConsumeAmmo Parms{};

	Parms.Weapon = Weapon;
	Parms.Amount = Amount;
	Parms.bAsPercent = bAsPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.GetCurrentDamageType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ UWeaponStatics::GetCurrentDamageType(class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetCurrentDamageType");

	Params::WeaponStatics_GetCurrentDamageType Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.GetDamageType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   UseMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FGameDataHandleProperty_ UWeaponStatics::GetDamageType(class AWeapon* Weapon, uint8 UseMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetDamageType");

	Params::WeaponStatics_GetDamageType Parms{};

	Parms.Weapon = Weapon;
	Parms.UseMode = UseMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.GetEditorBodyActionNames
// (Final, Native, Static, Protected, HasOutParams)
// Parameters:
// TArray<class FName>*                    OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UWeaponStatics::GetEditorBodyActionNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetEditorBodyActionNames");

	Params::WeaponStatics_GetEditorBodyActionNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function GbxWeapon.WeaponStatics.GetFireRateAccelPercent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   UseMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeaponStatics::GetFireRateAccelPercent(class AWeapon* Weapon, uint8 UseMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetFireRateAccelPercent");

	Params::WeaponStatics_GetFireRateAccelPercent Parms{};

	Parms.Weapon = Weapon;
	Parms.UseMode = UseMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.GetLoadedAmmo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   UseMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponStatics::GetLoadedAmmo(class AWeapon* Weapon, uint8 UseMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetLoadedAmmo");

	Params::WeaponStatics_GetLoadedAmmo Parms{};

	Parms.Weapon = Weapon;
	Parms.UseMode = UseMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.GetMaxLoadedAmmo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   UseMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponStatics::GetMaxLoadedAmmo(class AWeapon* Weapon, uint8 UseMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetMaxLoadedAmmo");

	Params::WeaponStatics_GetMaxLoadedAmmo Parms{};

	Parms.Weapon = Weapon;
	Parms.UseMode = UseMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.GetWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWeapon*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeapon* UWeaponStatics::GetWeapon(class AActor* WeaponUser, uint8 slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetWeapon");

	Params::WeaponStatics_GetWeapon Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.slot = slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.GetWeaponViewRelativeSocketTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UWeaponStatics::GetWeaponViewRelativeSocketTransform(class AWeapon* Weapon, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GetWeaponViewRelativeSocketTransform");

	Params::WeaponStatics_GetWeaponViewRelativeSocketTransform Parms{};

	Parms.Weapon = Weapon;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.GiveAmmo
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoaded                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::GiveAmmo(class AWeapon* Weapon, int32 Amount, bool bLoaded, bool bAsPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "GiveAmmo");

	Params::WeaponStatics_GiveAmmo Parms{};

	Parms.Weapon = Weapon;
	Parms.Amount = Amount;
	Parms.bLoaded = bLoaded;
	Parms.bAsPercent = bAsPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.HasPartDependencyTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       Tag                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponStatics::HasPartDependencyTag(class AWeapon* Weapon, const class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "HasPartDependencyTag");

	Params::WeaponStatics_HasPartDependencyTag Parms{};

	Parms.Weapon = Weapon;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.HideWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::HideWeapon(class AActor* WeaponUser, uint8 slot, class FName reason, bool bServerAuthority, bool bPlayAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "HideWeapon");

	Params::WeaponStatics_HideWeapon Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.slot = slot;
	Parms.reason = reason;
	Parms.bServerAuthority = bServerAuthority;
	Parms.bPlayAnimation = bPlayAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.HideWeapons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::HideWeapons(class AActor* WeaponUser, class FName reason, bool bServerAuthority, bool bPlayAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "HideWeapons");

	Params::WeaponStatics_HideWeapons Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.reason = reason;
	Parms.bServerAuthority = bServerAuthority;
	Parms.bPlayAnimation = bPlayAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.IsLocalWeaponAuthority
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponStatics::IsLocalWeaponAuthority(class AActor* WeaponUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "IsLocalWeaponAuthority");

	Params::WeaponStatics_IsLocalWeaponAuthority Parms{};

	Parms.WeaponUser = WeaponUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponStatics.RefillAmmo
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::RefillAmmo(class AWeapon* Weapon, int32 Amount, bool bAsPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "RefillAmmo");

	Params::WeaponStatics_RefillAmmo Parms{};

	Parms.Weapon = Weapon;
	Parms.Amount = Amount;
	Parms.bAsPercent = bAsPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.RefillAmmoForCurrentWeapon
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          OwnerContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::RefillAmmoForCurrentWeapon(class UObject* OwnerContext, int32 Amount, bool bAsPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "RefillAmmoForCurrentWeapon");

	Params::WeaponStatics_RefillAmmoForCurrentWeapon Parms{};

	Parms.OwnerContext = OwnerContext;
	Parms.Amount = Amount;
	Parms.bAsPercent = bAsPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.ResetVisibleAmmoState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::ResetVisibleAmmoState(class AWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "ResetVisibleAmmoState");

	Params::WeaponStatics_ResetVisibleAmmoState Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.RestrictWeapons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::RestrictWeapons(class AActor* WeaponUser, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "RestrictWeapons");

	Params::WeaponStatics_RestrictWeapons Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.SetVisibleAmmoState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVisibleAmmoState                       NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::SetVisibleAmmoState(class AWeapon* Weapon, EVisibleAmmoState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "SetVisibleAmmoState");

	Params::WeaponStatics_SetVisibleAmmoState Parms{};

	Parms.Weapon = Weapon;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.SetVisibleAmmoUpdateMethod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVisibleAmmoUpdateMethod                NewUpdateMethod                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::SetVisibleAmmoUpdateMethod(class AWeapon* Weapon, EVisibleAmmoUpdateMethod NewUpdateMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "SetVisibleAmmoUpdateMethod");

	Params::WeaponStatics_SetVisibleAmmoUpdateMethod Parms{};

	Parms.Weapon = Weapon;
	Parms.NewUpdateMethod = NewUpdateMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.ToggleWeaponMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::ToggleWeaponMode(class AActor* WeaponUser, uint8 slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "ToggleWeaponMode");

	Params::WeaponStatics_ToggleWeaponMode Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.slot = slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.UnhideWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::UnhideWeapon(class AActor* WeaponUser, uint8 slot, class FName reason, bool bServerAuthority, bool bPlayAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "UnhideWeapon");

	Params::WeaponStatics_UnhideWeapon Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.slot = slot;
	Parms.reason = reason;
	Parms.bServerAuthority = bServerAuthority;
	Parms.bPlayAnimation = bPlayAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.UnhideWeapons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::UnhideWeapons(class AActor* WeaponUser, class FName reason, bool bServerAuthority, bool bPlayAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "UnhideWeapons");

	Params::WeaponStatics_UnhideWeapons Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.reason = reason;
	Parms.bServerAuthority = bServerAuthority;
	Parms.bPlayAnimation = bPlayAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.UnrestrictWeapons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WeaponUser                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::UnrestrictWeapons(class AActor* WeaponUser, class FName reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "UnrestrictWeapons");

	Params::WeaponStatics_UnrestrictWeapons Parms{};

	Parms.WeaponUser = WeaponUser;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponStatics.UpdateAmmoVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWeapon*                          Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponStatics::UpdateAmmoVisibility(class AWeapon* Weapon, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponStatics", "UpdateAmmoVisibility");

	Params::WeaponStatics_UpdateAmmoVisibility Parms{};

	Parms.Weapon = Weapon;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.AddTargetLock
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FGameDataHandleProperty_                Effect                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRelativeOffset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerAuthority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponTargetLockFunctionLibrary::AddTargetLock(class AActor* Source, EWeaponTargetLockChannel channel, class AActor* target, const struct FVector& Offset, class FName socket, float Duration, FGameDataHandleProperty_ Effect, bool bRelativeOffset, bool bServerAuthority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "AddTargetLock");

	Params::WeaponTargetLockFunctionLibrary_AddTargetLock Parms{};

	Parms.Source = Source;
	Parms.channel = channel;
	Parms.target = target;
	Parms.Offset = std::move(Offset);
	Parms.socket = socket;
	Parms.Duration = Duration;
	Parms.Effect = Effect;
	Parms.bRelativeOffset = bRelativeOffset;
	Parms.bServerAuthority = bServerAuthority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.DoesSourceHaveLockOnTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponTargetLockFunctionLibrary::DoesSourceHaveLockOnTarget(class AActor* Source, EWeaponTargetLockChannel channel, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "DoesSourceHaveLockOnTarget");

	Params::WeaponTargetLockFunctionLibrary_DoesSourceHaveLockOnTarget Parms{};

	Parms.Source = Source;
	Parms.channel = channel;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.GetRandomTargetLock
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponTargetLockResult*         Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponTargetLockFunctionLibrary::GetRandomTargetLock(class AActor* Source, EWeaponTargetLockChannel channel, struct FWeaponTargetLockResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "GetRandomTargetLock");

	Params::WeaponTargetLockFunctionLibrary_GetRandomTargetLock Parms{};

	Parms.Source = Source;
	Parms.channel = channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.GetTargetLockList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FWeaponTargetLockResult>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWeaponTargetLockResult> UWeaponTargetLockFunctionLibrary::GetTargetLockList(class AActor* Source, EWeaponTargetLockChannel channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "GetTargetLockList");

	Params::WeaponTargetLockFunctionLibrary_GetTargetLockList Parms{};

	Parms.Source = Source;
	Parms.channel = channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.HasTargetLock
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponTargetLockFunctionLibrary::HasTargetLock(class AActor* Source, EWeaponTargetLockChannel channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "HasTargetLock");

	Params::WeaponTargetLockFunctionLibrary_HasTargetLock Parms{};

	Parms.Source = Source;
	Parms.channel = channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.NumTargetLocks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponTargetLockFunctionLibrary::NumTargetLocks(class AActor* Source, EWeaponTargetLockChannel channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "NumTargetLocks");

	Params::WeaponTargetLockFunctionLibrary_NumTargetLocks Parms{};

	Parms.Source = Source;
	Parms.channel = channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.RemoveAllTargetLocks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponTargetLockFunctionLibrary::RemoveAllTargetLocks(class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "RemoveAllTargetLocks");

	Params::WeaponTargetLockFunctionLibrary_RemoveAllTargetLocks Parms{};

	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.RemoveAllTargetLocksForSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponTargetLockFunctionLibrary::RemoveAllTargetLocksForSource(class AActor* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "RemoveAllTargetLocksForSource");

	Params::WeaponTargetLockFunctionLibrary_RemoveAllTargetLocksForSource Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.RemoveAllTargetLocksForSourceChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponTargetLockFunctionLibrary::RemoveAllTargetLocksForSourceChannel(class AActor* Source, EWeaponTargetLockChannel channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "RemoveAllTargetLocksForSourceChannel");

	Params::WeaponTargetLockFunctionLibrary_RemoveAllTargetLocksForSourceChannel Parms{};

	Parms.Source = Source;
	Parms.channel = channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.RemoveTargetLock
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LockId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponTargetLockFunctionLibrary::RemoveTargetLock(class UObject* WorldContext, int32 LockId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "RemoveTargetLock");

	Params::WeaponTargetLockFunctionLibrary_RemoveTargetLock Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LockId = LockId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxWeapon.WeaponTargetLockFunctionLibrary.RemoveTargetLocksBetweenSourceAndTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponTargetLockChannel                channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponTargetLockFunctionLibrary::RemoveTargetLocksBetweenSourceAndTarget(class AActor* Source, EWeaponTargetLockChannel channel, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponTargetLockFunctionLibrary", "RemoveTargetLocksBetweenSourceAndTarget");

	Params::WeaponTargetLockFunctionLibrary_RemoveTargetLocksBetweenSourceAndTarget Parms{};

	Parms.Source = Source;
	Parms.channel = channel;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

